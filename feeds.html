
    <!DOCTYPE html>
    <html lang="en">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <meta name="description" content="Security alerts and cybersecurity news feeds">
        <meta name="keywords" content="cybersecurity news, security alerts, vulnerability feeds, threat intelligence">
        <meta name="author" content="dotne1">
        <meta property="og:title" content="Security Feeds - dotne1's Cybersecurity Portfolio">
        <meta property="og:description" content="Stay updated with the latest cybersecurity news and alerts">
        <meta property="og:type" content="website">
        <title>Security Feeds - dotne1's Cybersecurity Portfolio</title>
        <link rel="stylesheet" href="styles.css">
        <link rel="icon" type="image/x-icon" href="/favicon.ico">
    </head>
    <body>
        <nav class="navbar">
            <div class="nav-links">
                <a href="index.html" class="nav-link">Home</a>
                <a href="about-me.html" class="nav-link">About Me</a>
                <a href="projects.html" class="nav-link">Projects</a>
                <a href="resume.html" class="nav-link">Resume</a>
                <a href="feeds.html" class="nav-link">Feeds</a>
            </div>
        </nav>

        <div class="container" role="main">
            <h1 class="main-header">Security Feeds</h1>
            <div class="search-bar">
                <input type="text" id="searchInput" placeholder="Search CVEs..." onkeyup="searchCVEs()">
            </div>
            <div class="feed-preview" id="cveFeed">
                <div class="feed-header">Latest Vulnerabilities</div>
    
                <div class="cve-entry" data-cve-id="CVE-2025-39963" data-description="in the linux kernel, the following vulnerability has been resolved:

io_uring: fix incorrect io_kiocb reference in io_link_skb

in io_link_skb function, there is a bug where prev_notif is incorrectly
assigned using 'nd' instead of 'prev_nd'. this causes the context
validation check to compare the current notification with itself instead
of comparing it with the previous notification.

fix by using the correct prev_nd parameter when obtaining prev_notif.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-39963" target="_blank">CVE-2025-39963</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-10-09 08:15:32 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">N/A</span></p>
                    <p><span class="feed-label">CVSS Score:</span> N/A</p>
                    <p>In the Linux kernel, the following vulnerability has been resolved:

io_uring: fix incorrect io_kiocb reference in io_link_skb

In io_link_skb function, there is a bug where prev_notif is incorrectly
assigned using 'nd' instead of 'prev_nd'. This causes the context
validation check to compare the current notification with itself instead
of comparing it with the previous notification.

Fix by using the correct prev_nd parameter when obtaining prev_notif.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-39962" data-description="in the linux kernel, the following vulnerability has been resolved:

rxrpc: fix untrusted unsigned subtract

fix the following smatch static checker warning:

   net/rxrpc/rxgk_app.c:65 rxgk_yfs_decode_ticket()
   warn: untrusted unsigned subtract. 'ticket_len - 10 * 4'

by prechecking the length of what we're trying to extract in two places in
the token and decoding for a response packet.

also use sizeof() on the struct we're extracting rather specifying the size
numerically to be consistent with the other related statements.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-39962" target="_blank">CVE-2025-39962</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-10-09 08:15:32 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">N/A</span></p>
                    <p><span class="feed-label">CVSS Score:</span> N/A</p>
                    <p>In the Linux kernel, the following vulnerability has been resolved:

rxrpc: Fix untrusted unsigned subtract

Fix the following Smatch static checker warning:

   net/rxrpc/rxgk_app.c:65 rxgk_yfs_decode_ticket()
   warn: untrusted unsigned subtract. 'ticket_len - 10 * 4'

by prechecking the length of what we're trying to extract in two places in
the token and decoding for a response packet.

Also use sizeof() on the struct we're extracting rather specifying the size
numerically to be consistent with the other related statements.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-39961" data-description="in the linux kernel, the following vulnerability has been resolved:

iommu/amd/pgtbl: fix possible race while increase page table level

the amd iommu host page table implementation supports dynamic page table levels
(up to 6 levels), starting with a 3-level configuration that expands based on
iova address. the kernel maintains a root pointer and current page table level
to enable proper page table walks in alloc_pte()/fetch_pte() operations.

the iommu iova allocator initially starts with 32-bit address and onces its
exhuasted it switches to 64-bit address (max address is determined based
on iommu and device dma capability). to support larger iova, amd iommu
driver increases page table level.

but in unmap path (iommu_v1_unmap_pages()), fetch_pte() reads
pgtable->[root/mode] without lock. so its possible that in exteme corner case,
when increase_address_space() is updating pgtable->[root/mode], fetch_pte()
reads wrong page table level (pgtable->mode). it does compare the value with
level encoded in page table and returns null. this will result is
iommu_unmap ops to fail and upper layer may retry/log warn_on.

cpu 0                                         cpu 1
------                                       ------
map pages                                    unmap pages
alloc_pte() -> increase_address_space()      iommu_v1_unmap_pages() -> fetch_pte()
  pgtable->root = pte (new root value)
                                             read pgtable->[mode/root]
					       reads new root, old mode
  updates mode (pgtable->mode += 1)

since page table level updates are infrequent and already synchronized with a
spinlock, implement seqcount to enable lock-free read operations on the read path.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-39961" target="_blank">CVE-2025-39961</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-10-09 08:15:32 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">N/A</span></p>
                    <p><span class="feed-label">CVSS Score:</span> N/A</p>
                    <p>In the Linux kernel, the following vulnerability has been resolved:

iommu/amd/pgtbl: Fix possible race while increase page table level

The AMD IOMMU host page table implementation supports dynamic page table levels
(up to 6 levels), starting with a 3-level configuration that expands based on
IOVA address. The kernel maintains a root pointer and current page table level
to enable proper page table walks in alloc_pte()/fetch_pte() operations.

The IOMMU IOVA allocator initially starts with 32-bit address and onces its
exhuasted it switches to 64-bit address (max address is determined based
on IOMMU and device DMA capability). To support larger IOVA, AMD IOMMU
driver increases page table level.

But in unmap path (iommu_v1_unmap_pages()), fetch_pte() reads
pgtable->[root/mode] without lock. So its possible that in exteme corner case,
when increase_address_space() is updating pgtable->[root/mode], fetch_pte()
reads wrong page table level (pgtable->mode). It does compare the value with
level encoded in page table and returns NULL. This will result is
iommu_unmap ops to fail and upper layer may retry/log WARN_ON.

CPU 0                                         CPU 1
------                                       ------
map pages                                    unmap pages
alloc_pte() -> increase_address_space()      iommu_v1_unmap_pages() -> fetch_pte()
  pgtable->root = pte (new root value)
                                             READ pgtable->[mode/root]
					       Reads new root, old mode
  Updates mode (pgtable->mode += 1)

Since Page table level updates are infrequent and already synchronized with a
spinlock, implement seqcount to enable lock-free read operations on the read path.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-39960" data-description="in the linux kernel, the following vulnerability has been resolved:

gpiolib: acpi: initialize acpi_gpio_info struct

since commit 7c010d463372 ("gpiolib: acpi: make sure we fill struct
acpi_gpio_info"), uninitialized acpi_gpio_info struct are passed to
__acpi_find_gpio() and later in the call stack info->quirks is used in
acpi_populate_gpio_lookup. this breaks the i2c_hid_cpi driver:

[   58.122916] i2c_hid_acpi i2c-uniw0001:00: hid over i2c has not been provided an int irq
[   58.123097] i2c_hid_acpi i2c-uniw0001:00: probe with driver i2c_hid_acpi failed with error -22

fix this by initializing the acpi_gpio_info pass to __acpi_find_gpio()">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-39960" target="_blank">CVE-2025-39960</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-10-09 08:15:32 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">N/A</span></p>
                    <p><span class="feed-label">CVSS Score:</span> N/A</p>
                    <p>In the Linux kernel, the following vulnerability has been resolved:

gpiolib: acpi: initialize acpi_gpio_info struct

Since commit 7c010d463372 ("gpiolib: acpi: Make sure we fill struct
acpi_gpio_info"), uninitialized acpi_gpio_info struct are passed to
__acpi_find_gpio() and later in the call stack info->quirks is used in
acpi_populate_gpio_lookup. This breaks the i2c_hid_cpi driver:

[   58.122916] i2c_hid_acpi i2c-UNIW0001:00: HID over i2c has not been provided an Int IRQ
[   58.123097] i2c_hid_acpi i2c-UNIW0001:00: probe with driver i2c_hid_acpi failed with error -22

Fix this by initializing the acpi_gpio_info pass to __acpi_find_gpio()</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-10240" data-description="a vulnerability exists in the progress flowmon web application prior to version 12.5.5, whereby a user who clicks a malicious link provided by an attacker may inadvertently trigger unintended actions within their authenticated session.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-10240" target="_blank">CVE-2025-10240</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-10-09 08:15:31 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-online">HIGH</span></p>
                    <p><span class="feed-label">CVSS Score:</span> 8.8</p>
                    <p>A vulnerability exists in the Progress Flowmon web application prior to version 12.5.5, whereby a user who clicks a malicious link provided by an attacker may inadvertently trigger unintended actions within their authenticated session.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-10239" data-description="in flowmon versions prior to 12.5.5, a vulnerability has been identified that allows a user with administrator privileges and access to the management interface to execute additional unintended commands within scripts intended for troubleshooting purposes.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-10239" target="_blank">CVE-2025-10239</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-10-09 08:15:31 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-online">HIGH</span></p>
                    <p><span class="feed-label">CVSS Score:</span> 7.2</p>
                    <p>In Flowmon versions prior to 12.5.5, a vulnerability has been identified that allows a user with administrator privileges and access to the management interface to execute additional unintended commands within scripts intended for troubleshooting purposes.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-9371" data-description="the betheme theme for wordpress is vulnerable to stored cross-site scripting via the ‘page_title’ parameter in all versions up to, and including, 28.1.6 due to insufficient input sanitization and output escaping of theme breadcrumbs. this makes it possible for authenticated attackers, with contributor-level access and above, to inject arbitrary web scripts in pages that will execute whenever a user accesses an injected page.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-9371" target="_blank">CVE-2025-9371</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-10-09 07:15:35 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">MEDIUM</span></p>
                    <p><span class="feed-label">CVSS Score:</span> 6.4</p>
                    <p>The Betheme theme for WordPress is vulnerable to Stored Cross-Site Scripting via the ‘page_title’ parameter in all versions up to, and including, 28.1.6 due to insufficient input sanitization and output escaping of theme breadcrumbs. This makes it possible for authenticated attackers, with Contributor-level access and above, to inject arbitrary web scripts in pages that will execute whenever a user accesses an injected page.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-2934" data-description="gitlab has remediated an issue in gitlab ce/ee affecting all versions from 5.2 prior to 18.2.8, 18.3 prior to 18.3.4, and 18.4 prior to 18.4.2 that could have allowed an authenticated attacker to create a denial of service condition by configuring malicious webhook endpoints that send crafted http responses.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-2934" target="_blank">CVE-2025-2934</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-10-09 07:15:35 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">MEDIUM</span></p>
                    <p><span class="feed-label">CVSS Score:</span> 4.3</p>
                    <p>GitLab has remediated an issue in GitLab CE/EE affecting all versions from 5.2 prior to 18.2.8, 18.3 prior to 18.3.4, and 18.4 prior to 18.4.2 that could have allowed an authenticated attacker to create a denial of service condition by configuring malicious webhook endpoints that send crafted HTTP responses.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-11340" data-description="gitlab has remediated an issue in gitlab ee affecting all versions from 18.3 to 18.3.4, 18.4 to 18.4.2 that, under certain conditions, could have allowed authenticated users with read-only api tokens to perform unauthorized write operations on vulnerability records by exploiting incorrectly scoped graphql mutations.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-11340" target="_blank">CVE-2025-11340</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-10-09 07:15:35 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-online">HIGH</span></p>
                    <p><span class="feed-label">CVSS Score:</span> 7.7</p>
                    <p>GitLab has remediated an issue in GitLab EE affecting all versions from 18.3 to 18.3.4, 18.4 to 18.4.2 that, under certain conditions, could have allowed authenticated users with read-only API tokens to perform unauthorized write operations on vulnerability records by exploiting incorrectly scoped GraphQL mutations.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-10249" data-description="the slider revolution plugin for wordpress is vulnerable to unauthorized access and modification of data due to a missing capability check on several functions in all versions up to, and including, 6.7.37. this makes it possible for authenticated attackers, with contributor-level access and above, to install and activate plugin add-ons, create sliders, and download arbitrary files.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-10249" target="_blank">CVE-2025-10249</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-10-09 07:15:34 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">MEDIUM</span></p>
                    <p><span class="feed-label">CVSS Score:</span> 6.5</p>
                    <p>The Slider Revolution plugin for WordPress is vulnerable to unauthorized access and modification of data due to a missing capability check on several functions in all versions up to, and including, 6.7.37. This makes it possible for authenticated attackers, with Contributor-level access and above, to install and activate plugin add-ons, create sliders, and download arbitrary files.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-10004" data-description="gitlab has remediated an issue in gitlab ce/ee affecting all versions from 13.12 to 18.2.8, 18.3 to 18.3.4, and 18.4 to 18.4.2 that could make the gitlab instance unresponsive or severely degraded by sending crafted graphql queries requesting large repository blobs.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-10004" target="_blank">CVE-2025-10004</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-10-09 07:15:34 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-online">HIGH</span></p>
                    <p><span class="feed-label">CVSS Score:</span> 7.5</p>
                    <p>GitLab has remediated an issue in GitLab CE/EE affecting all versions from 13.12 to 18.2.8, 18.3 to 18.3.4, and 18.4 to 18.4.2 that could make the GitLab instance unresponsive or severely degraded by sending crafted GraphQL queries requesting large repository blobs.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-39959" data-description="in the linux kernel, the following vulnerability has been resolved:

asoc: amd: acp: fix incorrect retrival of acp_chip_info

use dev_get_drvdata(dev->parent) instead of dev_get_platdata(dev)
to correctly obtain acp_chip_info members in the acp i2s driver.
previously, some members were not updated properly due to incorrect
data access, which could potentially lead to null pointer
dereferences.

this issue was missed in the earlier commit
("asoc: amd: acp: fix null pointer deref in acp_i2s_set_tdm_slot"),
which only addressed set_tdm_slot(). this change ensures that all
relevant functions correctly retrieve acp_chip_info, preventing
further null pointer dereference issues.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-39959" target="_blank">CVE-2025-39959</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-10-09 05:15:38 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">N/A</span></p>
                    <p><span class="feed-label">CVSS Score:</span> N/A</p>
                    <p>In the Linux kernel, the following vulnerability has been resolved:

ASoC: amd: acp: Fix incorrect retrival of acp_chip_info

Use dev_get_drvdata(dev->parent) instead of dev_get_platdata(dev)
to correctly obtain acp_chip_info members in the acp I2S driver.
Previously, some members were not updated properly due to incorrect
data access, which could potentially lead to null pointer
dereferences.

This issue was missed in the earlier commit
("ASoC: amd: acp: Fix NULL pointer deref in acp_i2s_set_tdm_slot"),
which only addressed set_tdm_slot(). This change ensures that all
relevant functions correctly retrieve acp_chip_info, preventing
further null pointer dereference issues.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-39958" data-description="in the linux kernel, the following vulnerability has been resolved:

iommu/s390: make attach succeed when the device was surprise removed

when a pci device is removed with surprise hotplug, there may still be
attempts to attach the device to the default domain as part of tear down
via (__iommu_release_dma_ownership()), or because the removal happens
during probe (__iommu_probe_device()). in both cases zpci_register_ioat()
fails with a cc value indicating that the device handle is invalid. this
is because the device is no longer part of the instance as far as the
hypervisor is concerned.

currently this leads to an error return and s390_iommu_attach_device()
fails. this triggers the warn_on() in __iommu_group_set_domain_nofail()
because attaching to the default domain must never fail.

with the device fenced by the hypervisor no dmas to or from memory are
possible and the iommu translations have no effect. proceed as if the
registration was successful and let the hotplug event handling clean up
the device.

this is similar to how devices in the error state are handled since
commit 59bbf596791b ("iommu/s390: make attach succeed even if the device
is in error state") except that for removal the domain will not be
registered later. this approach was also previously discussed at the
link.

handle both cases, error state and removal, in a helper which checks if
the error needs to be propagated or ignored. avoid magic number
condition codes by using the pre-existing, but never used, defines for
pci load/store condition codes and rename them to reflect that they
apply to all pci instructions.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-39958" target="_blank">CVE-2025-39958</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-10-09 05:15:37 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">N/A</span></p>
                    <p><span class="feed-label">CVSS Score:</span> N/A</p>
                    <p>In the Linux kernel, the following vulnerability has been resolved:

iommu/s390: Make attach succeed when the device was surprise removed

When a PCI device is removed with surprise hotplug, there may still be
attempts to attach the device to the default domain as part of tear down
via (__iommu_release_dma_ownership()), or because the removal happens
during probe (__iommu_probe_device()). In both cases zpci_register_ioat()
fails with a cc value indicating that the device handle is invalid. This
is because the device is no longer part of the instance as far as the
hypervisor is concerned.

Currently this leads to an error return and s390_iommu_attach_device()
fails. This triggers the WARN_ON() in __iommu_group_set_domain_nofail()
because attaching to the default domain must never fail.

With the device fenced by the hypervisor no DMAs to or from memory are
possible and the IOMMU translations have no effect. Proceed as if the
registration was successful and let the hotplug event handling clean up
the device.

This is similar to how devices in the error state are handled since
commit 59bbf596791b ("iommu/s390: Make attach succeed even if the device
is in error state") except that for removal the domain will not be
registered later. This approach was also previously discussed at the
link.

Handle both cases, error state and removal, in a helper which checks if
the error needs to be propagated or ignored. Avoid magic number
condition codes by using the pre-existing, but never used, defines for
PCI load/store condition codes and rename them to reflect that they
apply to all PCI instructions.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-39957" data-description="in the linux kernel, the following vulnerability has been resolved:

wifi: mac80211: increase scan_ies_len for s1g

currently the s1g capability element is not taken into account
for the scan_ies_len, which leads to a buffer length validation
failure in ieee80211_prep_hw_scan() and subsequent warn in
__ieee80211_start_scan(). this prevents hw scanning from functioning.
to fix ensure we accommodate for the s1g capability length.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-39957" target="_blank">CVE-2025-39957</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-10-09 05:15:37 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">N/A</span></p>
                    <p><span class="feed-label">CVSS Score:</span> N/A</p>
                    <p>In the Linux kernel, the following vulnerability has been resolved:

wifi: mac80211: increase scan_ies_len for S1G

Currently the S1G capability element is not taken into account
for the scan_ies_len, which leads to a buffer length validation
failure in ieee80211_prep_hw_scan() and subsequent WARN in
__ieee80211_start_scan(). This prevents hw scanning from functioning.
To fix ensure we accommodate for the S1G capability length.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-39956" data-description="in the linux kernel, the following vulnerability has been resolved:

igc: don't fail igc_probe() on led setup error

when igc_led_setup() fails, igc_probe() fails and triggers kernel panic
in free_netdev() since unregister_netdev() is not called. [1]
this behavior can be tested using fault-injection framework, especially
the failslab feature. [2]

since led support is not mandatory, treat led setup failures as
non-fatal and continue probe with a warning message, consequently
avoiding the kernel panic.

[1]
 kernel bug at net/core/dev.c:12047!
 oops: invalid opcode: 0000 [#1] smp nopti
 cpu: 0 uid: 0 pid: 937 comm: repro-igc-led-e not tainted 6.17.0-rc4-enjuk-tnguy-00865-gc4940196ab02 #64 preempt(voluntary)
 hardware name: qemu standard pc (q35 + ich9, 2009), bios 1.16.3-debian-1.16.3-2 04/01/2014
 rip: 0010:free_netdev+0x278/0x2b0
 [...]
 call trace:
  <task>
  igc_probe+0x370/0x910
  local_pci_probe+0x3a/0x80
  pci_device_probe+0xd1/0x200
 [...]

[2]
 #!/bin/bash -ex

 failslab_path=/sys/kernel/debug/failslab/
 device=0000:00:05.0
 start_addr=$(grep " igc_led_setup" /proc/kallsyms \
         | awk '{printf("0x%s", $1)}')
 end_addr=$(printf "0x%x" $((start_addr + 0x100)))

 echo $start_addr > $failslab_path/require-start
 echo $end_addr > $failslab_path/require-end
 echo 1 > $failslab_path/times
 echo 100 > $failslab_path/probability
 echo n > $failslab_path/ignore-gfp-wait

 echo $device > /sys/bus/pci/drivers/igc/bind">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-39956" target="_blank">CVE-2025-39956</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-10-09 05:15:36 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">N/A</span></p>
                    <p><span class="feed-label">CVSS Score:</span> N/A</p>
                    <p>In the Linux kernel, the following vulnerability has been resolved:

igc: don't fail igc_probe() on LED setup error

When igc_led_setup() fails, igc_probe() fails and triggers kernel panic
in free_netdev() since unregister_netdev() is not called. [1]
This behavior can be tested using fault-injection framework, especially
the failslab feature. [2]

Since LED support is not mandatory, treat LED setup failures as
non-fatal and continue probe with a warning message, consequently
avoiding the kernel panic.

[1]
 kernel BUG at net/core/dev.c:12047!
 Oops: invalid opcode: 0000 [#1] SMP NOPTI
 CPU: 0 UID: 0 PID: 937 Comm: repro-igc-led-e Not tainted 6.17.0-rc4-enjuk-tnguy-00865-gc4940196ab02 #64 PREEMPT(voluntary)
 Hardware name: QEMU Standard PC (Q35 + ICH9, 2009), BIOS 1.16.3-debian-1.16.3-2 04/01/2014
 RIP: 0010:free_netdev+0x278/0x2b0
 [...]
 Call Trace:
  <TASK>
  igc_probe+0x370/0x910
  local_pci_probe+0x3a/0x80
  pci_device_probe+0xd1/0x200
 [...]

[2]
 #!/bin/bash -ex

 FAILSLAB_PATH=/sys/kernel/debug/failslab/
 DEVICE=0000:00:05.0
 START_ADDR=$(grep " igc_led_setup" /proc/kallsyms \
         | awk '{printf("0x%s", $1)}')
 END_ADDR=$(printf "0x%x" $((START_ADDR + 0x100)))

 echo $START_ADDR > $FAILSLAB_PATH/require-start
 echo $END_ADDR > $FAILSLAB_PATH/require-end
 echo 1 > $FAILSLAB_PATH/times
 echo 100 > $FAILSLAB_PATH/probability
 echo N > $FAILSLAB_PATH/ignore-gfp-wait

 echo $DEVICE > /sys/bus/pci/drivers/igc/bind</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-39955" data-description="in the linux kernel, the following vulnerability has been resolved:

tcp: clear tcp_sk(sk)->fastopen_rsk in tcp_disconnect().

syzbot reported the splat below where a socket had tcp_sk(sk)->fastopen_rsk
in the tcp_established state. [0]

syzbot reused the server-side tcp fast open socket as a new client before
the tfo socket completes 3whs:

  1. accept()
  2. connect(af_unspec)
  3. connect() to another destination

as of accept(), sk->sk_state is tcp_syn_recv, and tcp_disconnect() changes
it to tcp_close and makes connect() possible, which restarts timers.

since tcp_disconnect() forgot to clear tcp_sk(sk)->fastopen_rsk, the
retransmit timer triggered the warning and the intended packet was not
retransmitted.

let's call reqsk_fastopen_remove() in tcp_disconnect().

[0]:
warning: cpu: 2 pid: 0 at net/ipv4/tcp_timer.c:542 tcp_retransmit_timer (net/ipv4/tcp_timer.c:542 (discriminator 7))
modules linked in:
cpu: 2 uid: 0 pid: 0 comm: swapper/2 not tainted 6.17.0-rc5-g201825fb4278 #62 preempt(voluntary)
hardware name: qemu standard pc (i440fx + piix, 1996), bios 1.16.3-debian-1.16.3-2 04/01/2014
rip: 0010:tcp_retransmit_timer (net/ipv4/tcp_timer.c:542 (discriminator 7))
code: 41 55 41 54 55 53 48 8b af b8 08 00 00 48 89 fb 48 85 ed 0f 84 55 01 00 00 0f b6 47 12 3c 03 74 0c 0f b6 47 12 3c 04 74 04 90 <0f> 0b 90 48 8b 85 c0 00 00 00 48 89 ef 48 8b 40 30 e8 6a 4f 06 3e
rsp: 0018:ffffc900002f8d40 eflags: 00010293
rax: 0000000000000002 rbx: ffff888106911400 rcx: 0000000000000017
rdx: 0000000002517619 rsi: ffffffff83764080 rdi: ffff888106911400
rbp: ffff888106d5c000 r08: 0000000000000001 r09: ffffc900002f8de8
r10: 00000000000000c2 r11: ffffc900002f8ff8 r12: ffff888106911540
r13: ffff888106911480 r14: ffff888106911840 r15: ffffc900002f8de0
fs:  0000000000000000(0000) gs:ffff88907b768000(0000) knlgs:0000000000000000
cs:  0010 ds: 0000 es: 0000 cr0: 0000000080050033
cr2: 00007f8044d69d90 cr3: 0000000002c30003 cr4: 0000000000370ef0
call trace:
 <irq>
 tcp_write_timer (net/ipv4/tcp_timer.c:738)
 call_timer_fn (kernel/time/timer.c:1747)
 __run_timers (kernel/time/timer.c:1799 kernel/time/timer.c:2372)
 timer_expire_remote (kernel/time/timer.c:2385 kernel/time/timer.c:2376 kernel/time/timer.c:2135)
 tmigr_handle_remote_up (kernel/time/timer_migration.c:944 kernel/time/timer_migration.c:1035)
 __walk_groups.isra.0 (kernel/time/timer_migration.c:533 (discriminator 1))
 tmigr_handle_remote (kernel/time/timer_migration.c:1096)
 handle_softirqs (./arch/x86/include/asm/jump_label.h:36 ./include/trace/events/irq.h:142 kernel/softirq.c:580)
 irq_exit_rcu (kernel/softirq.c:614 kernel/softirq.c:453 kernel/softirq.c:680 kernel/softirq.c:696)
 sysvec_apic_timer_interrupt (arch/x86/kernel/apic/apic.c:1050 (discriminator 35) arch/x86/kernel/apic/apic.c:1050 (discriminator 35))
 </irq>">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-39955" target="_blank">CVE-2025-39955</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-10-09 05:15:36 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">N/A</span></p>
                    <p><span class="feed-label">CVSS Score:</span> N/A</p>
                    <p>In the Linux kernel, the following vulnerability has been resolved:

tcp: Clear tcp_sk(sk)->fastopen_rsk in tcp_disconnect().

syzbot reported the splat below where a socket had tcp_sk(sk)->fastopen_rsk
in the TCP_ESTABLISHED state. [0]

syzbot reused the server-side TCP Fast Open socket as a new client before
the TFO socket completes 3WHS:

  1. accept()
  2. connect(AF_UNSPEC)
  3. connect() to another destination

As of accept(), sk->sk_state is TCP_SYN_RECV, and tcp_disconnect() changes
it to TCP_CLOSE and makes connect() possible, which restarts timers.

Since tcp_disconnect() forgot to clear tcp_sk(sk)->fastopen_rsk, the
retransmit timer triggered the warning and the intended packet was not
retransmitted.

Let's call reqsk_fastopen_remove() in tcp_disconnect().

[0]:
WARNING: CPU: 2 PID: 0 at net/ipv4/tcp_timer.c:542 tcp_retransmit_timer (net/ipv4/tcp_timer.c:542 (discriminator 7))
Modules linked in:
CPU: 2 UID: 0 PID: 0 Comm: swapper/2 Not tainted 6.17.0-rc5-g201825fb4278 #62 PREEMPT(voluntary)
Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.16.3-debian-1.16.3-2 04/01/2014
RIP: 0010:tcp_retransmit_timer (net/ipv4/tcp_timer.c:542 (discriminator 7))
Code: 41 55 41 54 55 53 48 8b af b8 08 00 00 48 89 fb 48 85 ed 0f 84 55 01 00 00 0f b6 47 12 3c 03 74 0c 0f b6 47 12 3c 04 74 04 90 <0f> 0b 90 48 8b 85 c0 00 00 00 48 89 ef 48 8b 40 30 e8 6a 4f 06 3e
RSP: 0018:ffffc900002f8d40 EFLAGS: 00010293
RAX: 0000000000000002 RBX: ffff888106911400 RCX: 0000000000000017
RDX: 0000000002517619 RSI: ffffffff83764080 RDI: ffff888106911400
RBP: ffff888106d5c000 R08: 0000000000000001 R09: ffffc900002f8de8
R10: 00000000000000c2 R11: ffffc900002f8ff8 R12: ffff888106911540
R13: ffff888106911480 R14: ffff888106911840 R15: ffffc900002f8de0
FS:  0000000000000000(0000) GS:ffff88907b768000(0000) knlGS:0000000000000000
CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
CR2: 00007f8044d69d90 CR3: 0000000002c30003 CR4: 0000000000370ef0
Call Trace:
 <IRQ>
 tcp_write_timer (net/ipv4/tcp_timer.c:738)
 call_timer_fn (kernel/time/timer.c:1747)
 __run_timers (kernel/time/timer.c:1799 kernel/time/timer.c:2372)
 timer_expire_remote (kernel/time/timer.c:2385 kernel/time/timer.c:2376 kernel/time/timer.c:2135)
 tmigr_handle_remote_up (kernel/time/timer_migration.c:944 kernel/time/timer_migration.c:1035)
 __walk_groups.isra.0 (kernel/time/timer_migration.c:533 (discriminator 1))
 tmigr_handle_remote (kernel/time/timer_migration.c:1096)
 handle_softirqs (./arch/x86/include/asm/jump_label.h:36 ./include/trace/events/irq.h:142 kernel/softirq.c:580)
 irq_exit_rcu (kernel/softirq.c:614 kernel/softirq.c:453 kernel/softirq.c:680 kernel/softirq.c:696)
 sysvec_apic_timer_interrupt (arch/x86/kernel/apic/apic.c:1050 (discriminator 35) arch/x86/kernel/apic/apic.c:1050 (discriminator 35))
 </IRQ></p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-39954" data-description="in the linux kernel, the following vulnerability has been resolved:

clk: sunxi-ng: mp: fix dual-divider clock rate readback

when dual-divider clock support was introduced, the p divider offset was
left out of the .recalc_rate readback function. this causes the clock
rate to become bogus or even zero (possibly due to the p divider being
1, leading to a divide-by-zero).

fix this by incorporating the p divider offset into the calculation.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-39954" target="_blank">CVE-2025-39954</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-10-09 05:15:31 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">N/A</span></p>
                    <p><span class="feed-label">CVSS Score:</span> N/A</p>
                    <p>In the Linux kernel, the following vulnerability has been resolved:

clk: sunxi-ng: mp: Fix dual-divider clock rate readback

When dual-divider clock support was introduced, the P divider offset was
left out of the .recalc_rate readback function. This causes the clock
rate to become bogus or even zero (possibly due to the P divider being
1, leading to a divide-by-zero).

Fix this by incorporating the P divider offset into the calculation.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-10862" data-description="the popup builder with gamification, multi-step popups, page-level targeting, and woocommerce triggers plugin for wordpress is vulnerable to sql injection in all versions up to, and including, 2.1.3. this is due to insufficient escaping on the 'id' parameter and lack of sufficient preparation on the existing sql query. this makes it possible for unauthenticated attackers to append additional sql queries into already existing queries that can be used to extract sensitive information from the database.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-10862" target="_blank">CVE-2025-10862</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-10-09 04:15:45 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-online">HIGH</span></p>
                    <p><span class="feed-label">CVSS Score:</span> 7.5</p>
                    <p>The Popup builder with Gamification, Multi-Step Popups, Page-Level Targeting, and WooCommerce Triggers plugin for WordPress is vulnerable to SQL Injection in all versions up to, and including, 2.1.3. This is due to insufficient escaping on the 'id' parameter and lack of sufficient preparation on the existing SQL query. This makes it possible for unauthenticated attackers to append additional SQL queries into already existing queries that can be used to extract sensitive information from the database.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-11539" data-description="grafana image renderer is vulnerable to remote code execution due to an arbitrary file write vulnerability. this is due to the fact that the /render/csv endpoint lacked validation of the filepath parameter that allowed an attacker to save a shared object to an arbitrary location that is then loaded by the chromium process.

instances are vulnerable if:

1. the default token ("authtoken") is not changed, or is known to the attacker.
2. the attacker can reach the image renderer endpoint.
this issue affects grafana-image-renderer: from 1.0.0 through 4.0.16.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-11539" target="_blank">CVE-2025-11539</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-10-09 03:15:38 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-online">CRITICAL</span></p>
                    <p><span class="feed-label">CVSS Score:</span> 9.9</p>
                    <p>Grafana Image Renderer is vulnerable to remote code execution due to an arbitrary file write vulnerability. This is due to the fact that the /render/csv endpoint lacked validation of the filePath parameter that allowed an attacker to save a shared object to an arbitrary location that is then loaded by the Chromium process.

Instances are vulnerable if:

1. The default token ("authToken") is not changed, or is known to the attacker.
2. The attacker can reach the image renderer endpoint.
This issue affects grafana-image-renderer: from 1.0.0 through 4.0.16.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-11522" data-description="the search & go - directory wordpress theme theme for wordpress is vulnerable to authentication bypass via account takeover in all versions up to, and including, 2.7. this is due to insufficient user validation in the search_and_go_elated_check_facebook_user() function this makes it possible for unauthenticated attackers to gain access to other user's accounts, including administrators, when facebook login is enabled.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-11522" target="_blank">CVE-2025-11522</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-10-09 03:15:38 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-online">CRITICAL</span></p>
                    <p><span class="feed-label">CVSS Score:</span> 9.8</p>
                    <p>The Search & Go - Directory WordPress Theme theme for WordPress is vulnerable to Authentication Bypass via account takeover in all versions up to, and including, 2.7. This is due to insufficient user validation in the search_and_go_elated_check_facebook_user() function This makes it possible for unauthenticated attackers to gain access to other user's accounts, including administrators, when Facebook login is enabled.</p>
                </div>
        
            </div>
        </div>

        <footer class="footer">
            <p>© 2025 dotne1 - Cybersecurity Portfolio</p>
        </footer>

        <script>
            function searchCVEs() {
                const input = document.getElementById('searchInput').value.toLowerCase();
                const cveEntries = document.getElementsByClassName('cve-entry');
                for (let i = 0; i < cveEntries.length; i++) {
                    const cveId = cveEntries[i].getAttribute('data-cve-id').toLowerCase();
                    const description = cveEntries[i].getAttribute('data-description');
                    if (cveId.includes(input) || description.includes(input)) {
                        cveEntries[i].style.display = '';
                    } else {
                        cveEntries[i].style.display = 'none';
                    }
                }
            }
        </script>
    </body>
    </html>
    