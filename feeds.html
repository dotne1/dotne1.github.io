
    <!DOCTYPE html>
    <html lang="en">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <meta name="description" content="Security alerts and cybersecurity news feeds">
        <meta name="keywords" content="cybersecurity news, security alerts, vulnerability feeds, threat intelligence">
        <meta name="author" content="dotne1">
        <meta property="og:title" content="Security Feeds - dotne1's Cybersecurity Portfolio">
        <meta property="og:description" content="Stay updated with the latest cybersecurity news and alerts">
        <meta property="og:type" content="website">
        <title>Security Feeds - dotne1's Cybersecurity Portfolio</title>
        <link rel="stylesheet" href="styles.css">
        <link rel="icon" type="image/x-icon" href="/favicon.ico">
    </head>
    <body>
        <nav class="navbar">
            <div class="nav-links">
                <a href="index.html" class="nav-link">Home</a>
                <a href="about-me.html" class="nav-link">About Me</a>
                <a href="projects.html" class="nav-link">Projects</a>
                <a href="resume.html" class="nav-link">Resume</a>
                <a href="feeds.html" class="nav-link">Feeds</a>
            </div>
        </nav>

        <div class="container" role="main">
            <h1 class="main-header">Security Feeds</h1>
            <div class="search-bar">
                <input type="text" id="searchInput" placeholder="Search CVEs..." onkeyup="searchCVEs()">
            </div>
            <div class="feed-preview" id="cveFeed">
                <div class="feed-header">Latest Vulnerabilities</div>
    
                <div class="cve-entry" data-cve-id="CVE-2025-63608" data-description="a sql injection vulnerability exists in csz-cms <=1.3.0 in the form builder view functionality. the vulnerability is located in the field parameter of the form viewing feature, allowing authenticated administrators to execute arbitrary sql queries.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-63608" target="_blank">CVE-2025-63608</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-10-30 08:15:33 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">N/A</span></p>
                    <p><span class="feed-label">CVSS Score:</span> N/A</p>
                    <p>A SQL injection vulnerability exists in CSZ-CMS <=1.3.0 in the Form Builder view functionality. The vulnerability is located in the field parameter of the form viewing feature, allowing authenticated administrators to execute arbitrary SQL queries.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-10348" data-description="urve smart office is vulnerable to stored xss in report problem functionality. an attacker with a low-privileged account can upload an svg file containing a malicious payload, which will be executed when a victim visits the url of the uploaded resource. the resource is available to anyone without any form of authentication.

this issue was fixed in version 1.1.24.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-10348" target="_blank">CVE-2025-10348</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-10-30 08:15:32 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">N/A</span></p>
                    <p><span class="feed-label">CVSS Score:</span> N/A</p>
                    <p>URVE Smart Office is vulnerable to Stored XSS in report problem functionality. An attacker with a low-privileged account can upload an SVG file containing a malicious payload, which will be executed when a victim visits the URL of the uploaded resource. The resource is available to anyone without any form of authentication.

This issue was fixed in version 1.1.24.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-10317" data-description="quick.cart is vulnerable to cross-site request forgery in product creation functionality. malicious attacker can craft special website, which when visited by the admin, will automatically send a post request creating a malicious product with content defined by the attacker.
this software does not implement any protection against this type of attack. all forms available in this software are potentially vulnerable.

the vendor was notified early about this vulnerability, but didn't respond with the details of vulnerability or vulnerable version range. only version 6.7 was tested and confirmed as vulnerable, other versions were not tested and might also be vulnerable.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-10317" target="_blank">CVE-2025-10317</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-10-30 07:15:32 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">N/A</span></p>
                    <p><span class="feed-label">CVSS Score:</span> N/A</p>
                    <p>Quick.Cart is vulnerable to Cross-Site Request Forgery in product creation functionality. Malicious attacker can craft special website, which when visited by the admin, will automatically send a POST request creating a malicious product with content defined by the attacker.
This software does not implement any protection against this type of attack. All forms available in this software are potentially vulnerable.

The vendor was notified early about this vulnerability, but didn't respond with the details of vulnerability or vulnerable version range. Only version 6.7 was tested and confirmed as vulnerable, other versions were not tested and might also be vulnerable.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-53883" data-description="a improper neutralization of script-related html tags in a web page (basic xss) vulnerability allows attackers to run arbitrary javascript via a reflected xss issue in the search fields.this issue affects container suse/manager/5.0/x86_64/server:latest: from ? before 5.0.28-150600.3.36.8; suse manager server lts 4.3: from ? before 4.3.88-150400.3.113.5.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-53883" target="_blank">CVE-2025-53883</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-10-30 06:15:33 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">N/A</span></p>
                    <p><span class="feed-label">CVSS Score:</span> N/A</p>
                    <p>A Improper Neutralization of Script-Related HTML Tags in a Web Page (Basic XSS) vulnerability allows attackers to run arbitrary javascript via a reflected XSS issue in the search fields.This issue affects Container suse/manager/5.0/x86_64/server:latest: from ? before 5.0.28-150600.3.36.8; SUSE Manager Server LTS 4.3: from ? before 4.3.88-150400.3.113.5.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-53880" data-description="a path traversal vulnerability in the tftpsync/add and tftpsync/delete scripts allows a remote attacker on an adjacent network to write or delete files on the filesystem with the privileges of the unprivileged wwwrun user. although the endpoint is unauthenticated, access is restricted to a list of allowed ip addresses.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-53880" target="_blank">CVE-2025-53880</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-10-30 06:15:33 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">N/A</span></p>
                    <p><span class="feed-label">CVSS Score:</span> N/A</p>
                    <p>A Path Traversal vulnerability in the tftpsync/add and tftpsync/delete scripts allows a remote attacker on an adjacent network to write or delete files on the filesystem with the privileges of the unprivileged wwwrun user. Although the endpoint is unauthenticated, access is restricted to a list of allowed IP addresses.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-39663" data-description="cross-site scripting (xss) vulnerability in checkmk's distributed monitoring allows a compromised remote site to inject malicious html code into service outputs in the central site. affecting checkmk before 2.4.0p14, 2.3.0p39, 2.2.0 and 2.1.0 (eol).">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-39663" target="_blank">CVE-2025-39663</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-10-30 06:15:32 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">N/A</span></p>
                    <p><span class="feed-label">CVSS Score:</span> N/A</p>
                    <p>Cross-Site Scripting (XSS) vulnerability in Checkmk's distributed monitoring allows a compromised remote site to inject malicious HTML code into service outputs in the central site. Affecting Checkmk before 2.4.0p14, 2.3.0p39, 2.2.0 and 2.1.0 (eol).</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-62503" data-description="user with create and no update privilege for pools, connections, variables could update existing records via bulk create api with overwrite action.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-62503" target="_blank">CVE-2025-62503</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-10-30 05:15:35 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">N/A</span></p>
                    <p><span class="feed-label">CVSS Score:</span> N/A</p>
                    <p>User with CREATE and no UPDATE privilege for Pools, Connections, Variables could update existing records via bulk create API with overwrite action.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-62402" data-description="api users via `/api/v2/dagreports` could perform dag code execution in the context of the api-server if the api-server was deployed in the environment where dag files were available.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-62402" target="_blank">CVE-2025-62402</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-10-30 05:15:35 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">N/A</span></p>
                    <p><span class="feed-label">CVSS Score:</span> N/A</p>
                    <p>API users via `/api/v2/dagReports` could perform Dag code execution in the context of the api-server if the api-server was deployed in the environment where Dag files were available.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-54941" data-description="an example dag `example_dag_decorator` had non-validated parameter that allowed the ui user to redirect the example to a malicious server and execute code on worker. this however required that the example dags are enabled in production (not default) or the example dag code copied to build your own similar dag. if you used the `example_dag_decorator` please review it and apply the changes implemented in airflow 3.0.5 accordingly.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-54941" target="_blank">CVE-2025-54941</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-10-30 05:15:35 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">N/A</span></p>
                    <p><span class="feed-label">CVSS Score:</span> N/A</p>
                    <p>An example dag `example_dag_decorator` had non-validated parameter that allowed the UI user to redirect the example to a malicious server and execute code on worker. This however required that the example dags are enabled in production (not default) or the example dag code copied to build your own similar dag. If you used the `example_dag_decorator` please review it and apply the changes implemented in Airflow 3.0.5 accordingly.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-54471" data-description="neuvector used a hard-coded cryptographic key embedded in the source 
code. at compilation time, the key value was replaced with the secret 
key value and used to encrypt sensitive configurations  when neuvector 
stores the data.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-54471" target="_blank">CVE-2025-54471</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-10-30 05:15:35 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">MEDIUM</span></p>
                    <p><span class="feed-label">CVSS Score:</span> 6.5</p>
                    <p>NeuVector used a hard-coded cryptographic key embedded in the source 
code. At compilation time, the key value was replaced with the secret 
key value and used to encrypt sensitive configurations  when NeuVector 
stores the data.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-54470" data-description="this vulnerability affects neuvector deployments only when the report anonymous cluster data option is enabled. when this option is enabled, neuvector sends anonymous telemetry data to the telemetry server.


in affected versions, neuvector does not enforce tls 
certificate verification when transmitting anonymous cluster data to the
 telemetry server. as a result, the communication channel is susceptible
 to man-in-the-middle (mitm) attacks, where an attacker could intercept 
or modify the transmitted data. additionally, neuvector loads the 
response of the telemetry server is loaded into memory without size 
limitation, which makes  it vulnerable to a denial of service(dos) 
attack">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-54470" target="_blank">CVE-2025-54470</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-10-30 05:15:35 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-online">HIGH</span></p>
                    <p><span class="feed-label">CVSS Score:</span> 8.6</p>
                    <p>This vulnerability affects NeuVector deployments only when the Report anonymous cluster data option is enabled. When this option is enabled, NeuVector sends anonymous telemetry data to the telemetry server.


In affected versions, NeuVector does not enforce TLS 
certificate verification when transmitting anonymous cluster data to the
 telemetry server. As a result, the communication channel is susceptible
 to man-in-the-middle (MITM) attacks, where an attacker could intercept 
or modify the transmitted data. Additionally, NeuVector loads the 
response of the telemetry server is loaded into memory without size 
limitation, which makes  it vulnerable to a Denial of Service(DoS) 
attack</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-54469" data-description="a vulnerability was identified in neuvector, where the enforcer used environment variables cluster_rpc_port and cluster_lan_port to generate a command to be executed via popen, without first sanitising their values.


the entry process of the enforcer container is the monitor
 process. when the enforcer container stops, the monitor process checks 
whether the consul subprocess has exited. to perform this check, the 
monitor process uses the popen function to execute a shell command that determines whether the ports used by the consul subprocess are still active.


the values of environment variables cluster_rpc_port and cluster_lan_port
 are used directly to compose shell commands via popen without 
validation or sanitization.  this behavior could allow a malicious user 
to inject malicious commands through these variables within the enforcer
 container.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-54469" target="_blank">CVE-2025-54469</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-10-30 05:15:34 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-online">CRITICAL</span></p>
                    <p><span class="feed-label">CVSS Score:</span> 9.9</p>
                    <p>A vulnerability was identified in NeuVector, where the enforcer used environment variables CLUSTER_RPC_PORT and CLUSTER_LAN_PORT to generate a command to be executed via popen, without first sanitising their values.


The entry process of the enforcer container is the monitor
 process. When the enforcer container stops, the monitor process checks 
whether the consul subprocess has exited. To perform this check, the 
monitor process uses the popen function to execute a shell command that determines whether the ports used by the consul subprocess are still active.


The values of environment variables CLUSTER_RPC_PORT and CLUSTER_LAN_PORT
 are used directly to compose shell commands via popen without 
validation or sanitization.  This behavior could allow a malicious user 
to inject malicious commands through these variables within the enforcer
 container.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-40105" data-description="in the linux kernel, the following vulnerability has been resolved:

vfs: don't leak disconnected dentries on umount

when user calls open_by_handle_at() on some inode that is not cached, we
will create disconnected dentry for it. if such dentry is a directory,
exportfs_decode_fh_raw() will then try to connect this dentry to the
dentry tree through reconnect_path(). it may happen for various reasons
(such as corrupted fs or race with rename) that the call to
lookup_one_unlocked() in reconnect_one() will fail to find the dentry we
are trying to reconnect and instead create a new dentry under the
parent. now this dentry will not be marked as disconnected although the
parent still may well be disconnected (at least in case this
inconsistency happened because the fs is corrupted and .. doesn't point
to the real parent directory). this creates inconsistency in
disconnected flags but afaics it was mostly harmless. at least until
commit f1ee616214cb ("vfs: don't keep disconnected dentries on d_anon")
which removed adding of most disconnected dentries to sb->s_anon list.
thus after this commit cleanup of disconnected dentries implicitely
relies on the fact that dput() will immediately reclaim such dentries.
however when some leaf dentry isn't marked as disconnected, as in the
scenario described above, the reclaim doesn't happen and the dentries
are "leaked". memory reclaim can eventually reclaim them but otherwise
they stay in memory and if umount comes first, we hit infamous "busy
inodes after unmount" bug. make sure all dentries created under a
disconnected parent are marked as disconnected as well.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-40105" target="_blank">CVE-2025-40105</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-10-30 05:15:34 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">N/A</span></p>
                    <p><span class="feed-label">CVSS Score:</span> N/A</p>
                    <p>In the Linux kernel, the following vulnerability has been resolved:

vfs: Don't leak disconnected dentries on umount

When user calls open_by_handle_at() on some inode that is not cached, we
will create disconnected dentry for it. If such dentry is a directory,
exportfs_decode_fh_raw() will then try to connect this dentry to the
dentry tree through reconnect_path(). It may happen for various reasons
(such as corrupted fs or race with rename) that the call to
lookup_one_unlocked() in reconnect_one() will fail to find the dentry we
are trying to reconnect and instead create a new dentry under the
parent. Now this dentry will not be marked as disconnected although the
parent still may well be disconnected (at least in case this
inconsistency happened because the fs is corrupted and .. doesn't point
to the real parent directory). This creates inconsistency in
disconnected flags but AFAICS it was mostly harmless. At least until
commit f1ee616214cb ("VFS: don't keep disconnected dentries on d_anon")
which removed adding of most disconnected dentries to sb->s_anon list.
Thus after this commit cleanup of disconnected dentries implicitely
relies on the fact that dput() will immediately reclaim such dentries.
However when some leaf dentry isn't marked as disconnected, as in the
scenario described above, the reclaim doesn't happen and the dentries
are "leaked". Memory reclaim can eventually reclaim them but otherwise
they stay in memory and if umount comes first, we hit infamous "Busy
inodes after unmount" bug. Make sure all dentries created under a
disconnected parent are marked as disconnected as well.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-40104" data-description="in the linux kernel, the following vulnerability has been resolved:

ixgbevf: fix mailbox api compatibility by negotiating supported features

there was backward compatibility in the terms of mailbox api. various
drivers from various oses supporting 10g adapters from intel portfolio
could easily negotiate mailbox api.

this convention has been broken since introducing api 1.4.
commit 0062e7cc955e ("ixgbevf: add vf ipsec offload code") added support
for ipsec which is specific only for the kernel ixgbe driver. none of the
rest of the intel 10g pf/vf drivers supports it. and actually lack of
support was not included in the ipsec implementation - there were no such
code paths. no possibility to negotiate support for the feature was
introduced along with introduction of the feature itself.

commit 339f28964147 ("ixgbevf: add support for new mailbox communication
between pf and vf") increasing api version to 1.5 did the same - it
introduced code supported specifically by the pf esx driver. it altered api
version for the vf driver in the same time not touching the version
defined for the pf ixgbe driver. it led to additional discrepancies,
as the code provided within api 1.6 cannot be supported for linux ixgbe
driver as it causes crashes.

the issue was noticed some time ago and mitigated by jake within the commit
d0725312adf5 ("ixgbevf: stop attempting ipsec offload on mailbox api 1.5").
as a result we have regression for ipsec support and after increasing api
to version 1.6 ixgbevf driver stopped to support esx mbx.

to fix this mess add new mailbox op asking pf driver about supported
features. basing on a response determine whether to set support for ipsec
and esx-specific enhanced mailbox.

new mailbox op, for compatibility purposes, must be added within new api
revision, as api version of oot pf & vf drivers is already increased to
1.6 and doesn't incorporate features negotiate op.

features negotiation mechanism gives possibility to be extended with new
features when needed in the future.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-40104" target="_blank">CVE-2025-40104</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-10-30 05:15:34 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">N/A</span></p>
                    <p><span class="feed-label">CVSS Score:</span> N/A</p>
                    <p>In the Linux kernel, the following vulnerability has been resolved:

ixgbevf: fix mailbox API compatibility by negotiating supported features

There was backward compatibility in the terms of mailbox API. Various
drivers from various OSes supporting 10G adapters from Intel portfolio
could easily negotiate mailbox API.

This convention has been broken since introducing API 1.4.
Commit 0062e7cc955e ("ixgbevf: add VF IPsec offload code") added support
for IPSec which is specific only for the kernel ixgbe driver. None of the
rest of the Intel 10G PF/VF drivers supports it. And actually lack of
support was not included in the IPSec implementation - there were no such
code paths. No possibility to negotiate support for the feature was
introduced along with introduction of the feature itself.

Commit 339f28964147 ("ixgbevf: Add support for new mailbox communication
between PF and VF") increasing API version to 1.5 did the same - it
introduced code supported specifically by the PF ESX driver. It altered API
version for the VF driver in the same time not touching the version
defined for the PF ixgbe driver. It led to additional discrepancies,
as the code provided within API 1.6 cannot be supported for Linux ixgbe
driver as it causes crashes.

The issue was noticed some time ago and mitigated by Jake within the commit
d0725312adf5 ("ixgbevf: stop attempting IPSEC offload on Mailbox API 1.5").
As a result we have regression for IPsec support and after increasing API
to version 1.6 ixgbevf driver stopped to support ESX MBX.

To fix this mess add new mailbox op asking PF driver about supported
features. Basing on a response determine whether to set support for IPSec
and ESX-specific enhanced mailbox.

New mailbox op, for compatibility purposes, must be added within new API
revision, as API version of OOT PF & VF drivers is already increased to
1.6 and doesn't incorporate features negotiate op.

Features negotiation mechanism gives possibility to be extended with new
features when needed in the future.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-40103" data-description="in the linux kernel, the following vulnerability has been resolved:

smb: client: fix refcount leak for cifs_sb_tlink

fix three refcount inconsistency issues related to `cifs_sb_tlink`.

comments for `cifs_sb_tlink` state that `cifs_put_tlink()` needs to be
called after successful calls to `cifs_sb_tlink()`. three calls fail to
update refcount accordingly, leading to possible resource leaks.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-40103" target="_blank">CVE-2025-40103</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-10-30 05:15:34 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">N/A</span></p>
                    <p><span class="feed-label">CVSS Score:</span> N/A</p>
                    <p>In the Linux kernel, the following vulnerability has been resolved:

smb: client: Fix refcount leak for cifs_sb_tlink

Fix three refcount inconsistency issues related to `cifs_sb_tlink`.

Comments for `cifs_sb_tlink` state that `cifs_put_tlink()` needs to be
called after successful calls to `cifs_sb_tlink()`. Three calls fail to
update refcount accordingly, leading to possible resource leaks.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-40102" data-description="in the linux kernel, the following vulnerability has been resolved:

kvm: arm64: prevent access to vcpu events before init

another day, another syzkaller bug. kvm erroneously allows userspace to
pend vcpu events for a vcpu that hasn't been initialized yet, leading to
kvm interpreting a bunch of uninitialized garbage for routing /
injecting the exception.

in one case the injection code and the hyp disagree on whether the vcpu
has a 32bit el1 and put the vcpu into an illegal mode for aarch64,
tripping the bug() in exception_target_el() during the next injection:

  kernel bug at arch/arm64/kvm/inject_fault.c:40!
  internal error: oops - bug: 00000000f2000800 [#1]  smp
  cpu: 3 uid: 0 pid: 318 comm: repro not tainted 6.17.0-rc4-00104-g10fd0285305d #6 preempt
  hardware name: linux,dummy-virt (dt)
  pstate: 21402009 (nzcv daif +pan -uao -tco +dit -ssbs btype=--)
  pc : exception_target_el+0x88/0x8c
  lr : pend_serror_exception+0x18/0x13c
  sp : ffff800082f03a10
  x29: ffff800082f03a10 x28: ffff0000cb132280 x27: 0000000000000000
  x26: 0000000000000000 x25: ffff0000c2a99c20 x24: 0000000000000000
  x23: 0000000000008000 x22: 0000000000000002 x21: 0000000000000004
  x20: 0000000000008000 x19: ffff0000c2a99c20 x18: 0000000000000000
  x17: 0000000000000000 x16: 0000000000000000 x15: 00000000200000c0
  x14: 0000000000000000 x13: 0000000000000000 x12: 0000000000000000
  x11: 0000000000000000 x10: 0000000000000000 x9 : 0000000000000000
  x8 : ffff800082f03af8 x7 : 0000000000000000 x6 : 0000000000000000
  x5 : ffff800080f621f0 x4 : 0000000000000000 x3 : 0000000000000000
  x2 : 000000000040009b x1 : 0000000000000003 x0 : ffff0000c2a99c20
  call trace:
   exception_target_el+0x88/0x8c (p)
   kvm_inject_serror_esr+0x40/0x3b4
   __kvm_arm_vcpu_set_events+0xf0/0x100
   kvm_arch_vcpu_ioctl+0x180/0x9d4
   kvm_vcpu_ioctl+0x60c/0x9f4
   __arm64_sys_ioctl+0xac/0x104
   invoke_syscall+0x48/0x110
   el0_svc_common.constprop.0+0x40/0xe0
   do_el0_svc+0x1c/0x28
   el0_svc+0x34/0xf0
   el0t_64_sync_handler+0xa0/0xe4
   el0t_64_sync+0x198/0x19c
  code: f946bc01 b4fffe61 9101e020 17fffff2 (d4210000)

reject the ioctls outright as no sane vmm would call these before
kvm_arm_vcpu_init anyway. even if it did the exception would've been
thrown away by the eventual reset of the vcpu's state.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-40102" target="_blank">CVE-2025-40102</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-10-30 05:15:34 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">N/A</span></p>
                    <p><span class="feed-label">CVSS Score:</span> N/A</p>
                    <p>In the Linux kernel, the following vulnerability has been resolved:

KVM: arm64: Prevent access to vCPU events before init

Another day, another syzkaller bug. KVM erroneously allows userspace to
pend vCPU events for a vCPU that hasn't been initialized yet, leading to
KVM interpreting a bunch of uninitialized garbage for routing /
injecting the exception.

In one case the injection code and the hyp disagree on whether the vCPU
has a 32bit EL1 and put the vCPU into an illegal mode for AArch64,
tripping the BUG() in exception_target_el() during the next injection:

  kernel BUG at arch/arm64/kvm/inject_fault.c:40!
  Internal error: Oops - BUG: 00000000f2000800 [#1]  SMP
  CPU: 3 UID: 0 PID: 318 Comm: repro Not tainted 6.17.0-rc4-00104-g10fd0285305d #6 PREEMPT
  Hardware name: linux,dummy-virt (DT)
  pstate: 21402009 (nzCv daif +PAN -UAO -TCO +DIT -SSBS BTYPE=--)
  pc : exception_target_el+0x88/0x8c
  lr : pend_serror_exception+0x18/0x13c
  sp : ffff800082f03a10
  x29: ffff800082f03a10 x28: ffff0000cb132280 x27: 0000000000000000
  x26: 0000000000000000 x25: ffff0000c2a99c20 x24: 0000000000000000
  x23: 0000000000008000 x22: 0000000000000002 x21: 0000000000000004
  x20: 0000000000008000 x19: ffff0000c2a99c20 x18: 0000000000000000
  x17: 0000000000000000 x16: 0000000000000000 x15: 00000000200000c0
  x14: 0000000000000000 x13: 0000000000000000 x12: 0000000000000000
  x11: 0000000000000000 x10: 0000000000000000 x9 : 0000000000000000
  x8 : ffff800082f03af8 x7 : 0000000000000000 x6 : 0000000000000000
  x5 : ffff800080f621f0 x4 : 0000000000000000 x3 : 0000000000000000
  x2 : 000000000040009b x1 : 0000000000000003 x0 : ffff0000c2a99c20
  Call trace:
   exception_target_el+0x88/0x8c (P)
   kvm_inject_serror_esr+0x40/0x3b4
   __kvm_arm_vcpu_set_events+0xf0/0x100
   kvm_arch_vcpu_ioctl+0x180/0x9d4
   kvm_vcpu_ioctl+0x60c/0x9f4
   __arm64_sys_ioctl+0xac/0x104
   invoke_syscall+0x48/0x110
   el0_svc_common.constprop.0+0x40/0xe0
   do_el0_svc+0x1c/0x28
   el0_svc+0x34/0xf0
   el0t_64_sync_handler+0xa0/0xe4
   el0t_64_sync+0x198/0x19c
  Code: f946bc01 b4fffe61 9101e020 17fffff2 (d4210000)

Reject the ioctls outright as no sane VMM would call these before
KVM_ARM_VCPU_INIT anyway. Even if it did the exception would've been
thrown away by the eventual reset of the vCPU's state.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-40101" data-description="in the linux kernel, the following vulnerability has been resolved:

btrfs: fix memory leaks when rejecting a non single data profile without an rst

at the end of btrfs_load_block_group_zone_info() the first thing we do
is to ensure that if the mapping type is not a single one and there is
no raid stripe tree, then we return early with an error.

doing that, though, prevents the code from running the last calls from
this function which are about freeing memory allocated during its
run. hence, in this case, instead of returning early, we set the ret
value and fall through the rest of the cleanup code.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-40101" target="_blank">CVE-2025-40101</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-10-30 05:15:34 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">N/A</span></p>
                    <p><span class="feed-label">CVSS Score:</span> N/A</p>
                    <p>In the Linux kernel, the following vulnerability has been resolved:

btrfs: fix memory leaks when rejecting a non SINGLE data profile without an RST

At the end of btrfs_load_block_group_zone_info() the first thing we do
is to ensure that if the mapping type is not a SINGLE one and there is
no RAID stripe tree, then we return early with an error.

Doing that, though, prevents the code from running the last calls from
this function which are about freeing memory allocated during its
run. Hence, in this case, instead of returning early, we set the ret
value and fall through the rest of the cleanup code.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-40100" data-description="in the linux kernel, the following vulnerability has been resolved:

btrfs: do not assert we found block group item when creating free space tree

currently, when building a free space tree at populate_free_space_tree(),
if we are not using the block group tree feature, we always expect to find
block group items (either extent items or a block group item with key type
btrfs_block_group_item_key) when we search the extent tree with
btrfs_search_slot_for_read(), so we assert that we found an item. however
this expectation is wrong since we can have a new block group created in
the current transaction which is still empty and for which we still have
not added the block group's item to the extent tree, in which case we do
not have any items in the extent tree associated to the block group.

the insertion of a new block group's block group item in the extent tree
happens at btrfs_create_pending_block_groups() when it calls the helper
insert_block_group_item(). this typically is done when a transaction
handle is released, committed or when running delayed refs (either as
part of a transaction commit or when serving tickets for space reservation
if we are low on free space).

so remove the assertion at populate_free_space_tree() even when the block
group tree feature is not enabled and update the comment to mention this
case.

syzbot reported this with the following stack trace:

  btrfs info (device loop3 state m): rebuilding free space tree
  assertion failed: ret == 0 :: 0, in fs/btrfs/free-space-tree.c:1115
  ------------[ cut here ]------------
  kernel bug at fs/btrfs/free-space-tree.c:1115!
  oops: invalid opcode: 0000 [#1] smp kasan pti
  cpu: 1 uid: 0 pid: 6352 comm: syz.3.25 not tainted syzkaller #0 preempt(full)
  hardware name: google google compute engine/google compute engine, bios google 08/18/2025
  rip: 0010:populate_free_space_tree+0x700/0x710 fs/btrfs/free-space-tree.c:1115
  code: ff ff e8 d3 (...)
  rsp: 0018:ffffc9000430f780 eflags: 00010246
  rax: 0000000000000043 rbx: ffff88805b709630 rcx: fea61d0e2e79d000
  rdx: 0000000000000000 rsi: 0000000080000000 rdi: 0000000000000000
  rbp: ffffc9000430f8b0 r08: ffffc9000430f4a7 r09: 1ffff92000861e94
  r10: dffffc0000000000 r11: fffff52000861e95 r12: 0000000000000001
  r13: 1ffff92000861f00 r14: dffffc0000000000 r15: 0000000000000000
  fs:  00007f424d9fe6c0(0000) gs:ffff888125afc000(0000) knlgs:0000000000000000
  cs:  0010 ds: 0000 es: 0000 cr0: 0000000080050033
  cr2: 00007fd78ad212c0 cr3: 0000000076d68000 cr4: 00000000003526f0
  call trace:
   <task>
   btrfs_rebuild_free_space_tree+0x1ba/0x6d0 fs/btrfs/free-space-tree.c:1364
   btrfs_start_pre_rw_mount+0x128f/0x1bf0 fs/btrfs/disk-io.c:3062
   btrfs_remount_rw fs/btrfs/super.c:1334 [inline]
   btrfs_reconfigure+0xaed/0x2160 fs/btrfs/super.c:1559
   reconfigure_super+0x227/0x890 fs/super.c:1076
   do_remount fs/namespace.c:3279 [inline]
   path_mount+0xd1a/0xfe0 fs/namespace.c:4027
   do_mount fs/namespace.c:4048 [inline]
   __do_sys_mount fs/namespace.c:4236 [inline]
   __se_sys_mount+0x313/0x410 fs/namespace.c:4213
   do_syscall_x64 arch/x86/entry/syscall_64.c:63 [inline]
   do_syscall_64+0xfa/0xfa0 arch/x86/entry/syscall_64.c:94
   entry_syscall_64_after_hwframe+0x77/0x7f
   rip: 0033:0x7f424e39066a
  code: d8 64 89 02 (...)
  rsp: 002b:00007f424d9fde68 eflags: 00000246 orig_rax: 00000000000000a5
  rax: ffffffffffffffda rbx: 00007f424d9fdef0 rcx: 00007f424e39066a
  rdx: 0000200000000180 rsi: 0000200000000380 rdi: 0000000000000000
  rbp: 0000200000000180 r08: 00007f424d9fdef0 r09: 0000000000000020
  r10: 0000000000000020 r11: 0000000000000246 r12: 0000200000000380
  r13: 00007f424d9fdeb0 r14: 0000000000000000 r15: 00002000000002c0
   </task>
  modules linked in:
  ---[ end trace 0000000000000000 ]---">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-40100" target="_blank">CVE-2025-40100</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-10-30 05:15:34 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">N/A</span></p>
                    <p><span class="feed-label">CVSS Score:</span> N/A</p>
                    <p>In the Linux kernel, the following vulnerability has been resolved:

btrfs: do not assert we found block group item when creating free space tree

Currently, when building a free space tree at populate_free_space_tree(),
if we are not using the block group tree feature, we always expect to find
block group items (either extent items or a block group item with key type
BTRFS_BLOCK_GROUP_ITEM_KEY) when we search the extent tree with
btrfs_search_slot_for_read(), so we assert that we found an item. However
this expectation is wrong since we can have a new block group created in
the current transaction which is still empty and for which we still have
not added the block group's item to the extent tree, in which case we do
not have any items in the extent tree associated to the block group.

The insertion of a new block group's block group item in the extent tree
happens at btrfs_create_pending_block_groups() when it calls the helper
insert_block_group_item(). This typically is done when a transaction
handle is released, committed or when running delayed refs (either as
part of a transaction commit or when serving tickets for space reservation
if we are low on free space).

So remove the assertion at populate_free_space_tree() even when the block
group tree feature is not enabled and update the comment to mention this
case.

Syzbot reported this with the following stack trace:

  BTRFS info (device loop3 state M): rebuilding free space tree
  assertion failed: ret == 0 :: 0, in fs/btrfs/free-space-tree.c:1115
  ------------[ cut here ]------------
  kernel BUG at fs/btrfs/free-space-tree.c:1115!
  Oops: invalid opcode: 0000 [#1] SMP KASAN PTI
  CPU: 1 UID: 0 PID: 6352 Comm: syz.3.25 Not tainted syzkaller #0 PREEMPT(full)
  Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 08/18/2025
  RIP: 0010:populate_free_space_tree+0x700/0x710 fs/btrfs/free-space-tree.c:1115
  Code: ff ff e8 d3 (...)
  RSP: 0018:ffffc9000430f780 EFLAGS: 00010246
  RAX: 0000000000000043 RBX: ffff88805b709630 RCX: fea61d0e2e79d000
  RDX: 0000000000000000 RSI: 0000000080000000 RDI: 0000000000000000
  RBP: ffffc9000430f8b0 R08: ffffc9000430f4a7 R09: 1ffff92000861e94
  R10: dffffc0000000000 R11: fffff52000861e95 R12: 0000000000000001
  R13: 1ffff92000861f00 R14: dffffc0000000000 R15: 0000000000000000
  FS:  00007f424d9fe6c0(0000) GS:ffff888125afc000(0000) knlGS:0000000000000000
  CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
  CR2: 00007fd78ad212c0 CR3: 0000000076d68000 CR4: 00000000003526f0
  Call Trace:
   <TASK>
   btrfs_rebuild_free_space_tree+0x1ba/0x6d0 fs/btrfs/free-space-tree.c:1364
   btrfs_start_pre_rw_mount+0x128f/0x1bf0 fs/btrfs/disk-io.c:3062
   btrfs_remount_rw fs/btrfs/super.c:1334 [inline]
   btrfs_reconfigure+0xaed/0x2160 fs/btrfs/super.c:1559
   reconfigure_super+0x227/0x890 fs/super.c:1076
   do_remount fs/namespace.c:3279 [inline]
   path_mount+0xd1a/0xfe0 fs/namespace.c:4027
   do_mount fs/namespace.c:4048 [inline]
   __do_sys_mount fs/namespace.c:4236 [inline]
   __se_sys_mount+0x313/0x410 fs/namespace.c:4213
   do_syscall_x64 arch/x86/entry/syscall_64.c:63 [inline]
   do_syscall_64+0xfa/0xfa0 arch/x86/entry/syscall_64.c:94
   entry_SYSCALL_64_after_hwframe+0x77/0x7f
   RIP: 0033:0x7f424e39066a
  Code: d8 64 89 02 (...)
  RSP: 002b:00007f424d9fde68 EFLAGS: 00000246 ORIG_RAX: 00000000000000a5
  RAX: ffffffffffffffda RBX: 00007f424d9fdef0 RCX: 00007f424e39066a
  RDX: 0000200000000180 RSI: 0000200000000380 RDI: 0000000000000000
  RBP: 0000200000000180 R08: 00007f424d9fdef0 R09: 0000000000000020
  R10: 0000000000000020 R11: 0000000000000246 R12: 0000200000000380
  R13: 00007f424d9fdeb0 R14: 0000000000000000 R15: 00002000000002c0
   </TASK>
  Modules linked in:
  ---[ end trace 0000000000000000 ]---</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-40099" data-description="in the linux kernel, the following vulnerability has been resolved:

cifs: parse_dfs_referrals: prevent oob on malformed input

malicious smb server can send invalid reply to fsctl_dfs_get_referrals

- reply smaller than sizeof(struct get_dfs_referral_rsp)
- reply with number of referrals smaller than numberofreferrals in the
header

processing of such replies will cause oob.

return -einval error on such replies to prevent oob-s.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-40099" target="_blank">CVE-2025-40099</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-10-30 05:15:34 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">N/A</span></p>
                    <p><span class="feed-label">CVSS Score:</span> N/A</p>
                    <p>In the Linux kernel, the following vulnerability has been resolved:

cifs: parse_dfs_referrals: prevent oob on malformed input

Malicious SMB server can send invalid reply to FSCTL_DFS_GET_REFERRALS

- reply smaller than sizeof(struct get_dfs_referral_rsp)
- reply with number of referrals smaller than NumberOfReferrals in the
header

Processing of such replies will cause oob.

Return -EINVAL error on such replies to prevent oob-s.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-40098" data-description="in the linux kernel, the following vulnerability has been resolved:

alsa: hda: cs35l41: fix null pointer dereference in cs35l41_get_acpi_mute_state()

return value of a function acpi_evaluate_dsm() is dereferenced  without
checking for null, but it is usually checked for this function.

acpi_evaluate_dsm() may return null, when acpi_evaluate_object() returns
acpi_status other than acpi_success, so add a check to prevent the crach.

found by linux verification center (linuxtesting.org) with svace.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-40098" target="_blank">CVE-2025-40098</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-10-30 05:15:34 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">N/A</span></p>
                    <p><span class="feed-label">CVSS Score:</span> N/A</p>
                    <p>In the Linux kernel, the following vulnerability has been resolved:

ALSA: hda: cs35l41: Fix NULL pointer dereference in cs35l41_get_acpi_mute_state()

Return value of a function acpi_evaluate_dsm() is dereferenced  without
checking for NULL, but it is usually checked for this function.

acpi_evaluate_dsm() may return NULL, when acpi_evaluate_object() returns
acpi_status other than ACPI_SUCCESS, so add a check to prevent the crach.

Found by Linux Verification Center (linuxtesting.org) with SVACE.</p>
                </div>
        
            </div>
        </div>

        <footer class="footer">
            <p>© 2025 dotne1 - Cybersecurity Portfolio</p>
        </footer>

        <script>
            function searchCVEs() {
                const input = document.getElementById('searchInput').value.toLowerCase();
                const cveEntries = document.getElementsByClassName('cve-entry');
                for (let i = 0; i < cveEntries.length; i++) {
                    const cveId = cveEntries[i].getAttribute('data-cve-id').toLowerCase();
                    const description = cveEntries[i].getAttribute('data-description');
                    if (cveId.includes(input) || description.includes(input)) {
                        cveEntries[i].style.display = '';
                    } else {
                        cveEntries[i].style.display = 'none';
                    }
                }
            }
        </script>
    </body>
    </html>
    