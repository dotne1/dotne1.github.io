
    <!DOCTYPE html>
    <html lang="en">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <meta name="description" content="Security alerts and cybersecurity news feeds">
        <meta name="keywords" content="cybersecurity news, security alerts, vulnerability feeds, threat intelligence">
        <meta name="author" content="dotne1">
        <meta property="og:title" content="Security Feeds - dotne1's Cybersecurity Portfolio">
        <meta property="og:description" content="Stay updated with the latest cybersecurity news and alerts">
        <meta property="og:type" content="website">
        <title>Security Feeds - dotne1's Cybersecurity Portfolio</title>
        <link rel="stylesheet" href="styles.css">
        <link rel="icon" type="image/x-icon" href="/favicon.ico">
    </head>
    <body>
        <nav class="navbar">
            <div class="nav-links">
                <a href="index.html" class="nav-link">Home</a>
                <a href="about-me.html" class="nav-link">About Me</a>
                <a href="projects.html" class="nav-link">Projects</a>
                <a href="resume.html" class="nav-link">Resume</a>
                <a href="feeds.html" class="nav-link">Feeds</a>
            </div>
        </nav>

        <div class="container" role="main">
            <h1 class="main-header">Security Feeds</h1>
            <div class="search-bar">
                <input type="text" id="searchInput" placeholder="Search CVEs..." onkeyup="searchCVEs()">
            </div>
            <div class="feed-preview" id="cveFeed">
                <div class="feed-header">Latest Vulnerabilities</div>
    
                <div class="cve-entry" data-cve-id="CVE-2025-9636" data-description="pgadmin <= 9.7 is affected by a  cross-origin opener policy (coop) vulnerability. this vulnerability allows an attacker to manipulate the oauth flow, potentially leading to unauthorised account access, account takeover, data breaches, and privilege escalation.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-9636" target="_blank">CVE-2025-9636</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-09-04 12:15:39 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-online">HIGH</span></p>
                    <p><span class="feed-label">CVSS Score:</span> 7.9</p>
                    <p>pgAdmin <= 9.7 is affected by a  Cross-Origin Opener Policy (COOP) vulnerability. This vulnerability allows an attacker to manipulate the OAuth flow, potentially leading to unauthorised account access, account takeover, data breaches, and privilege escalation.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-57576" data-description="phpgurukul online shopping portal 2.1 is vulnerable to cross site scripting (xss) in /admin/updateorder.php.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-57576" target="_blank">CVE-2025-57576</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-09-04 11:15:43 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">N/A</span></p>
                    <p><span class="feed-label">CVSS Score:</span> N/A</p>
                    <p>PHPGurukul Online Shopping Portal 2.1 is vulnerable to Cross Site Scripting (XSS) in /admin/updateorder.php.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-38730" data-description="in the linux kernel, the following vulnerability has been resolved:

io_uring/net: commit partial buffers on retry

ring provided buffers are potentially only valid within the single
execution context in which they were acquired. io_uring deals with this
and invalidates them on retry. but on the networking side, if
msg_waitall is set, or if the socket is of the streaming type and too
little was processed, then it will hang on to the buffer rather than
recycle or commit it. this is problematic for two reasons:

1) if someone unregisters the provided buffer ring before a later retry,
   then the req->buf_list will no longer be valid.

2) if multiple sockers are using the same buffer group, then multiple
   receives can consume the same memory. this can cause data corruption
   in the application, as either receive could land in the same
   userspace buffer.

fix this by disallowing partial retries from pinning a provided buffer
across multiple executions, if ring provided buffers are used.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-38730" target="_blank">CVE-2025-38730</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-09-04 11:15:43 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">N/A</span></p>
                    <p><span class="feed-label">CVSS Score:</span> N/A</p>
                    <p>In the Linux kernel, the following vulnerability has been resolved:

io_uring/net: commit partial buffers on retry

Ring provided buffers are potentially only valid within the single
execution context in which they were acquired. io_uring deals with this
and invalidates them on retry. But on the networking side, if
MSG_WAITALL is set, or if the socket is of the streaming type and too
little was processed, then it will hang on to the buffer rather than
recycle or commit it. This is problematic for two reasons:

1) If someone unregisters the provided buffer ring before a later retry,
   then the req->buf_list will no longer be valid.

2) If multiple sockers are using the same buffer group, then multiple
   receives can consume the same memory. This can cause data corruption
   in the application, as either receive could land in the same
   userspace buffer.

Fix this by disallowing partial retries from pinning a provided buffer
across multiple executions, if ring provided buffers are used.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-38729" data-description="in the linux kernel, the following vulnerability has been resolved:

alsa: usb-audio: validate uac3 power domain descriptors, too

uac3 power domain descriptors need to be verified with its variable
blength for avoiding the unexpected oob accesses by malicious
firmware, too.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-38729" target="_blank">CVE-2025-38729</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-09-04 11:15:43 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">N/A</span></p>
                    <p><span class="feed-label">CVSS Score:</span> N/A</p>
                    <p>In the Linux kernel, the following vulnerability has been resolved:

ALSA: usb-audio: Validate UAC3 power domain descriptors, too

UAC3 power domain descriptors need to be verified with its variable
bLength for avoiding the unexpected OOB accesses by malicious
firmware, too.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-38728" data-description="in the linux kernel, the following vulnerability has been resolved:

smb3: fix for slab out of bounds on mount to ksmbd

with kasan enabled, it is possible to get a slab out of bounds
during mount to ksmbd due to missing check in parse_server_interfaces()
(see below):

 bug: kasan: slab-out-of-bounds in
 parse_server_interfaces+0x14ee/0x1880 [cifs]
 read of size 4 at addr ffff8881433dba98 by task mount/9827

 cpu: 5 uid: 0 pid: 9827 comm: mount tainted: g
 oe       6.16.0-rc2-kasan #2 preempt(voluntary)
 tainted: [o]=oot_module, [e]=unsigned_module
 hardware name: dell inc. precision tower 3620/0mwypt,
 bios 2.13.1 06/14/2019
 call trace:
  <task>
 dump_stack_lvl+0x9f/0xf0
 print_report+0xd1/0x670
 __virt_addr_valid+0x22c/0x430
 ? parse_server_interfaces+0x14ee/0x1880 [cifs]
 ? kasan_complete_mode_report_info+0x2a/0x1f0
 ? parse_server_interfaces+0x14ee/0x1880 [cifs]
   kasan_report+0xd6/0x110
   parse_server_interfaces+0x14ee/0x1880 [cifs]
   __asan_report_load_n_noabort+0x13/0x20
   parse_server_interfaces+0x14ee/0x1880 [cifs]
 ? __pfx_parse_server_interfaces+0x10/0x10 [cifs]
 ? trace_hardirqs_on+0x51/0x60
 smb3_request_interfaces+0x1ad/0x3f0 [cifs]
 ? __pfx_smb3_request_interfaces+0x10/0x10 [cifs]
 ? smb2_tcon+0x23c/0x15d0 [cifs]
 smb3_qfs_tcon+0x173/0x2b0 [cifs]
 ? __pfx_smb3_qfs_tcon+0x10/0x10 [cifs]
 ? cifs_get_tcon+0x105d/0x2120 [cifs]
 ? do_raw_spin_unlock+0x5d/0x200
 ? cifs_get_tcon+0x105d/0x2120 [cifs]
 ? __pfx_smb3_qfs_tcon+0x10/0x10 [cifs]
 cifs_mount_get_tcon+0x369/0xb90 [cifs]
 ? dfs_cache_find+0xe7/0x150 [cifs]
 dfs_mount_share+0x985/0x2970 [cifs]
 ? check_path.constprop.0+0x28/0x50
 ? save_trace+0x54/0x370
 ? __pfx_dfs_mount_share+0x10/0x10 [cifs]
 ? __lock_acquire+0xb82/0x2ba0
 ? __kasan_check_write+0x18/0x20
 cifs_mount+0xbc/0x9e0 [cifs]
 ? __pfx_cifs_mount+0x10/0x10 [cifs]
 ? do_raw_spin_unlock+0x5d/0x200
 ? cifs_setup_cifs_sb+0x29d/0x810 [cifs]
 cifs_smb3_do_mount+0x263/0x1990 [cifs]">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-38728" target="_blank">CVE-2025-38728</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-09-04 11:15:42 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">N/A</span></p>
                    <p><span class="feed-label">CVSS Score:</span> N/A</p>
                    <p>In the Linux kernel, the following vulnerability has been resolved:

smb3: fix for slab out of bounds on mount to ksmbd

With KASAN enabled, it is possible to get a slab out of bounds
during mount to ksmbd due to missing check in parse_server_interfaces()
(see below):

 BUG: KASAN: slab-out-of-bounds in
 parse_server_interfaces+0x14ee/0x1880 [cifs]
 Read of size 4 at addr ffff8881433dba98 by task mount/9827

 CPU: 5 UID: 0 PID: 9827 Comm: mount Tainted: G
 OE       6.16.0-rc2-kasan #2 PREEMPT(voluntary)
 Tainted: [O]=OOT_MODULE, [E]=UNSIGNED_MODULE
 Hardware name: Dell Inc. Precision Tower 3620/0MWYPT,
 BIOS 2.13.1 06/14/2019
 Call Trace:
  <TASK>
 dump_stack_lvl+0x9f/0xf0
 print_report+0xd1/0x670
 __virt_addr_valid+0x22c/0x430
 ? parse_server_interfaces+0x14ee/0x1880 [cifs]
 ? kasan_complete_mode_report_info+0x2a/0x1f0
 ? parse_server_interfaces+0x14ee/0x1880 [cifs]
   kasan_report+0xd6/0x110
   parse_server_interfaces+0x14ee/0x1880 [cifs]
   __asan_report_load_n_noabort+0x13/0x20
   parse_server_interfaces+0x14ee/0x1880 [cifs]
 ? __pfx_parse_server_interfaces+0x10/0x10 [cifs]
 ? trace_hardirqs_on+0x51/0x60
 SMB3_request_interfaces+0x1ad/0x3f0 [cifs]
 ? __pfx_SMB3_request_interfaces+0x10/0x10 [cifs]
 ? SMB2_tcon+0x23c/0x15d0 [cifs]
 smb3_qfs_tcon+0x173/0x2b0 [cifs]
 ? __pfx_smb3_qfs_tcon+0x10/0x10 [cifs]
 ? cifs_get_tcon+0x105d/0x2120 [cifs]
 ? do_raw_spin_unlock+0x5d/0x200
 ? cifs_get_tcon+0x105d/0x2120 [cifs]
 ? __pfx_smb3_qfs_tcon+0x10/0x10 [cifs]
 cifs_mount_get_tcon+0x369/0xb90 [cifs]
 ? dfs_cache_find+0xe7/0x150 [cifs]
 dfs_mount_share+0x985/0x2970 [cifs]
 ? check_path.constprop.0+0x28/0x50
 ? save_trace+0x54/0x370
 ? __pfx_dfs_mount_share+0x10/0x10 [cifs]
 ? __lock_acquire+0xb82/0x2ba0
 ? __kasan_check_write+0x18/0x20
 cifs_mount+0xbc/0x9e0 [cifs]
 ? __pfx_cifs_mount+0x10/0x10 [cifs]
 ? do_raw_spin_unlock+0x5d/0x200
 ? cifs_setup_cifs_sb+0x29d/0x810 [cifs]
 cifs_smb3_do_mount+0x263/0x1990 [cifs]</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-38727" data-description="in the linux kernel, the following vulnerability has been resolved:

netlink: avoid infinite retry looping in netlink_unicast()

netlink_attachskb() checks for the socket's read memory allocation
constraints. firstly, it has:

  rmem < read_once(sk->sk_rcvbuf)

to check if the just increased rmem value fits into the socket's receive
buffer. if not, it proceeds and tries to wait for the memory under:

  rmem + skb->truesize > read_once(sk->sk_rcvbuf)

the checks don't cover the case when skb->truesize + sk->sk_rmem_alloc is
equal to sk->sk_rcvbuf. thus the function neither successfully accepts
these conditions, nor manages to reschedule the task - and is called in
retry loop for indefinite time which is caught as:

  rcu: info: rcu_sched self-detected stall on cpu
  rcu:     0-....: (25999 ticks this gp) idle=ef2/1/0x4000000000000000 softirq=262269/262269 fqs=6212
  (t=26000 jiffies g=230833 q=259957)
  nmi backtrace for cpu 0
  cpu: 0 pid: 22 comm: kauditd not tainted 5.10.240 #68
  hardware name: qemu standard pc (i440fx + piix, 1996), bios 1.17.0-4.fc42 04/01/2014
  call trace:
  <irq>
  dump_stack lib/dump_stack.c:120
  nmi_cpu_backtrace.cold lib/nmi_backtrace.c:105
  nmi_trigger_cpumask_backtrace lib/nmi_backtrace.c:62
  rcu_dump_cpu_stacks kernel/rcu/tree_stall.h:335
  rcu_sched_clock_irq.cold kernel/rcu/tree.c:2590
  update_process_times kernel/time/timer.c:1953
  tick_sched_handle kernel/time/tick-sched.c:227
  tick_sched_timer kernel/time/tick-sched.c:1399
  __hrtimer_run_queues kernel/time/hrtimer.c:1652
  hrtimer_interrupt kernel/time/hrtimer.c:1717
  __sysvec_apic_timer_interrupt arch/x86/kernel/apic/apic.c:1113
  asm_call_irq_on_stack arch/x86/entry/entry_64.s:808
  </irq>

  netlink_attachskb net/netlink/af_netlink.c:1234
  netlink_unicast net/netlink/af_netlink.c:1349
  kauditd_send_queue kernel/audit.c:776
  kauditd_thread kernel/audit.c:897
  kthread kernel/kthread.c:328
  ret_from_fork arch/x86/entry/entry_64.s:304

restore the original behavior of the check which commit in fixes
accidentally missed when restructuring the code.

found by linux verification center (linuxtesting.org).">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-38727" target="_blank">CVE-2025-38727</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-09-04 11:15:42 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">N/A</span></p>
                    <p><span class="feed-label">CVSS Score:</span> N/A</p>
                    <p>In the Linux kernel, the following vulnerability has been resolved:

netlink: avoid infinite retry looping in netlink_unicast()

netlink_attachskb() checks for the socket's read memory allocation
constraints. Firstly, it has:

  rmem < READ_ONCE(sk->sk_rcvbuf)

to check if the just increased rmem value fits into the socket's receive
buffer. If not, it proceeds and tries to wait for the memory under:

  rmem + skb->truesize > READ_ONCE(sk->sk_rcvbuf)

The checks don't cover the case when skb->truesize + sk->sk_rmem_alloc is
equal to sk->sk_rcvbuf. Thus the function neither successfully accepts
these conditions, nor manages to reschedule the task - and is called in
retry loop for indefinite time which is caught as:

  rcu: INFO: rcu_sched self-detected stall on CPU
  rcu:     0-....: (25999 ticks this GP) idle=ef2/1/0x4000000000000000 softirq=262269/262269 fqs=6212
  (t=26000 jiffies g=230833 q=259957)
  NMI backtrace for cpu 0
  CPU: 0 PID: 22 Comm: kauditd Not tainted 5.10.240 #68
  Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.17.0-4.fc42 04/01/2014
  Call Trace:
  <IRQ>
  dump_stack lib/dump_stack.c:120
  nmi_cpu_backtrace.cold lib/nmi_backtrace.c:105
  nmi_trigger_cpumask_backtrace lib/nmi_backtrace.c:62
  rcu_dump_cpu_stacks kernel/rcu/tree_stall.h:335
  rcu_sched_clock_irq.cold kernel/rcu/tree.c:2590
  update_process_times kernel/time/timer.c:1953
  tick_sched_handle kernel/time/tick-sched.c:227
  tick_sched_timer kernel/time/tick-sched.c:1399
  __hrtimer_run_queues kernel/time/hrtimer.c:1652
  hrtimer_interrupt kernel/time/hrtimer.c:1717
  __sysvec_apic_timer_interrupt arch/x86/kernel/apic/apic.c:1113
  asm_call_irq_on_stack arch/x86/entry/entry_64.S:808
  </IRQ>

  netlink_attachskb net/netlink/af_netlink.c:1234
  netlink_unicast net/netlink/af_netlink.c:1349
  kauditd_send_queue kernel/audit.c:776
  kauditd_thread kernel/audit.c:897
  kthread kernel/kthread.c:328
  ret_from_fork arch/x86/entry/entry_64.S:304

Restore the original behavior of the check which commit in Fixes
accidentally missed when restructuring the code.

Found by Linux Verification Center (linuxtesting.org).</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-38726" data-description="in the linux kernel, the following vulnerability has been resolved:

net: ftgmac100: fix potential null pointer access in ftgmac100_phy_disconnect

after the call to phy_disconnect() netdev->phydev is reset to null.
so fixed_phy_unregister() would be called with a null pointer as argument.
therefore cache the phy_device before this call.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-38726" target="_blank">CVE-2025-38726</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-09-04 11:15:42 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">N/A</span></p>
                    <p><span class="feed-label">CVSS Score:</span> N/A</p>
                    <p>In the Linux kernel, the following vulnerability has been resolved:

net: ftgmac100: fix potential NULL pointer access in ftgmac100_phy_disconnect

After the call to phy_disconnect() netdev->phydev is reset to NULL.
So fixed_phy_unregister() would be called with a NULL pointer as argument.
Therefore cache the phy_device before this call.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-38725" data-description="in the linux kernel, the following vulnerability has been resolved:

net: usb: asix_devices: add phy_mask for ax88772 mdio bus

without setting phy_mask for ax88772 mdio bus, current driver may create
at most 32 mdio phy devices with phy address range from 0x00 ~ 0x1f.
dlink dub-e100 h/w ver b1 is such a device. however, only one main phy
device will bind to net phy driver. this is creating issue during system
suspend/resume since phy_polling_mode() in phy_state_machine() will
directly deference member of phydev->drv for non-main phy devices. then
null pointer dereference issue will occur. due to only external phy or
internal phy is necessary, add phy_mask for ax88772 mdio bus to workarnoud
the issue.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-38725" target="_blank">CVE-2025-38725</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-09-04 11:15:42 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">N/A</span></p>
                    <p><span class="feed-label">CVSS Score:</span> N/A</p>
                    <p>In the Linux kernel, the following vulnerability has been resolved:

net: usb: asix_devices: add phy_mask for ax88772 mdio bus

Without setting phy_mask for ax88772 mdio bus, current driver may create
at most 32 mdio phy devices with phy address range from 0x00 ~ 0x1f.
DLink DUB-E100 H/W Ver B1 is such a device. However, only one main phy
device will bind to net phy driver. This is creating issue during system
suspend/resume since phy_polling_mode() in phy_state_machine() will
directly deference member of phydev->drv for non-main phy devices. Then
NULL pointer dereference issue will occur. Due to only external phy or
internal phy is necessary, add phy_mask for ax88772 mdio bus to workarnoud
the issue.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-38724" data-description="in the linux kernel, the following vulnerability has been resolved:

nfsd: handle get_client_locked() failure in nfsd4_setclientid_confirm()

lei lu recently reported that nfsd4_setclientid_confirm() did not check
the return value from get_client_locked(). a setclientid_confirm could
race with a confirmed client expiring and fail to get a reference. that
could later lead to a uaf.

fix this by getting a reference early in the case where there is an
extant confirmed client. if that fails then treat it as if there were no
confirmed client found at all.

in the case where the unconfirmed client is expiring, just fail and
return the result from get_client_locked().">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-38724" target="_blank">CVE-2025-38724</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-09-04 11:15:42 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">N/A</span></p>
                    <p><span class="feed-label">CVSS Score:</span> N/A</p>
                    <p>In the Linux kernel, the following vulnerability has been resolved:

nfsd: handle get_client_locked() failure in nfsd4_setclientid_confirm()

Lei Lu recently reported that nfsd4_setclientid_confirm() did not check
the return value from get_client_locked(). a SETCLIENTID_CONFIRM could
race with a confirmed client expiring and fail to get a reference. That
could later lead to a UAF.

Fix this by getting a reference early in the case where there is an
extant confirmed client. If that fails then treat it as if there were no
confirmed client found at all.

In the case where the unconfirmed client is expiring, just fail and
return the result from get_client_locked().</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-38723" data-description="in the linux kernel, the following vulnerability has been resolved:

loongarch: bpf: fix jump offset calculation in tailcall

the extra pass of bpf_int_jit_compile() skips jit context initialization
which essentially skips offset calculation leaving out_offset = -1, so
the jmp_offset in emit_bpf_tail_call is calculated by

"#define jmp_offset (out_offset - (cur_offset))"

is a negative number, which is wrong. the final generated assembly are
as follow.

54:	bgeu        	$a2, $t1, -8	    # 0x0000004c
58:	addi.d      	$a6, $s5, -1
5c:	bltz        	$a6, -16	    # 0x0000004c
60:	alsl.d      	$t2, $a2, $a1, 0x3
64:	ld.d        	$t2, $t2, 264
68:	beq         	$t2, $zero, -28	    # 0x0000004c

before apply this patch, the follow test case will reveal soft lock issues.

cd tools/testing/selftests/bpf/
./test_progs --allow=tailcalls/tailcall_bpf2bpf_1

dmesg:
watchdog: bug: soft lockup - cpu#2 stuck for 26s! [test_progs:25056]">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-38723" target="_blank">CVE-2025-38723</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-09-04 11:15:42 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">N/A</span></p>
                    <p><span class="feed-label">CVSS Score:</span> N/A</p>
                    <p>In the Linux kernel, the following vulnerability has been resolved:

LoongArch: BPF: Fix jump offset calculation in tailcall

The extra pass of bpf_int_jit_compile() skips JIT context initialization
which essentially skips offset calculation leaving out_offset = -1, so
the jmp_offset in emit_bpf_tail_call is calculated by

"#define jmp_offset (out_offset - (cur_offset))"

is a negative number, which is wrong. The final generated assembly are
as follow.

54:	bgeu        	$a2, $t1, -8	    # 0x0000004c
58:	addi.d      	$a6, $s5, -1
5c:	bltz        	$a6, -16	    # 0x0000004c
60:	alsl.d      	$t2, $a2, $a1, 0x3
64:	ld.d        	$t2, $t2, 264
68:	beq         	$t2, $zero, -28	    # 0x0000004c

Before apply this patch, the follow test case will reveal soft lock issues.

cd tools/testing/selftests/bpf/
./test_progs --allow=tailcalls/tailcall_bpf2bpf_1

dmesg:
watchdog: BUG: soft lockup - CPU#2 stuck for 26s! [test_progs:25056]</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-38722" data-description="in the linux kernel, the following vulnerability has been resolved:

habanalabs: fix uaf in export_dmabuf()

as soon as we'd inserted a file reference into descriptor table, another
thread could close it.  that's fine for the case when all we are doing is
returning that descriptor to userland (it's a race, but it's a userland
race and there's nothing the kernel can do about it).  however, if we
follow fd_install() with any kind of access to objects that would be
destroyed on close (be it the struct file itself or anything destroyed
by its ->release()), we have a uaf.

dma_buf_fd() is a combination of reserving a descriptor and fd_install().
habanalabs export_dmabuf() calls it and then proceeds to access the
objects destroyed on close.  in particular, it grabs an extra reference to
another struct file that will be dropped as part of ->release() for ours;
that "will be" is actually "might have already been".

fix that by reserving descriptor before anything else and do fd_install()
only when everything had been set up.  as a side benefit, we no longer
have the failure exit with file already created, but reference to
underlying file (as well as ->dmabuf_export_cnt, etc.) not grabbed yet;
unlike dma_buf_fd(), fd_install() can't fail.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-38722" target="_blank">CVE-2025-38722</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-09-04 11:15:41 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">N/A</span></p>
                    <p><span class="feed-label">CVSS Score:</span> N/A</p>
                    <p>In the Linux kernel, the following vulnerability has been resolved:

habanalabs: fix UAF in export_dmabuf()

As soon as we'd inserted a file reference into descriptor table, another
thread could close it.  That's fine for the case when all we are doing is
returning that descriptor to userland (it's a race, but it's a userland
race and there's nothing the kernel can do about it).  However, if we
follow fd_install() with any kind of access to objects that would be
destroyed on close (be it the struct file itself or anything destroyed
by its ->release()), we have a UAF.

dma_buf_fd() is a combination of reserving a descriptor and fd_install().
habanalabs export_dmabuf() calls it and then proceeds to access the
objects destroyed on close.  In particular, it grabs an extra reference to
another struct file that will be dropped as part of ->release() for ours;
that "will be" is actually "might have already been".

Fix that by reserving descriptor before anything else and do fd_install()
only when everything had been set up.  As a side benefit, we no longer
have the failure exit with file already created, but reference to
underlying file (as well as ->dmabuf_export_cnt, etc.) not grabbed yet;
unlike dma_buf_fd(), fd_install() can't fail.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-38721" data-description="in the linux kernel, the following vulnerability has been resolved:

netfilter: ctnetlink: fix refcount leak on table dump

there is a reference count leak in ctnetlink_dump_table():
      if (res < 0) {
                nf_conntrack_get(&ct->ct_general); // here
                cb->args[1] = (unsigned long)ct;
                ...

while its very unlikely, its possible that ct == last.
if this happens, then the refcount of ct was already incremented.
this 2nd increment is never undone.

this prevents the conntrack object from being released, which in turn
keeps prevents cnet->count from dropping back to 0.

this will then block the netns dismantle (or conntrack rmmod) as
nf_conntrack_cleanup_net_list() will wait forever.

this can be reproduced by running conntrack_resize.sh selftest in a loop.
it takes ~20 minutes for me on a preemptible kernel on average before
i see a runaway kworker spinning in nf_conntrack_cleanup_net_list.

one fix would to change this to:
        if (res < 0) {
		if (ct != last)
	                nf_conntrack_get(&ct->ct_general);

but this reference counting isn't needed in the first place.
we can just store a cookie value instead.

a followup patch will do the same for ctnetlink_exp_dump_table,
it looks to me as if this has the same problem and like
ctnetlink_dump_table, we only need a 'skip hint', not the actual
object so we can apply the same cookie strategy there as well.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-38721" target="_blank">CVE-2025-38721</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-09-04 11:15:41 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">N/A</span></p>
                    <p><span class="feed-label">CVSS Score:</span> N/A</p>
                    <p>In the Linux kernel, the following vulnerability has been resolved:

netfilter: ctnetlink: fix refcount leak on table dump

There is a reference count leak in ctnetlink_dump_table():
      if (res < 0) {
                nf_conntrack_get(&ct->ct_general); // HERE
                cb->args[1] = (unsigned long)ct;
                ...

While its very unlikely, its possible that ct == last.
If this happens, then the refcount of ct was already incremented.
This 2nd increment is never undone.

This prevents the conntrack object from being released, which in turn
keeps prevents cnet->count from dropping back to 0.

This will then block the netns dismantle (or conntrack rmmod) as
nf_conntrack_cleanup_net_list() will wait forever.

This can be reproduced by running conntrack_resize.sh selftest in a loop.
It takes ~20 minutes for me on a preemptible kernel on average before
I see a runaway kworker spinning in nf_conntrack_cleanup_net_list.

One fix would to change this to:
        if (res < 0) {
		if (ct != last)
	                nf_conntrack_get(&ct->ct_general);

But this reference counting isn't needed in the first place.
We can just store a cookie value instead.

A followup patch will do the same for ctnetlink_exp_dump_table,
it looks to me as if this has the same problem and like
ctnetlink_dump_table, we only need a 'skip hint', not the actual
object so we can apply the same cookie strategy there as well.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-38720" data-description="in the linux kernel, the following vulnerability has been resolved:

net: hibmcge: fix rtnl deadlock issue

currently, the hibmcge netdev acquires the rtnl_lock in
pci_error_handlers.reset_prepare() and releases it in
pci_error_handlers.reset_done().

however, in the pci framework:
pci_reset_bus - __pci_reset_slot - pci_slot_save_and_disable_locked -
 pci_dev_save_and_disable - err_handler->reset_prepare(dev);

in pci_slot_save_and_disable_locked():
	list_for_each_entry(dev, &slot->bus->devices, bus_list) {
		if (!dev->slot || dev->slot!= slot)
			continue;
		pci_dev_save_and_disable(dev);
		if (dev->subordinate)
			pci_bus_save_and_disable_locked(dev->subordinate);
	}

this will iterate through all devices under the current bus and execute
err_handler->reset_prepare(), causing two devices of the hibmcge driver
to sequentially request the rtnl_lock, leading to a deadlock.

since the driver now executes netif_device_detach()
before the reset process, it will not concurrently with
other netdev apis, so there is no need to hold the rtnl_lock now.

therefore, this patch removes the rtnl_lock during the reset process and
adjusts the position of hbg_nic_state_resetting to ensure
that multiple resets are not executed concurrently.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-38720" target="_blank">CVE-2025-38720</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-09-04 11:15:41 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">N/A</span></p>
                    <p><span class="feed-label">CVSS Score:</span> N/A</p>
                    <p>In the Linux kernel, the following vulnerability has been resolved:

net: hibmcge: fix rtnl deadlock issue

Currently, the hibmcge netdev acquires the rtnl_lock in
pci_error_handlers.reset_prepare() and releases it in
pci_error_handlers.reset_done().

However, in the PCI framework:
pci_reset_bus - __pci_reset_slot - pci_slot_save_and_disable_locked -
 pci_dev_save_and_disable - err_handler->reset_prepare(dev);

In pci_slot_save_and_disable_locked():
	list_for_each_entry(dev, &slot->bus->devices, bus_list) {
		if (!dev->slot || dev->slot!= slot)
			continue;
		pci_dev_save_and_disable(dev);
		if (dev->subordinate)
			pci_bus_save_and_disable_locked(dev->subordinate);
	}

This will iterate through all devices under the current bus and execute
err_handler->reset_prepare(), causing two devices of the hibmcge driver
to sequentially request the rtnl_lock, leading to a deadlock.

Since the driver now executes netif_device_detach()
before the reset process, it will not concurrently with
other netdev APIs, so there is no need to hold the rtnl_lock now.

Therefore, this patch removes the rtnl_lock during the reset process and
adjusts the position of HBG_NIC_STATE_RESETTING to ensure
that multiple resets are not executed concurrently.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-38719" data-description="in the linux kernel, the following vulnerability has been resolved:

net: hibmcge: fix the division by zero issue

when the network port is down, the queue is released, and ring->len is 0.
in debugfs, hbg_get_queue_used_num() will be called,
which may lead to a division by zero issue.

this patch adds a check, if ring->len is 0,
hbg_get_queue_used_num() directly returns 0.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-38719" target="_blank">CVE-2025-38719</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-09-04 11:15:41 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">N/A</span></p>
                    <p><span class="feed-label">CVSS Score:</span> N/A</p>
                    <p>In the Linux kernel, the following vulnerability has been resolved:

net: hibmcge: fix the division by zero issue

When the network port is down, the queue is released, and ring->len is 0.
In debugfs, hbg_get_queue_used_num() will be called,
which may lead to a division by zero issue.

This patch adds a check, if ring->len is 0,
hbg_get_queue_used_num() directly returns 0.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-38718" data-description="in the linux kernel, the following vulnerability has been resolved:

sctp: linearize cloned gso packets in sctp_rcv

a cloned head skb still shares these frag skbs in fraglist with the
original head skb. it's not safe to access these frag skbs.

syzbot reported two use-of-uninitialized-memory bugs caused by this:

  bug: kmsan: uninit-value in sctp_inq_pop+0x15b7/0x1920 net/sctp/inqueue.c:211
   sctp_inq_pop+0x15b7/0x1920 net/sctp/inqueue.c:211
   sctp_assoc_bh_rcv+0x1a7/0xc50 net/sctp/associola.c:998
   sctp_inq_push+0x2ef/0x380 net/sctp/inqueue.c:88
   sctp_backlog_rcv+0x397/0xdb0 net/sctp/input.c:331
   sk_backlog_rcv+0x13b/0x420 include/net/sock.h:1122
   __release_sock+0x1da/0x330 net/core/sock.c:3106
   release_sock+0x6b/0x250 net/core/sock.c:3660
   sctp_wait_for_connect+0x487/0x820 net/sctp/socket.c:9360
   sctp_sendmsg_to_asoc+0x1ec1/0x1f00 net/sctp/socket.c:1885
   sctp_sendmsg+0x32b9/0x4a80 net/sctp/socket.c:2031
   inet_sendmsg+0x25a/0x280 net/ipv4/af_inet.c:851
   sock_sendmsg_nosec net/socket.c:718 [inline]

and

  bug: kmsan: uninit-value in sctp_assoc_bh_rcv+0x34e/0xbc0 net/sctp/associola.c:987
   sctp_assoc_bh_rcv+0x34e/0xbc0 net/sctp/associola.c:987
   sctp_inq_push+0x2a3/0x350 net/sctp/inqueue.c:88
   sctp_backlog_rcv+0x3c7/0xda0 net/sctp/input.c:331
   sk_backlog_rcv+0x142/0x420 include/net/sock.h:1148
   __release_sock+0x1d3/0x330 net/core/sock.c:3213
   release_sock+0x6b/0x270 net/core/sock.c:3767
   sctp_wait_for_connect+0x458/0x820 net/sctp/socket.c:9367
   sctp_sendmsg_to_asoc+0x223a/0x2260 net/sctp/socket.c:1886
   sctp_sendmsg+0x3910/0x49f0 net/sctp/socket.c:2032
   inet_sendmsg+0x269/0x2a0 net/ipv4/af_inet.c:851
   sock_sendmsg_nosec net/socket.c:712 [inline]

this patch fixes it by linearizing cloned gso packets in sctp_rcv().">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-38718" target="_blank">CVE-2025-38718</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-09-04 11:15:41 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">N/A</span></p>
                    <p><span class="feed-label">CVSS Score:</span> N/A</p>
                    <p>In the Linux kernel, the following vulnerability has been resolved:

sctp: linearize cloned gso packets in sctp_rcv

A cloned head skb still shares these frag skbs in fraglist with the
original head skb. It's not safe to access these frag skbs.

syzbot reported two use-of-uninitialized-memory bugs caused by this:

  BUG: KMSAN: uninit-value in sctp_inq_pop+0x15b7/0x1920 net/sctp/inqueue.c:211
   sctp_inq_pop+0x15b7/0x1920 net/sctp/inqueue.c:211
   sctp_assoc_bh_rcv+0x1a7/0xc50 net/sctp/associola.c:998
   sctp_inq_push+0x2ef/0x380 net/sctp/inqueue.c:88
   sctp_backlog_rcv+0x397/0xdb0 net/sctp/input.c:331
   sk_backlog_rcv+0x13b/0x420 include/net/sock.h:1122
   __release_sock+0x1da/0x330 net/core/sock.c:3106
   release_sock+0x6b/0x250 net/core/sock.c:3660
   sctp_wait_for_connect+0x487/0x820 net/sctp/socket.c:9360
   sctp_sendmsg_to_asoc+0x1ec1/0x1f00 net/sctp/socket.c:1885
   sctp_sendmsg+0x32b9/0x4a80 net/sctp/socket.c:2031
   inet_sendmsg+0x25a/0x280 net/ipv4/af_inet.c:851
   sock_sendmsg_nosec net/socket.c:718 [inline]

and

  BUG: KMSAN: uninit-value in sctp_assoc_bh_rcv+0x34e/0xbc0 net/sctp/associola.c:987
   sctp_assoc_bh_rcv+0x34e/0xbc0 net/sctp/associola.c:987
   sctp_inq_push+0x2a3/0x350 net/sctp/inqueue.c:88
   sctp_backlog_rcv+0x3c7/0xda0 net/sctp/input.c:331
   sk_backlog_rcv+0x142/0x420 include/net/sock.h:1148
   __release_sock+0x1d3/0x330 net/core/sock.c:3213
   release_sock+0x6b/0x270 net/core/sock.c:3767
   sctp_wait_for_connect+0x458/0x820 net/sctp/socket.c:9367
   sctp_sendmsg_to_asoc+0x223a/0x2260 net/sctp/socket.c:1886
   sctp_sendmsg+0x3910/0x49f0 net/sctp/socket.c:2032
   inet_sendmsg+0x269/0x2a0 net/ipv4/af_inet.c:851
   sock_sendmsg_nosec net/socket.c:712 [inline]

This patch fixes it by linearizing cloned gso packets in sctp_rcv().</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-38717" data-description="in the linux kernel, the following vulnerability has been resolved:

net: kcm: fix race condition in kcm_unattach()

syzbot found a race condition when kcm_unattach(psock)
and kcm_release(kcm) are executed at the same time.

kcm_unattach() is missing a check of the flag
kcm->tx_stopped before calling queue_work().

if the kcm has a reserved psock, kcm_unattach() might get executed
between cancel_work_sync() and unreserve_psock() in kcm_release(),
requeuing kcm->tx_work right before kcm gets freed in kcm_done().

remove kcm->tx_stopped and replace it by the less
error-prone disable_work_sync().">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-38717" target="_blank">CVE-2025-38717</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-09-04 11:15:41 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">N/A</span></p>
                    <p><span class="feed-label">CVSS Score:</span> N/A</p>
                    <p>In the Linux kernel, the following vulnerability has been resolved:

net: kcm: Fix race condition in kcm_unattach()

syzbot found a race condition when kcm_unattach(psock)
and kcm_release(kcm) are executed at the same time.

kcm_unattach() is missing a check of the flag
kcm->tx_stopped before calling queue_work().

If the kcm has a reserved psock, kcm_unattach() might get executed
between cancel_work_sync() and unreserve_psock() in kcm_release(),
requeuing kcm->tx_work right before kcm gets freed in kcm_done().

Remove kcm->tx_stopped and replace it by the less
error-prone disable_work_sync().</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-38716" data-description="in the linux kernel, the following vulnerability has been resolved:

hfs: fix general protection fault in hfs_find_init()

the hfs_find_init() method can trigger the crash
if tree pointer is null:

[   45.746290][ t9787] oops: general protection fault, probably for non-canonical address 0xdffffc0000000008: 0000 [#1] smp kai
[   45.747287][ t9787] kasan: null-ptr-deref in range [0x0000000000000040-0x0000000000000047]
[   45.748716][ t9787] cpu: 2 uid: 0 pid: 9787 comm: repro not tainted 6.16.0-rc3 #10 preempt(full)
[   45.750250][ t9787] hardware name: qemu ubuntu 24.04 pc (i440fx + piix, 1996), bios 1.16.3-debian-1.16.3-2 04/01/2014
[   45.751983][ t9787] rip: 0010:hfs_find_init+0x86/0x230
[   45.752834][ t9787] code: c1 ea 03 80 3c 02 00 0f 85 9a 01 00 00 4c 8d 6b 40 48 c7 45 18 00 00 00 00 48 b8 00 00 00 00 00 fc
[   45.755574][ t9787] rsp: 0018:ffffc90015157668 eflags: 00010202
[   45.756432][ t9787] rax: dffffc0000000000 rbx: 0000000000000000 rcx: ffffffff819a4d09
[   45.757457][ t9787] rdx: 0000000000000008 rsi: ffffffff819acd3a rdi: ffffc900151576e8
[   45.758282][ t9787] rbp: ffffc900151576d0 r08: 0000000000000005 r09: 0000000000000000
[   45.758943][ t9787] r10: 0000000080000000 r11: 0000000000000001 r12: 0000000000000004
[   45.759619][ t9787] r13: 0000000000000040 r14: ffff88802c50814a r15: 0000000000000000
[   45.760293][ t9787] fs:  00007ffb72734540(0000) gs:ffff8880cec64000(0000) knlgs:0000000000000000
[   45.761050][ t9787] cs:  0010 ds: 0000 es: 0000 cr0: 0000000080050033
[   45.761606][ t9787] cr2: 00007f9bd8225000 cr3: 000000010979a000 cr4: 00000000000006f0
[   45.762286][ t9787] call trace:
[   45.762570][ t9787]  <task>
[   45.762824][ t9787]  hfs_ext_read_extent+0x190/0x9d0
[   45.763269][ t9787]  ? submit_bio_noacct_nocheck+0x2dd/0xce0
[   45.763766][ t9787]  ? __pfx_hfs_ext_read_extent+0x10/0x10
[   45.764250][ t9787]  hfs_get_block+0x55f/0x830
[   45.764646][ t9787]  block_read_full_folio+0x36d/0x850
[   45.765105][ t9787]  ? __pfx_hfs_get_block+0x10/0x10
[   45.765541][ t9787]  ? const_folio_flags+0x5b/0x100
[   45.765972][ t9787]  ? __pfx_hfs_read_folio+0x10/0x10
[   45.766415][ t9787]  filemap_read_folio+0xbe/0x290
[   45.766840][ t9787]  ? __pfx_filemap_read_folio+0x10/0x10
[   45.767325][ t9787]  ? __filemap_get_folio+0x32b/0xbf0
[   45.767780][ t9787]  do_read_cache_folio+0x263/0x5c0
[   45.768223][ t9787]  ? __pfx_hfs_read_folio+0x10/0x10
[   45.768666][ t9787]  read_cache_page+0x5b/0x160
[   45.769070][ t9787]  hfs_btree_open+0x491/0x1740
[   45.769481][ t9787]  hfs_mdb_get+0x15e2/0x1fb0
[   45.769877][ t9787]  ? __pfx_hfs_mdb_get+0x10/0x10
[   45.770316][ t9787]  ? find_held_lock+0x2b/0x80
[   45.770731][ t9787]  ? lockdep_init_map_type+0x5c/0x280
[   45.771200][ t9787]  ? lockdep_init_map_type+0x5c/0x280
[   45.771674][ t9787]  hfs_fill_super+0x38e/0x720
[   45.772092][ t9787]  ? __pfx_hfs_fill_super+0x10/0x10
[   45.772549][ t9787]  ? snprintf+0xbe/0x100
[   45.772931][ t9787]  ? __pfx_snprintf+0x10/0x10
[   45.773350][ t9787]  ? do_raw_spin_lock+0x129/0x2b0
[   45.773796][ t9787]  ? find_held_lock+0x2b/0x80
[   45.774215][ t9787]  ? set_blocksize+0x40a/0x510
[   45.774636][ t9787]  ? sb_set_blocksize+0x176/0x1d0
[   45.775087][ t9787]  ? setup_bdev_super+0x369/0x730
[   45.775533][ t9787]  get_tree_bdev_flags+0x384/0x620
[   45.775985][ t9787]  ? __pfx_hfs_fill_super+0x10/0x10
[   45.776453][ t9787]  ? __pfx_get_tree_bdev_flags+0x10/0x10
[   45.776950][ t9787]  ? bpf_lsm_capable+0x9/0x10
[   45.777365][ t9787]  ? security_capable+0x80/0x260
[   45.777803][ t9787]  vfs_get_tree+0x8e/0x340
[   45.778203][ t9787]  path_mount+0x13de/0x2010
[   45.778604][ t9787]  ? kmem_cache_free+0x2b0/0x4c0
[   45.779052][ t9787]  ? __pfx_path_mount+0x10/0x10
[   45.779480][ t9787]  ? getname_flags.part.0+0x1c5/0x550
[   45.779954][ t9787]  ? putname+0x154/0x1a0
[   45.780335][ t9787]  __x64_sys_mount+0x27b/0x300
[   45.780758][ t9787]  ? __pfx___x64_sys_mount+0x10/0x10
[   45.781232][ t9787] 
---truncated---">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-38716" target="_blank">CVE-2025-38716</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-09-04 11:15:41 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">N/A</span></p>
                    <p><span class="feed-label">CVSS Score:</span> N/A</p>
                    <p>In the Linux kernel, the following vulnerability has been resolved:

hfs: fix general protection fault in hfs_find_init()

The hfs_find_init() method can trigger the crash
if tree pointer is NULL:

[   45.746290][ T9787] Oops: general protection fault, probably for non-canonical address 0xdffffc0000000008: 0000 [#1] SMP KAI
[   45.747287][ T9787] KASAN: null-ptr-deref in range [0x0000000000000040-0x0000000000000047]
[   45.748716][ T9787] CPU: 2 UID: 0 PID: 9787 Comm: repro Not tainted 6.16.0-rc3 #10 PREEMPT(full)
[   45.750250][ T9787] Hardware name: QEMU Ubuntu 24.04 PC (i440FX + PIIX, 1996), BIOS 1.16.3-debian-1.16.3-2 04/01/2014
[   45.751983][ T9787] RIP: 0010:hfs_find_init+0x86/0x230
[   45.752834][ T9787] Code: c1 ea 03 80 3c 02 00 0f 85 9a 01 00 00 4c 8d 6b 40 48 c7 45 18 00 00 00 00 48 b8 00 00 00 00 00 fc
[   45.755574][ T9787] RSP: 0018:ffffc90015157668 EFLAGS: 00010202
[   45.756432][ T9787] RAX: dffffc0000000000 RBX: 0000000000000000 RCX: ffffffff819a4d09
[   45.757457][ T9787] RDX: 0000000000000008 RSI: ffffffff819acd3a RDI: ffffc900151576e8
[   45.758282][ T9787] RBP: ffffc900151576d0 R08: 0000000000000005 R09: 0000000000000000
[   45.758943][ T9787] R10: 0000000080000000 R11: 0000000000000001 R12: 0000000000000004
[   45.759619][ T9787] R13: 0000000000000040 R14: ffff88802c50814a R15: 0000000000000000
[   45.760293][ T9787] FS:  00007ffb72734540(0000) GS:ffff8880cec64000(0000) knlGS:0000000000000000
[   45.761050][ T9787] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
[   45.761606][ T9787] CR2: 00007f9bd8225000 CR3: 000000010979a000 CR4: 00000000000006f0
[   45.762286][ T9787] Call Trace:
[   45.762570][ T9787]  <TASK>
[   45.762824][ T9787]  hfs_ext_read_extent+0x190/0x9d0
[   45.763269][ T9787]  ? submit_bio_noacct_nocheck+0x2dd/0xce0
[   45.763766][ T9787]  ? __pfx_hfs_ext_read_extent+0x10/0x10
[   45.764250][ T9787]  hfs_get_block+0x55f/0x830
[   45.764646][ T9787]  block_read_full_folio+0x36d/0x850
[   45.765105][ T9787]  ? __pfx_hfs_get_block+0x10/0x10
[   45.765541][ T9787]  ? const_folio_flags+0x5b/0x100
[   45.765972][ T9787]  ? __pfx_hfs_read_folio+0x10/0x10
[   45.766415][ T9787]  filemap_read_folio+0xbe/0x290
[   45.766840][ T9787]  ? __pfx_filemap_read_folio+0x10/0x10
[   45.767325][ T9787]  ? __filemap_get_folio+0x32b/0xbf0
[   45.767780][ T9787]  do_read_cache_folio+0x263/0x5c0
[   45.768223][ T9787]  ? __pfx_hfs_read_folio+0x10/0x10
[   45.768666][ T9787]  read_cache_page+0x5b/0x160
[   45.769070][ T9787]  hfs_btree_open+0x491/0x1740
[   45.769481][ T9787]  hfs_mdb_get+0x15e2/0x1fb0
[   45.769877][ T9787]  ? __pfx_hfs_mdb_get+0x10/0x10
[   45.770316][ T9787]  ? find_held_lock+0x2b/0x80
[   45.770731][ T9787]  ? lockdep_init_map_type+0x5c/0x280
[   45.771200][ T9787]  ? lockdep_init_map_type+0x5c/0x280
[   45.771674][ T9787]  hfs_fill_super+0x38e/0x720
[   45.772092][ T9787]  ? __pfx_hfs_fill_super+0x10/0x10
[   45.772549][ T9787]  ? snprintf+0xbe/0x100
[   45.772931][ T9787]  ? __pfx_snprintf+0x10/0x10
[   45.773350][ T9787]  ? do_raw_spin_lock+0x129/0x2b0
[   45.773796][ T9787]  ? find_held_lock+0x2b/0x80
[   45.774215][ T9787]  ? set_blocksize+0x40a/0x510
[   45.774636][ T9787]  ? sb_set_blocksize+0x176/0x1d0
[   45.775087][ T9787]  ? setup_bdev_super+0x369/0x730
[   45.775533][ T9787]  get_tree_bdev_flags+0x384/0x620
[   45.775985][ T9787]  ? __pfx_hfs_fill_super+0x10/0x10
[   45.776453][ T9787]  ? __pfx_get_tree_bdev_flags+0x10/0x10
[   45.776950][ T9787]  ? bpf_lsm_capable+0x9/0x10
[   45.777365][ T9787]  ? security_capable+0x80/0x260
[   45.777803][ T9787]  vfs_get_tree+0x8e/0x340
[   45.778203][ T9787]  path_mount+0x13de/0x2010
[   45.778604][ T9787]  ? kmem_cache_free+0x2b0/0x4c0
[   45.779052][ T9787]  ? __pfx_path_mount+0x10/0x10
[   45.779480][ T9787]  ? getname_flags.part.0+0x1c5/0x550
[   45.779954][ T9787]  ? putname+0x154/0x1a0
[   45.780335][ T9787]  __x64_sys_mount+0x27b/0x300
[   45.780758][ T9787]  ? __pfx___x64_sys_mount+0x10/0x10
[   45.781232][ T9787] 
---truncated---</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-38715" data-description="in the linux kernel, the following vulnerability has been resolved:

hfs: fix slab-out-of-bounds in hfs_bnode_read()

this patch introduces is_bnode_offset_valid() method that checks
the requested offset value. also, it introduces
check_and_correct_requested_length() method that checks and
correct the requested length (if it is necessary). these methods
are used in hfs_bnode_read(), hfs_bnode_write(), hfs_bnode_clear(),
hfs_bnode_copy(), and hfs_bnode_move() with the goal to prevent
the access out of allocated memory and triggering the crash.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-38715" target="_blank">CVE-2025-38715</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-09-04 11:15:40 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">N/A</span></p>
                    <p><span class="feed-label">CVSS Score:</span> N/A</p>
                    <p>In the Linux kernel, the following vulnerability has been resolved:

hfs: fix slab-out-of-bounds in hfs_bnode_read()

This patch introduces is_bnode_offset_valid() method that checks
the requested offset value. Also, it introduces
check_and_correct_requested_length() method that checks and
correct the requested length (if it is necessary). These methods
are used in hfs_bnode_read(), hfs_bnode_write(), hfs_bnode_clear(),
hfs_bnode_copy(), and hfs_bnode_move() with the goal to prevent
the access out of allocated memory and triggering the crash.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-38714" data-description="in the linux kernel, the following vulnerability has been resolved:

hfsplus: fix slab-out-of-bounds in hfsplus_bnode_read()

the hfsplus_bnode_read() method can trigger the issue:

[  174.852007][ t9784] ==================================================================
[  174.852709][ t9784] bug: kasan: slab-out-of-bounds in hfsplus_bnode_read+0x2f4/0x360
[  174.853412][ t9784] read of size 8 at addr ffff88810b5fc6c0 by task repro/9784
[  174.854059][ t9784]
[  174.854272][ t9784] cpu: 1 uid: 0 pid: 9784 comm: repro not tainted 6.16.0-rc3 #7 preempt(full)
[  174.854281][ t9784] hardware name: qemu ubuntu 24.04 pc (i440fx + piix, 1996), bios 1.16.3-debian-1.16.3-2 04/01/2014
[  174.854286][ t9784] call trace:
[  174.854289][ t9784]  <task>
[  174.854292][ t9784]  dump_stack_lvl+0x10e/0x1f0
[  174.854305][ t9784]  print_report+0xd0/0x660
[  174.854315][ t9784]  ? __virt_addr_valid+0x81/0x610
[  174.854323][ t9784]  ? __phys_addr+0xe8/0x180
[  174.854330][ t9784]  ? hfsplus_bnode_read+0x2f4/0x360
[  174.854337][ t9784]  kasan_report+0xc6/0x100
[  174.854346][ t9784]  ? hfsplus_bnode_read+0x2f4/0x360
[  174.854354][ t9784]  hfsplus_bnode_read+0x2f4/0x360
[  174.854362][ t9784]  hfsplus_bnode_dump+0x2ec/0x380
[  174.854370][ t9784]  ? __pfx_hfsplus_bnode_dump+0x10/0x10
[  174.854377][ t9784]  ? hfsplus_bnode_write_u16+0x83/0xb0
[  174.854385][ t9784]  ? srcu_gp_start+0xd0/0x310
[  174.854393][ t9784]  ? __mark_inode_dirty+0x29e/0xe40
[  174.854402][ t9784]  hfsplus_brec_remove+0x3d2/0x4e0
[  174.854411][ t9784]  __hfsplus_delete_attr+0x290/0x3a0
[  174.854419][ t9784]  ? __pfx_hfs_find_1st_rec_by_cnid+0x10/0x10
[  174.854427][ t9784]  ? __pfx___hfsplus_delete_attr+0x10/0x10
[  174.854436][ t9784]  ? __asan_memset+0x23/0x50
[  174.854450][ t9784]  hfsplus_delete_all_attrs+0x262/0x320
[  174.854459][ t9784]  ? __pfx_hfsplus_delete_all_attrs+0x10/0x10
[  174.854469][ t9784]  ? rcu_is_watching+0x12/0xc0
[  174.854476][ t9784]  ? __mark_inode_dirty+0x29e/0xe40
[  174.854483][ t9784]  hfsplus_delete_cat+0x845/0xde0
[  174.854493][ t9784]  ? __pfx_hfsplus_delete_cat+0x10/0x10
[  174.854507][ t9784]  hfsplus_unlink+0x1ca/0x7c0
[  174.854516][ t9784]  ? __pfx_hfsplus_unlink+0x10/0x10
[  174.854525][ t9784]  ? down_write+0x148/0x200
[  174.854532][ t9784]  ? __pfx_down_write+0x10/0x10
[  174.854540][ t9784]  vfs_unlink+0x2fe/0x9b0
[  174.854549][ t9784]  do_unlinkat+0x490/0x670
[  174.854557][ t9784]  ? __pfx_do_unlinkat+0x10/0x10
[  174.854565][ t9784]  ? __might_fault+0xbc/0x130
[  174.854576][ t9784]  ? getname_flags.part.0+0x1c5/0x550
[  174.854584][ t9784]  __x64_sys_unlink+0xc5/0x110
[  174.854592][ t9784]  do_syscall_64+0xc9/0x480
[  174.854600][ t9784]  entry_syscall_64_after_hwframe+0x77/0x7f
[  174.854608][ t9784] rip: 0033:0x7f6fdf4c3167
[  174.854614][ t9784] code: f0 ff ff 73 01 c3 48 8b 0d 26 0d 0e 00 f7 d8 64 89 01 48 83 c8 ff c3 66 2e 0f 1f 84 00 00 00 00 08
[  174.854622][ t9784] rsp: 002b:00007ffcb948bca8 eflags: 00000206 orig_rax: 0000000000000057
[  174.854630][ t9784] rax: ffffffffffffffda rbx: 0000000000000000 rcx: 00007f6fdf4c3167
[  174.854636][ t9784] rdx: 00007ffcb948bcc0 rsi: 00007ffcb948bcc0 rdi: 00007ffcb948bd50
[  174.854641][ t9784] rbp: 00007ffcb948cd90 r08: 0000000000000001 r09: 00007ffcb948bb40
[  174.854645][ t9784] r10: 00007f6fdf564fc0 r11: 0000000000000206 r12: 0000561e1bc9c2d0
[  174.854650][ t9784] r13: 0000000000000000 r14: 0000000000000000 r15: 0000000000000000
[  174.854658][ t9784]  </task>
[  174.854661][ t9784]
[  174.879281][ t9784] allocated by task 9784:
[  174.879664][ t9784]  kasan_save_stack+0x20/0x40
[  174.880082][ t9784]  kasan_save_track+0x14/0x30
[  174.880500][ t9784]  __kasan_kmalloc+0xaa/0xb0
[  174.880908][ t9784]  __kmalloc_noprof+0x205/0x550
[  174.881337][ t9784]  __hfs_bnode_create+0x107/0x890
[  174.881779][ t9784]  hfsplus_bnode_find+0x2d0/0xd10
[  174.882222][ t9784]  hfsplus_brec_find+0x2b0/0x520
[  174.882659][ t9784]  hfsplus_delete_all_attrs+0x23b/0x3
---truncated---">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-38714" target="_blank">CVE-2025-38714</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-09-04 11:15:40 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">N/A</span></p>
                    <p><span class="feed-label">CVSS Score:</span> N/A</p>
                    <p>In the Linux kernel, the following vulnerability has been resolved:

hfsplus: fix slab-out-of-bounds in hfsplus_bnode_read()

The hfsplus_bnode_read() method can trigger the issue:

[  174.852007][ T9784] ==================================================================
[  174.852709][ T9784] BUG: KASAN: slab-out-of-bounds in hfsplus_bnode_read+0x2f4/0x360
[  174.853412][ T9784] Read of size 8 at addr ffff88810b5fc6c0 by task repro/9784
[  174.854059][ T9784]
[  174.854272][ T9784] CPU: 1 UID: 0 PID: 9784 Comm: repro Not tainted 6.16.0-rc3 #7 PREEMPT(full)
[  174.854281][ T9784] Hardware name: QEMU Ubuntu 24.04 PC (i440FX + PIIX, 1996), BIOS 1.16.3-debian-1.16.3-2 04/01/2014
[  174.854286][ T9784] Call Trace:
[  174.854289][ T9784]  <TASK>
[  174.854292][ T9784]  dump_stack_lvl+0x10e/0x1f0
[  174.854305][ T9784]  print_report+0xd0/0x660
[  174.854315][ T9784]  ? __virt_addr_valid+0x81/0x610
[  174.854323][ T9784]  ? __phys_addr+0xe8/0x180
[  174.854330][ T9784]  ? hfsplus_bnode_read+0x2f4/0x360
[  174.854337][ T9784]  kasan_report+0xc6/0x100
[  174.854346][ T9784]  ? hfsplus_bnode_read+0x2f4/0x360
[  174.854354][ T9784]  hfsplus_bnode_read+0x2f4/0x360
[  174.854362][ T9784]  hfsplus_bnode_dump+0x2ec/0x380
[  174.854370][ T9784]  ? __pfx_hfsplus_bnode_dump+0x10/0x10
[  174.854377][ T9784]  ? hfsplus_bnode_write_u16+0x83/0xb0
[  174.854385][ T9784]  ? srcu_gp_start+0xd0/0x310
[  174.854393][ T9784]  ? __mark_inode_dirty+0x29e/0xe40
[  174.854402][ T9784]  hfsplus_brec_remove+0x3d2/0x4e0
[  174.854411][ T9784]  __hfsplus_delete_attr+0x290/0x3a0
[  174.854419][ T9784]  ? __pfx_hfs_find_1st_rec_by_cnid+0x10/0x10
[  174.854427][ T9784]  ? __pfx___hfsplus_delete_attr+0x10/0x10
[  174.854436][ T9784]  ? __asan_memset+0x23/0x50
[  174.854450][ T9784]  hfsplus_delete_all_attrs+0x262/0x320
[  174.854459][ T9784]  ? __pfx_hfsplus_delete_all_attrs+0x10/0x10
[  174.854469][ T9784]  ? rcu_is_watching+0x12/0xc0
[  174.854476][ T9784]  ? __mark_inode_dirty+0x29e/0xe40
[  174.854483][ T9784]  hfsplus_delete_cat+0x845/0xde0
[  174.854493][ T9784]  ? __pfx_hfsplus_delete_cat+0x10/0x10
[  174.854507][ T9784]  hfsplus_unlink+0x1ca/0x7c0
[  174.854516][ T9784]  ? __pfx_hfsplus_unlink+0x10/0x10
[  174.854525][ T9784]  ? down_write+0x148/0x200
[  174.854532][ T9784]  ? __pfx_down_write+0x10/0x10
[  174.854540][ T9784]  vfs_unlink+0x2fe/0x9b0
[  174.854549][ T9784]  do_unlinkat+0x490/0x670
[  174.854557][ T9784]  ? __pfx_do_unlinkat+0x10/0x10
[  174.854565][ T9784]  ? __might_fault+0xbc/0x130
[  174.854576][ T9784]  ? getname_flags.part.0+0x1c5/0x550
[  174.854584][ T9784]  __x64_sys_unlink+0xc5/0x110
[  174.854592][ T9784]  do_syscall_64+0xc9/0x480
[  174.854600][ T9784]  entry_SYSCALL_64_after_hwframe+0x77/0x7f
[  174.854608][ T9784] RIP: 0033:0x7f6fdf4c3167
[  174.854614][ T9784] Code: f0 ff ff 73 01 c3 48 8b 0d 26 0d 0e 00 f7 d8 64 89 01 48 83 c8 ff c3 66 2e 0f 1f 84 00 00 00 00 08
[  174.854622][ T9784] RSP: 002b:00007ffcb948bca8 EFLAGS: 00000206 ORIG_RAX: 0000000000000057
[  174.854630][ T9784] RAX: ffffffffffffffda RBX: 0000000000000000 RCX: 00007f6fdf4c3167
[  174.854636][ T9784] RDX: 00007ffcb948bcc0 RSI: 00007ffcb948bcc0 RDI: 00007ffcb948bd50
[  174.854641][ T9784] RBP: 00007ffcb948cd90 R08: 0000000000000001 R09: 00007ffcb948bb40
[  174.854645][ T9784] R10: 00007f6fdf564fc0 R11: 0000000000000206 R12: 0000561e1bc9c2d0
[  174.854650][ T9784] R13: 0000000000000000 R14: 0000000000000000 R15: 0000000000000000
[  174.854658][ T9784]  </TASK>
[  174.854661][ T9784]
[  174.879281][ T9784] Allocated by task 9784:
[  174.879664][ T9784]  kasan_save_stack+0x20/0x40
[  174.880082][ T9784]  kasan_save_track+0x14/0x30
[  174.880500][ T9784]  __kasan_kmalloc+0xaa/0xb0
[  174.880908][ T9784]  __kmalloc_noprof+0x205/0x550
[  174.881337][ T9784]  __hfs_bnode_create+0x107/0x890
[  174.881779][ T9784]  hfsplus_bnode_find+0x2d0/0xd10
[  174.882222][ T9784]  hfsplus_brec_find+0x2b0/0x520
[  174.882659][ T9784]  hfsplus_delete_all_attrs+0x23b/0x3
---truncated---</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-38713" data-description="in the linux kernel, the following vulnerability has been resolved:

hfsplus: fix slab-out-of-bounds read in hfsplus_uni2asc()

the hfsplus_readdir() method is capable to crash by calling
hfsplus_uni2asc():

[  667.121659][ t9805] ==================================================================
[  667.122651][ t9805] bug: kasan: slab-out-of-bounds in hfsplus_uni2asc+0x902/0xa10
[  667.123627][ t9805] read of size 2 at addr ffff88802592f40c by task repro/9805
[  667.124578][ t9805]
[  667.124876][ t9805] cpu: 3 uid: 0 pid: 9805 comm: repro not tainted 6.16.0-rc3 #1 preempt(full)
[  667.124886][ t9805] hardware name: qemu ubuntu 24.04 pc (i440fx + piix, 1996), bios 1.16.3-debian-1.16.3-2 04/01/2014
[  667.124890][ t9805] call trace:
[  667.124893][ t9805]  <task>
[  667.124896][ t9805]  dump_stack_lvl+0x10e/0x1f0
[  667.124911][ t9805]  print_report+0xd0/0x660
[  667.124920][ t9805]  ? __virt_addr_valid+0x81/0x610
[  667.124928][ t9805]  ? __phys_addr+0xe8/0x180
[  667.124934][ t9805]  ? hfsplus_uni2asc+0x902/0xa10
[  667.124942][ t9805]  kasan_report+0xc6/0x100
[  667.124950][ t9805]  ? hfsplus_uni2asc+0x902/0xa10
[  667.124959][ t9805]  hfsplus_uni2asc+0x902/0xa10
[  667.124966][ t9805]  ? hfsplus_bnode_read+0x14b/0x360
[  667.124974][ t9805]  hfsplus_readdir+0x845/0xfc0
[  667.124984][ t9805]  ? __pfx_hfsplus_readdir+0x10/0x10
[  667.124994][ t9805]  ? stack_trace_save+0x8e/0xc0
[  667.125008][ t9805]  ? iterate_dir+0x18b/0xb20
[  667.125015][ t9805]  ? trace_lock_acquire+0x85/0xd0
[  667.125022][ t9805]  ? lock_acquire+0x30/0x80
[  667.125029][ t9805]  ? iterate_dir+0x18b/0xb20
[  667.125037][ t9805]  ? down_read_killable+0x1ed/0x4c0
[  667.125044][ t9805]  ? putname+0x154/0x1a0
[  667.125051][ t9805]  ? __pfx_down_read_killable+0x10/0x10
[  667.125058][ t9805]  ? apparmor_file_permission+0x239/0x3e0
[  667.125069][ t9805]  iterate_dir+0x296/0xb20
[  667.125076][ t9805]  __x64_sys_getdents64+0x13c/0x2c0
[  667.125084][ t9805]  ? __pfx___x64_sys_getdents64+0x10/0x10
[  667.125091][ t9805]  ? __x64_sys_openat+0x141/0x200
[  667.125126][ t9805]  ? __pfx_filldir64+0x10/0x10
[  667.125134][ t9805]  ? do_user_addr_fault+0x7fe/0x12f0
[  667.125143][ t9805]  do_syscall_64+0xc9/0x480
[  667.125151][ t9805]  entry_syscall_64_after_hwframe+0x77/0x7f
[  667.125158][ t9805] rip: 0033:0x7fa8753b2fc9
[  667.125164][ t9805] code: 00 c3 66 2e 0f 1f 84 00 00 00 00 00 0f 1f 44 00 00 48 89 f8 48 89 f7 48 89 d6 48 89 ca 4d 89 c2 48
[  667.125172][ t9805] rsp: 002b:00007ffe96f8e0f8 eflags: 00000217 orig_rax: 00000000000000d9
[  667.125181][ t9805] rax: ffffffffffffffda rbx: 0000000000000000 rcx: 00007fa8753b2fc9
[  667.125185][ t9805] rdx: 0000000000000400 rsi: 00002000000063c0 rdi: 0000000000000004
[  667.125190][ t9805] rbp: 00007ffe96f8e110 r08: 00007ffe96f8e110 r09: 00007ffe96f8e110
[  667.125195][ t9805] r10: 0000000000000000 r11: 0000000000000217 r12: 0000556b1e3b4260
[  667.125199][ t9805] r13: 0000000000000000 r14: 0000000000000000 r15: 0000000000000000
[  667.125207][ t9805]  </task>
[  667.125210][ t9805]
[  667.145632][ t9805] allocated by task 9805:
[  667.145991][ t9805]  kasan_save_stack+0x20/0x40
[  667.146352][ t9805]  kasan_save_track+0x14/0x30
[  667.146717][ t9805]  __kasan_kmalloc+0xaa/0xb0
[  667.147065][ t9805]  __kmalloc_noprof+0x205/0x550
[  667.147448][ t9805]  hfsplus_find_init+0x95/0x1f0
[  667.147813][ t9805]  hfsplus_readdir+0x220/0xfc0
[  667.148174][ t9805]  iterate_dir+0x296/0xb20
[  667.148549][ t9805]  __x64_sys_getdents64+0x13c/0x2c0
[  667.148937][ t9805]  do_syscall_64+0xc9/0x480
[  667.149291][ t9805]  entry_syscall_64_after_hwframe+0x77/0x7f
[  667.149809][ t9805]
[  667.150030][ t9805] the buggy address belongs to the object at ffff88802592f000
[  667.150030][ t9805]  which belongs to the cache kmalloc-2k of size 2048
[  667.151282][ t9805] the buggy address is located 0 bytes to the right of
[  667.151282][ t9805]  allocated 1036-byte region [ffff88802592f000, ffff88802592f40c)
[  667.1
---truncated---">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-38713" target="_blank">CVE-2025-38713</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-09-04 11:15:40 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">N/A</span></p>
                    <p><span class="feed-label">CVSS Score:</span> N/A</p>
                    <p>In the Linux kernel, the following vulnerability has been resolved:

hfsplus: fix slab-out-of-bounds read in hfsplus_uni2asc()

The hfsplus_readdir() method is capable to crash by calling
hfsplus_uni2asc():

[  667.121659][ T9805] ==================================================================
[  667.122651][ T9805] BUG: KASAN: slab-out-of-bounds in hfsplus_uni2asc+0x902/0xa10
[  667.123627][ T9805] Read of size 2 at addr ffff88802592f40c by task repro/9805
[  667.124578][ T9805]
[  667.124876][ T9805] CPU: 3 UID: 0 PID: 9805 Comm: repro Not tainted 6.16.0-rc3 #1 PREEMPT(full)
[  667.124886][ T9805] Hardware name: QEMU Ubuntu 24.04 PC (i440FX + PIIX, 1996), BIOS 1.16.3-debian-1.16.3-2 04/01/2014
[  667.124890][ T9805] Call Trace:
[  667.124893][ T9805]  <TASK>
[  667.124896][ T9805]  dump_stack_lvl+0x10e/0x1f0
[  667.124911][ T9805]  print_report+0xd0/0x660
[  667.124920][ T9805]  ? __virt_addr_valid+0x81/0x610
[  667.124928][ T9805]  ? __phys_addr+0xe8/0x180
[  667.124934][ T9805]  ? hfsplus_uni2asc+0x902/0xa10
[  667.124942][ T9805]  kasan_report+0xc6/0x100
[  667.124950][ T9805]  ? hfsplus_uni2asc+0x902/0xa10
[  667.124959][ T9805]  hfsplus_uni2asc+0x902/0xa10
[  667.124966][ T9805]  ? hfsplus_bnode_read+0x14b/0x360
[  667.124974][ T9805]  hfsplus_readdir+0x845/0xfc0
[  667.124984][ T9805]  ? __pfx_hfsplus_readdir+0x10/0x10
[  667.124994][ T9805]  ? stack_trace_save+0x8e/0xc0
[  667.125008][ T9805]  ? iterate_dir+0x18b/0xb20
[  667.125015][ T9805]  ? trace_lock_acquire+0x85/0xd0
[  667.125022][ T9805]  ? lock_acquire+0x30/0x80
[  667.125029][ T9805]  ? iterate_dir+0x18b/0xb20
[  667.125037][ T9805]  ? down_read_killable+0x1ed/0x4c0
[  667.125044][ T9805]  ? putname+0x154/0x1a0
[  667.125051][ T9805]  ? __pfx_down_read_killable+0x10/0x10
[  667.125058][ T9805]  ? apparmor_file_permission+0x239/0x3e0
[  667.125069][ T9805]  iterate_dir+0x296/0xb20
[  667.125076][ T9805]  __x64_sys_getdents64+0x13c/0x2c0
[  667.125084][ T9805]  ? __pfx___x64_sys_getdents64+0x10/0x10
[  667.125091][ T9805]  ? __x64_sys_openat+0x141/0x200
[  667.125126][ T9805]  ? __pfx_filldir64+0x10/0x10
[  667.125134][ T9805]  ? do_user_addr_fault+0x7fe/0x12f0
[  667.125143][ T9805]  do_syscall_64+0xc9/0x480
[  667.125151][ T9805]  entry_SYSCALL_64_after_hwframe+0x77/0x7f
[  667.125158][ T9805] RIP: 0033:0x7fa8753b2fc9
[  667.125164][ T9805] Code: 00 c3 66 2e 0f 1f 84 00 00 00 00 00 0f 1f 44 00 00 48 89 f8 48 89 f7 48 89 d6 48 89 ca 4d 89 c2 48
[  667.125172][ T9805] RSP: 002b:00007ffe96f8e0f8 EFLAGS: 00000217 ORIG_RAX: 00000000000000d9
[  667.125181][ T9805] RAX: ffffffffffffffda RBX: 0000000000000000 RCX: 00007fa8753b2fc9
[  667.125185][ T9805] RDX: 0000000000000400 RSI: 00002000000063c0 RDI: 0000000000000004
[  667.125190][ T9805] RBP: 00007ffe96f8e110 R08: 00007ffe96f8e110 R09: 00007ffe96f8e110
[  667.125195][ T9805] R10: 0000000000000000 R11: 0000000000000217 R12: 0000556b1e3b4260
[  667.125199][ T9805] R13: 0000000000000000 R14: 0000000000000000 R15: 0000000000000000
[  667.125207][ T9805]  </TASK>
[  667.125210][ T9805]
[  667.145632][ T9805] Allocated by task 9805:
[  667.145991][ T9805]  kasan_save_stack+0x20/0x40
[  667.146352][ T9805]  kasan_save_track+0x14/0x30
[  667.146717][ T9805]  __kasan_kmalloc+0xaa/0xb0
[  667.147065][ T9805]  __kmalloc_noprof+0x205/0x550
[  667.147448][ T9805]  hfsplus_find_init+0x95/0x1f0
[  667.147813][ T9805]  hfsplus_readdir+0x220/0xfc0
[  667.148174][ T9805]  iterate_dir+0x296/0xb20
[  667.148549][ T9805]  __x64_sys_getdents64+0x13c/0x2c0
[  667.148937][ T9805]  do_syscall_64+0xc9/0x480
[  667.149291][ T9805]  entry_SYSCALL_64_after_hwframe+0x77/0x7f
[  667.149809][ T9805]
[  667.150030][ T9805] The buggy address belongs to the object at ffff88802592f000
[  667.150030][ T9805]  which belongs to the cache kmalloc-2k of size 2048
[  667.151282][ T9805] The buggy address is located 0 bytes to the right of
[  667.151282][ T9805]  allocated 1036-byte region [ffff88802592f000, ffff88802592f40c)
[  667.1
---truncated---</p>
                </div>
        
            </div>
        </div>

        <footer class="footer">
            <p>© 2025 dotne1 - Cybersecurity Portfolio</p>
        </footer>

        <script>
            function searchCVEs() {
                const input = document.getElementById('searchInput').value.toLowerCase();
                const cveEntries = document.getElementsByClassName('cve-entry');
                for (let i = 0; i < cveEntries.length; i++) {
                    const cveId = cveEntries[i].getAttribute('data-cve-id').toLowerCase();
                    const description = cveEntries[i].getAttribute('data-description');
                    if (cveId.includes(input) || description.includes(input)) {
                        cveEntries[i].style.display = '';
                    } else {
                        cveEntries[i].style.display = 'none';
                    }
                }
            }
        </script>
    </body>
    </html>
    