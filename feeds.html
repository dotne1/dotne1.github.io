
    <!DOCTYPE html>
    <html lang="en">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <meta name="description" content="Security alerts and cybersecurity news feeds">
        <meta name="keywords" content="cybersecurity news, security alerts, vulnerability feeds, threat intelligence">
        <meta name="author" content="dotne1">
        <meta property="og:title" content="Security Feeds - dotne1's Cybersecurity Portfolio">
        <meta property="og:description" content="Stay updated with the latest cybersecurity news and alerts">
        <meta property="og:type" content="website">
        <title>Security Feeds - dotne1's Cybersecurity Portfolio</title>
        <link rel="stylesheet" href="styles.css">
        <link rel="icon" type="image/x-icon" href="/favicon.ico">
    </head>
    <body>
        <nav class="navbar">
            <div class="nav-links">
                <a href="index.html" class="nav-link">Home</a>
                <a href="about-me.html" class="nav-link">About Me</a>
                <a href="projects.html" class="nav-link">Projects</a>
                <a href="resume.html" class="nav-link">Resume</a>
                <a href="feeds.html" class="nav-link">Feeds</a>
            </div>
        </nav>

        <div class="container" role="main">
            <h1 class="main-header">Security Feeds</h1>
            <div class="search-bar">
                <input type="text" id="searchInput" placeholder="Search CVEs..." onkeyup="searchCVEs()">
            </div>
            <div class="feed-preview" id="cveFeed">
                <div class="feed-header">Latest Vulnerabilities</div>
    
                <div class="cve-entry" data-cve-id="CVE-2025-68734" data-description="in the linux kernel, the following vulnerability has been resolved:

isdn: misdn: hfcsusb: fix memory leak in hfcsusb_probe()

in hfcsusb_probe(), the memory allocated for ctrl_urb gets leaked when
setup_instance() fails with an error code. fix that by freeing the urb
before freeing the hw structure. also change the error paths to use the
goto ladder style.

compile tested only. issue found using a prototype static analysis tool.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-68734" target="_blank">CVE-2025-68734</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-12-24 05:16:02 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">N/A</span></p>
                    <p><span class="feed-label">CVSS Score:</span> N/A</p>
                    <p>In the Linux kernel, the following vulnerability has been resolved:

isdn: mISDN: hfcsusb: fix memory leak in hfcsusb_probe()

In hfcsusb_probe(), the memory allocated for ctrl_urb gets leaked when
setup_instance() fails with an error code. Fix that by freeing the urb
before freeing the hw structure. Also change the error paths to use the
goto ladder style.

Compile tested only. Issue found using a prototype static analysis tool.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-68733" data-description="in the linux kernel, the following vulnerability has been resolved:

smack: fix bug: unprivileged task can create labels

if an unprivileged task is allowed to relabel itself
(/smack/relabel-self is not empty),
it can freely create new labels by writing their
names into own /proc/pid/attr/smack/current

this occurs because do_setattr() imports
the provided label in advance,
before checking "relabel-self" list.

this change ensures that the "relabel-self" list
is checked before importing the label.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-68733" target="_blank">CVE-2025-68733</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-12-24 05:16:02 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">N/A</span></p>
                    <p><span class="feed-label">CVSS Score:</span> N/A</p>
                    <p>In the Linux kernel, the following vulnerability has been resolved:

smack: fix bug: unprivileged task can create labels

If an unprivileged task is allowed to relabel itself
(/smack/relabel-self is not empty),
it can freely create new labels by writing their
names into own /proc/PID/attr/smack/current

This occurs because do_setattr() imports
the provided label in advance,
before checking "relabel-self" list.

This change ensures that the "relabel-self" list
is checked before importing the label.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-68732" data-description="in the linux kernel, the following vulnerability has been resolved:

gpu: host1x: fix race in syncpt alloc/free

fix race condition between host1x_syncpt_alloc()
and host1x_syncpt_put() by using kref_put_mutex()
instead of kref_put() + manual mutex locking.

this ensures no thread can acquire the
syncpt_mutex after the refcount drops to zero
but before syncpt_release acquires it.
this prevents races where syncpoints could
be allocated while still being cleaned up
from a previous release.

remove explicit mutex locking in syncpt_release
as kref_put_mutex() handles this atomically.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-68732" target="_blank">CVE-2025-68732</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-12-24 05:16:02 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">N/A</span></p>
                    <p><span class="feed-label">CVSS Score:</span> N/A</p>
                    <p>In the Linux kernel, the following vulnerability has been resolved:

gpu: host1x: Fix race in syncpt alloc/free

Fix race condition between host1x_syncpt_alloc()
and host1x_syncpt_put() by using kref_put_mutex()
instead of kref_put() + manual mutex locking.

This ensures no thread can acquire the
syncpt_mutex after the refcount drops to zero
but before syncpt_release acquires it.
This prevents races where syncpoints could
be allocated while still being cleaned up
from a previous release.

Remove explicit mutex locking in syncpt_release
as kref_put_mutex() handles this atomically.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-68731" data-description="in the linux kernel, the following vulnerability has been resolved:

accel/amdxdna: fix an integer overflow in aie2_query_ctx_status_array()

the unpublished smatch static checker reported a warning.

drivers/accel/amdxdna/aie2_pci.c:904 aie2_query_ctx_status_array()
warn: potential user controlled sizeof overflow
'args->num_element * args->element_size' '1-u32max(user) * 1-u32max(user)'

even this will not cause a real issue, it is better to put a reasonable
limitation for element_size and num_element. add condition to make sure
the input element_size <= 4k and num_element <= 1k.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-68731" target="_blank">CVE-2025-68731</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-12-24 05:16:02 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">N/A</span></p>
                    <p><span class="feed-label">CVSS Score:</span> N/A</p>
                    <p>In the Linux kernel, the following vulnerability has been resolved:

accel/amdxdna: Fix an integer overflow in aie2_query_ctx_status_array()

The unpublished smatch static checker reported a warning.

drivers/accel/amdxdna/aie2_pci.c:904 aie2_query_ctx_status_array()
warn: potential user controlled sizeof overflow
'args->num_element * args->element_size' '1-u32max(user) * 1-u32max(user)'

Even this will not cause a real issue, it is better to put a reasonable
limitation for element_size and num_element. Add condition to make sure
the input element_size <= 4K and num_element <= 1K.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-68730" data-description="in the linux kernel, the following vulnerability has been resolved:

accel/ivpu: fix page fault in ivpu_bo_unbind_all_bos_from_context()

don't add bo to the vdev->bo_list in ivpu_gem_create_object().
when failure happens inside drm_gem_shmem_create(), the bo is not
fully created and ivpu_gem_bo_free() callback will not be called
causing a deleted bo to be left on the list.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-68730" target="_blank">CVE-2025-68730</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-12-24 05:16:02 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">N/A</span></p>
                    <p><span class="feed-label">CVSS Score:</span> N/A</p>
                    <p>In the Linux kernel, the following vulnerability has been resolved:

accel/ivpu: Fix page fault in ivpu_bo_unbind_all_bos_from_context()

Don't add BO to the vdev->bo_list in ivpu_gem_create_object().
When failure happens inside drm_gem_shmem_create(), the BO is not
fully created and ivpu_gem_bo_free() callback will not be called
causing a deleted BO to be left on the list.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-68729" data-description="in the linux kernel, the following vulnerability has been resolved:

wifi: ath12k: fix msdu buffer types handling in rx error path

currently, packets received on the reo exception ring from
unassociated peers are of msdu buffer type, while the driver expects
link descriptor type packets. these packets are not parsed further due
to a return check on packet type in ath12k_hal_desc_reo_parse_err(),
but the associated skb is not freed. this may lead to kernel
crashes and buffer leaks.

hence to fix, update the rx error handler to explicitly drop
msdu buffer type packets received on the reo exception ring.
this prevents further processing of invalid packets and ensures
stability in the rx error handling path.

tested-on: qcn9274 hw2.0 pci wlan.wbe.1.4.1-00199-qcahkswpl_siliconz-1">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-68729" target="_blank">CVE-2025-68729</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-12-24 05:16:02 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">N/A</span></p>
                    <p><span class="feed-label">CVSS Score:</span> N/A</p>
                    <p>In the Linux kernel, the following vulnerability has been resolved:

wifi: ath12k: Fix MSDU buffer types handling in RX error path

Currently, packets received on the REO exception ring from
unassociated peers are of MSDU buffer type, while the driver expects
link descriptor type packets. These packets are not parsed further due
to a return check on packet type in ath12k_hal_desc_reo_parse_err(),
but the associated skb is not freed. This may lead to kernel
crashes and buffer leaks.

Hence to fix, update the RX error handler to explicitly drop
MSDU buffer type packets received on the REO exception ring.
This prevents further processing of invalid packets and ensures
stability in the RX error handling path.

Tested-on: QCN9274 hw2.0 PCI WLAN.WBE.1.4.1-00199-QCAHKSWPL_SILICONZ-1</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-68728" data-description="in the linux kernel, the following vulnerability has been resolved:

ntfs3: fix uninit memory after failed mi_read in mi_format_new

fix a kmsan un-init bug found by syzkaller.

ntfs_get_bh() expects a buffer from sb_getblk(), that buffer may not be
uptodate. we do not bring the buffer uptodate before setting it as
uptodate. if the buffer were to not be uptodate, it could mean adding a
buffer with un-init data to the mi record. attempting to load that record
will trigger kmsan.

avoid this by setting the buffer as uptodate, if it’s not already, by
overwriting it.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-68728" target="_blank">CVE-2025-68728</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-12-24 05:16:02 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">N/A</span></p>
                    <p><span class="feed-label">CVSS Score:</span> N/A</p>
                    <p>In the Linux kernel, the following vulnerability has been resolved:

ntfs3: fix uninit memory after failed mi_read in mi_format_new

Fix a KMSAN un-init bug found by syzkaller.

ntfs_get_bh() expects a buffer from sb_getblk(), that buffer may not be
uptodate. We do not bring the buffer uptodate before setting it as
uptodate. If the buffer were to not be uptodate, it could mean adding a
buffer with un-init data to the mi record. Attempting to load that record
will trigger KMSAN.

Avoid this by setting the buffer as uptodate, if it’s not already, by
overwriting it.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-68727" data-description="in the linux kernel, the following vulnerability has been resolved:

ntfs3: fix uninit buffer allocated by __getname()

fix uninit errors caused after buffer allocation given to 'de'; by
initializing the buffer with zeroes. the fix was found by using kmsan.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-68727" target="_blank">CVE-2025-68727</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-12-24 05:16:02 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">N/A</span></p>
                    <p><span class="feed-label">CVSS Score:</span> N/A</p>
                    <p>In the Linux kernel, the following vulnerability has been resolved:

ntfs3: Fix uninit buffer allocated by __getname()

Fix uninit errors caused after buffer allocation given to 'de'; by
initializing the buffer with zeroes. The fix was found by using KMSAN.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-68726" data-description="in the linux kernel, the following vulnerability has been resolved:

crypto: aead - fix reqsize handling

commit afddce13ce81d ("crypto: api - add reqsize to crypto_alg")
introduced cra_reqsize field in crypto_alg struct to replace type
specific reqsize fields. it looks like this was introduced specifically
for ahash and acomp from the commit description as subsequent commits
add necessary changes in these alg frameworks.

however, this is being recommended for use in all crypto algs
instead of setting reqsize using crypto_*_set_reqsize(). using
cra_reqsize in aead algorithms, hence, causes memory corruptions and
crashes as the underlying functions in the algorithm framework have not
been updated to set the reqsize properly from cra_reqsize. [1]

add proper set_reqsize calls in the aead init function to properly
initialize reqsize for these algorithms in the framework.

[1]: https://gist.github.com/pratham-t/24247446f1faf4b7843e4014d5089f6b">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-68726" target="_blank">CVE-2025-68726</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-12-24 05:16:01 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">N/A</span></p>
                    <p><span class="feed-label">CVSS Score:</span> N/A</p>
                    <p>In the Linux kernel, the following vulnerability has been resolved:

crypto: aead - Fix reqsize handling

Commit afddce13ce81d ("crypto: api - Add reqsize to crypto_alg")
introduced cra_reqsize field in crypto_alg struct to replace type
specific reqsize fields. It looks like this was introduced specifically
for ahash and acomp from the commit description as subsequent commits
add necessary changes in these alg frameworks.

However, this is being recommended for use in all crypto algs
instead of setting reqsize using crypto_*_set_reqsize(). Using
cra_reqsize in aead algorithms, hence, causes memory corruptions and
crashes as the underlying functions in the algorithm framework have not
been updated to set the reqsize properly from cra_reqsize. [1]

Add proper set_reqsize calls in the aead init function to properly
initialize reqsize for these algorithms in the framework.

[1]: https://gist.github.com/Pratham-T/24247446f1faf4b7843e4014d5089f6b</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-68725" data-description="in the linux kernel, the following vulnerability has been resolved:

bpf: do not let bpf test infra emit invalid gso types to stack

yinhao et al. reported that their fuzzer tool was able to trigger a
skb_warn_bad_offload() from netif_skb_features() -> gso_features_check().
when a bpf program - triggered via bpf test infra - pushes the packet
to the loopback device via bpf_clone_redirect() then mentioned offload
warning can be seen. gso-related features are then rightfully disabled.

we get into this situation due to convert___skb_to_skb() setting
gso_segs and gso_size but not gso_type. technically, it makes sense
that this warning triggers since the gso properties are malformed due
to the gso_type. potentially, the gso_type could be marked non-trustworthy
through setting it at least to skb_gso_dodgy without any other specific
assumptions, but that also feels wrong given we should not go further
into the gso engine in the first place.

the checks were added in 121d57af308d ("gso: validate gso_type in gso
handlers") because there were malicious (syzbot) senders that combine
a protocol with a non-matching gso_type. if we would want to drop such
packets, gso_features_check() currently only returns feature flags via
netif_skb_features(), so one location for potentially dropping such skbs
could be validate_xmit_unreadable_skb(), but then otoh it would be
an additional check in the fast-path for a very corner case. given
bpf_clone_redirect() is the only place where bpf test infra could emit
such packets, lets reject them right there.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-68725" target="_blank">CVE-2025-68725</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-12-24 05:16:01 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">N/A</span></p>
                    <p><span class="feed-label">CVSS Score:</span> N/A</p>
                    <p>In the Linux kernel, the following vulnerability has been resolved:

bpf: Do not let BPF test infra emit invalid GSO types to stack

Yinhao et al. reported that their fuzzer tool was able to trigger a
skb_warn_bad_offload() from netif_skb_features() -> gso_features_check().
When a BPF program - triggered via BPF test infra - pushes the packet
to the loopback device via bpf_clone_redirect() then mentioned offload
warning can be seen. GSO-related features are then rightfully disabled.

We get into this situation due to convert___skb_to_skb() setting
gso_segs and gso_size but not gso_type. Technically, it makes sense
that this warning triggers since the GSO properties are malformed due
to the gso_type. Potentially, the gso_type could be marked non-trustworthy
through setting it at least to SKB_GSO_DODGY without any other specific
assumptions, but that also feels wrong given we should not go further
into the GSO engine in the first place.

The checks were added in 121d57af308d ("gso: validate gso_type in GSO
handlers") because there were malicious (syzbot) senders that combine
a protocol with a non-matching gso_type. If we would want to drop such
packets, gso_features_check() currently only returns feature flags via
netif_skb_features(), so one location for potentially dropping such skbs
could be validate_xmit_unreadable_skb(), but then otoh it would be
an additional check in the fast-path for a very corner case. Given
bpf_clone_redirect() is the only place where BPF test infra could emit
such packets, lets reject them right there.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-68724" data-description="in the linux kernel, the following vulnerability has been resolved:

crypto: asymmetric_keys - prevent overflow in asymmetric_key_generate_id

use check_add_overflow() to guard against potential integer overflows
when adding the binary blob lengths and the size of an asymmetric_key_id
structure and return err_ptr(-eoverflow) accordingly. this prevents a
possible buffer overflow when copying data from potentially malicious
x.509 certificate fields that can be arbitrarily large, such as asn.1
integer serial numbers, issuer names, etc.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-68724" target="_blank">CVE-2025-68724</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-12-24 05:16:01 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">N/A</span></p>
                    <p><span class="feed-label">CVSS Score:</span> N/A</p>
                    <p>In the Linux kernel, the following vulnerability has been resolved:

crypto: asymmetric_keys - prevent overflow in asymmetric_key_generate_id

Use check_add_overflow() to guard against potential integer overflows
when adding the binary blob lengths and the size of an asymmetric_key_id
structure and return ERR_PTR(-EOVERFLOW) accordingly. This prevents a
possible buffer overflow when copying data from potentially malicious
X.509 certificate fields that can be arbitrarily large, such as ASN.1
INTEGER serial numbers, issuer names, etc.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-68380" data-description="in the linux kernel, the following vulnerability has been resolved:

wifi: ath11k: fix peer he mcs assignment

in ath11k_wmi_send_peer_assoc_cmd(), peer's transmit mcs is sent to
firmware as receive mcs while peer's receive mcs sent as transmit mcs,
which goes against firmwire's definition.

while connecting to a misbehaved ap that advertises 0xffff (meaning not
supported) for 160 mhz transmit mcs map, firmware crashes due to 0xffff
is assigned to he_mcs->rx_mcs_set field.

	ext tag: he capabilities
	    [...]
	    supported he-mcs and nss set
		[...]
	        rx and tx mcs maps 160 mhz
		    [...]
	            tx he-mcs map 160 mhz: 0xffff

swap the assignment to fix this issue.

as the he rate control mask is meant to limit our own transmit mcs, it
needs to go via he_mcs->rx_mcs_set field. with the aforementioned swapping
done, change is needed as well to apply it to the peer's receive mcs.

tested-on: wcn6855 hw2.1 pci wlan.hsp.1.1-03125-qcahspswpl_v1_v2_siliconz_lite-3.6510.41
tested-on: qcn9274 hw2.0 pci wlan.wbe.1.4.1-00199-qcahkswpl_siliconz-1">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-68380" target="_blank">CVE-2025-68380</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-12-24 05:16:01 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">N/A</span></p>
                    <p><span class="feed-label">CVSS Score:</span> N/A</p>
                    <p>In the Linux kernel, the following vulnerability has been resolved:

wifi: ath11k: fix peer HE MCS assignment

In ath11k_wmi_send_peer_assoc_cmd(), peer's transmit MCS is sent to
firmware as receive MCS while peer's receive MCS sent as transmit MCS,
which goes against firmwire's definition.

While connecting to a misbehaved AP that advertises 0xffff (meaning not
supported) for 160 MHz transmit MCS map, firmware crashes due to 0xffff
is assigned to he_mcs->rx_mcs_set field.

	Ext Tag: HE Capabilities
	    [...]
	    Supported HE-MCS and NSS Set
		[...]
	        Rx and Tx MCS Maps 160 MHz
		    [...]
	            Tx HE-MCS Map 160 MHz: 0xffff

Swap the assignment to fix this issue.

As the HE rate control mask is meant to limit our own transmit MCS, it
needs to go via he_mcs->rx_mcs_set field. With the aforementioned swapping
done, change is needed as well to apply it to the peer's receive MCS.

Tested-on: WCN6855 hw2.1 PCI WLAN.HSP.1.1-03125-QCAHSPSWPL_V1_V2_SILICONZ_LITE-3.6510.41
Tested-on: QCN9274 hw2.0 PCI WLAN.WBE.1.4.1-00199-QCAHKSWPL_SILICONZ-1</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-68379" data-description="in the linux kernel, the following vulnerability has been resolved:

rdma/rxe: fix null deref on srq->rq.queue after resize failure

a null pointer dereference can occur in rxe_srq_chk_attr() when
ibv_modify_srq() is invoked twice in succession under certain error
conditions. the first call may fail in rxe_queue_resize(), which leads
rxe_srq_from_attr() to set srq->rq.queue = null. the second call then
triggers a crash (null deref) when accessing
srq->rq.queue->buf->index_mask.

call trace:
<task>
rxe_modify_srq+0x170/0x480 [rdma_rxe]
? __pfx_rxe_modify_srq+0x10/0x10 [rdma_rxe]
? uverbs_try_lock_object+0x4f/0xa0 [ib_uverbs]
? rdma_lookup_get_uobject+0x1f0/0x380 [ib_uverbs]
ib_uverbs_modify_srq+0x204/0x290 [ib_uverbs]
? __pfx_ib_uverbs_modify_srq+0x10/0x10 [ib_uverbs]
? tryinc_node_nr_active+0xe6/0x150
? uverbs_fill_udata+0xed/0x4f0 [ib_uverbs]
ib_uverbs_handler_uverbs_method_invoke_write+0x2c0/0x470 [ib_uverbs]
? __pfx_ib_uverbs_handler_uverbs_method_invoke_write+0x10/0x10 [ib_uverbs]
? uverbs_fill_udata+0xed/0x4f0 [ib_uverbs]
ib_uverbs_run_method+0x55a/0x6e0 [ib_uverbs]
? __pfx_ib_uverbs_handler_uverbs_method_invoke_write+0x10/0x10 [ib_uverbs]
ib_uverbs_cmd_verbs+0x54d/0x800 [ib_uverbs]
? __pfx_ib_uverbs_cmd_verbs+0x10/0x10 [ib_uverbs]
? __pfx___raw_spin_lock_irqsave+0x10/0x10
? __pfx_do_vfs_ioctl+0x10/0x10
? ioctl_has_perm.constprop.0.isra.0+0x2c7/0x4c0
? __pfx_ioctl_has_perm.constprop.0.isra.0+0x10/0x10
ib_uverbs_ioctl+0x13e/0x220 [ib_uverbs]
? __pfx_ib_uverbs_ioctl+0x10/0x10 [ib_uverbs]
__x64_sys_ioctl+0x138/0x1c0
do_syscall_64+0x82/0x250
? fdget_pos+0x58/0x4c0
? ksys_write+0xf3/0x1c0
? __pfx_ksys_write+0x10/0x10
? do_syscall_64+0xc8/0x250
? __pfx_vm_mmap_pgoff+0x10/0x10
? fget+0x173/0x230
? fput+0x2a/0x80
? ksys_mmap_pgoff+0x224/0x4c0
? do_syscall_64+0xc8/0x250
? do_user_addr_fault+0x37b/0xfe0
? clear_bhb_loop+0x50/0xa0
? clear_bhb_loop+0x50/0xa0
? clear_bhb_loop+0x50/0xa0
entry_syscall_64_after_hwframe+0x76/0x7e">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-68379" target="_blank">CVE-2025-68379</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-12-24 05:16:01 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">N/A</span></p>
                    <p><span class="feed-label">CVSS Score:</span> N/A</p>
                    <p>In the Linux kernel, the following vulnerability has been resolved:

RDMA/rxe: Fix null deref on srq->rq.queue after resize failure

A NULL pointer dereference can occur in rxe_srq_chk_attr() when
ibv_modify_srq() is invoked twice in succession under certain error
conditions. The first call may fail in rxe_queue_resize(), which leads
rxe_srq_from_attr() to set srq->rq.queue = NULL. The second call then
triggers a crash (null deref) when accessing
srq->rq.queue->buf->index_mask.

Call Trace:
<TASK>
rxe_modify_srq+0x170/0x480 [rdma_rxe]
? __pfx_rxe_modify_srq+0x10/0x10 [rdma_rxe]
? uverbs_try_lock_object+0x4f/0xa0 [ib_uverbs]
? rdma_lookup_get_uobject+0x1f0/0x380 [ib_uverbs]
ib_uverbs_modify_srq+0x204/0x290 [ib_uverbs]
? __pfx_ib_uverbs_modify_srq+0x10/0x10 [ib_uverbs]
? tryinc_node_nr_active+0xe6/0x150
? uverbs_fill_udata+0xed/0x4f0 [ib_uverbs]
ib_uverbs_handler_UVERBS_METHOD_INVOKE_WRITE+0x2c0/0x470 [ib_uverbs]
? __pfx_ib_uverbs_handler_UVERBS_METHOD_INVOKE_WRITE+0x10/0x10 [ib_uverbs]
? uverbs_fill_udata+0xed/0x4f0 [ib_uverbs]
ib_uverbs_run_method+0x55a/0x6e0 [ib_uverbs]
? __pfx_ib_uverbs_handler_UVERBS_METHOD_INVOKE_WRITE+0x10/0x10 [ib_uverbs]
ib_uverbs_cmd_verbs+0x54d/0x800 [ib_uverbs]
? __pfx_ib_uverbs_cmd_verbs+0x10/0x10 [ib_uverbs]
? __pfx___raw_spin_lock_irqsave+0x10/0x10
? __pfx_do_vfs_ioctl+0x10/0x10
? ioctl_has_perm.constprop.0.isra.0+0x2c7/0x4c0
? __pfx_ioctl_has_perm.constprop.0.isra.0+0x10/0x10
ib_uverbs_ioctl+0x13e/0x220 [ib_uverbs]
? __pfx_ib_uverbs_ioctl+0x10/0x10 [ib_uverbs]
__x64_sys_ioctl+0x138/0x1c0
do_syscall_64+0x82/0x250
? fdget_pos+0x58/0x4c0
? ksys_write+0xf3/0x1c0
? __pfx_ksys_write+0x10/0x10
? do_syscall_64+0xc8/0x250
? __pfx_vm_mmap_pgoff+0x10/0x10
? fget+0x173/0x230
? fput+0x2a/0x80
? ksys_mmap_pgoff+0x224/0x4c0
? do_syscall_64+0xc8/0x250
? do_user_addr_fault+0x37b/0xfe0
? clear_bhb_loop+0x50/0xa0
? clear_bhb_loop+0x50/0xa0
? clear_bhb_loop+0x50/0xa0
entry_SYSCALL_64_after_hwframe+0x76/0x7e</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-68378" data-description="in the linux kernel, the following vulnerability has been resolved:

bpf: fix stackmap overflow check in __bpf_get_stackid()

syzkaller reported a kasan slab-out-of-bounds write in __bpf_get_stackid()
when copying stack trace data. the issue occurs when the perf trace
 contains more stack entries than the stack map bucket can hold,
 leading to an out-of-bounds write in the bucket's data array.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-68378" target="_blank">CVE-2025-68378</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-12-24 05:16:01 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">N/A</span></p>
                    <p><span class="feed-label">CVSS Score:</span> N/A</p>
                    <p>In the Linux kernel, the following vulnerability has been resolved:

bpf: Fix stackmap overflow check in __bpf_get_stackid()

Syzkaller reported a KASAN slab-out-of-bounds write in __bpf_get_stackid()
when copying stack trace data. The issue occurs when the perf trace
 contains more stack entries than the stack map bucket can hold,
 leading to an out-of-bounds write in the bucket's data array.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-68377" data-description="in the linux kernel, the following vulnerability has been resolved:

ns: initialize ns_list_node for initial namespaces

make sure that the list is always initialized for initial namespaces.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-68377" target="_blank">CVE-2025-68377</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-12-24 05:16:01 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">N/A</span></p>
                    <p><span class="feed-label">CVSS Score:</span> N/A</p>
                    <p>In the Linux kernel, the following vulnerability has been resolved:

ns: initialize ns_list_node for initial namespaces

Make sure that the list is always initialized for initial namespaces.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-68376" data-description="in the linux kernel, the following vulnerability has been resolved:

coresight: etr: fix etr buffer use-after-free issue

when etr is enabled as cs_mode_sysfs, if the buffer size is changed
and enabled again, currently sysfs_buf will point to the newly
allocated memory(buf_new) and free the old memory(buf_old). but the
etr_buf that is being used by the etr remains pointed to buf_old, not
updated to buf_new. in this case, it will result in a memory
use-after-free issue.

fix this by checking etr's mode before updating and releasing buf_old,
if the mode is cs_mode_sysfs, then skip updating and releasing it.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-68376" target="_blank">CVE-2025-68376</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-12-24 05:16:01 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">N/A</span></p>
                    <p><span class="feed-label">CVSS Score:</span> N/A</p>
                    <p>In the Linux kernel, the following vulnerability has been resolved:

coresight: ETR: Fix ETR buffer use-after-free issue

When ETR is enabled as CS_MODE_SYSFS, if the buffer size is changed
and enabled again, currently sysfs_buf will point to the newly
allocated memory(buf_new) and free the old memory(buf_old). But the
etr_buf that is being used by the ETR remains pointed to buf_old, not
updated to buf_new. In this case, it will result in a memory
use-after-free issue.

Fix this by checking ETR's mode before updating and releasing buf_old,
if the mode is CS_MODE_SYSFS, then skip updating and releasing it.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-68375" data-description="in the linux kernel, the following vulnerability has been resolved:

perf/x86: fix null event access and potential pebs record loss

when intel_pmu_drain_pebs_icl() is called to drain pebs records, the
perf_event_overflow() could be called to process the last pebs record.

while perf_event_overflow() could trigger the interrupt throttle and
stop all events of the group, like what the below call-chain shows.

perf_event_overflow()
  -> __perf_event_overflow()
    ->__perf_event_account_interrupt()
      -> perf_event_throttle_group()
        -> perf_event_throttle()
          -> event->pmu->stop()
            -> x86_pmu_stop()

the side effect of stopping the events is that all corresponding event
pointers in cpuc->events[] array are cleared to null.

assume there are two pebs events (event a and event b) in a group. when
intel_pmu_drain_pebs_icl() calls perf_event_overflow() to process the
last pebs record of pebs event a, interrupt throttle is triggered and
all pointers of event a and event b are cleared to null. then
intel_pmu_drain_pebs_icl() tries to process the last pebs record of
event b and encounters null pointer access.

to avoid this issue, move cpuc->events[] clearing from x86_pmu_stop()
to x86_pmu_del(). it's safe since cpuc->active_mask or
cpuc->pebs_enabled is always checked before access the event pointer
from cpuc->events[].">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-68375" target="_blank">CVE-2025-68375</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-12-24 05:16:01 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">N/A</span></p>
                    <p><span class="feed-label">CVSS Score:</span> N/A</p>
                    <p>In the Linux kernel, the following vulnerability has been resolved:

perf/x86: Fix NULL event access and potential PEBS record loss

When intel_pmu_drain_pebs_icl() is called to drain PEBS records, the
perf_event_overflow() could be called to process the last PEBS record.

While perf_event_overflow() could trigger the interrupt throttle and
stop all events of the group, like what the below call-chain shows.

perf_event_overflow()
  -> __perf_event_overflow()
    ->__perf_event_account_interrupt()
      -> perf_event_throttle_group()
        -> perf_event_throttle()
          -> event->pmu->stop()
            -> x86_pmu_stop()

The side effect of stopping the events is that all corresponding event
pointers in cpuc->events[] array are cleared to NULL.

Assume there are two PEBS events (event a and event b) in a group. When
intel_pmu_drain_pebs_icl() calls perf_event_overflow() to process the
last PEBS record of PEBS event a, interrupt throttle is triggered and
all pointers of event a and event b are cleared to NULL. Then
intel_pmu_drain_pebs_icl() tries to process the last PEBS record of
event b and encounters NULL pointer access.

To avoid this issue, move cpuc->events[] clearing from x86_pmu_stop()
to x86_pmu_del(). It's safe since cpuc->active_mask or
cpuc->pebs_enabled is always checked before access the event pointer
from cpuc->events[].</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-68374" data-description="in the linux kernel, the following vulnerability has been resolved:

md: fix rcu protection in md_wakeup_thread

we attempted to use rcu to protect the pointer 'thread', but directly
passed the value when calling md_wakeup_thread(). this means that the
rcu pointer has been acquired before rcu_read_lock(), which renders
rcu_read_lock() ineffective and could lead to a use-after-free.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-68374" target="_blank">CVE-2025-68374</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-12-24 05:16:00 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">N/A</span></p>
                    <p><span class="feed-label">CVSS Score:</span> N/A</p>
                    <p>In the Linux kernel, the following vulnerability has been resolved:

md: fix rcu protection in md_wakeup_thread

We attempted to use RCU to protect the pointer 'thread', but directly
passed the value when calling md_wakeup_thread(). This means that the
RCU pointer has been acquired before rcu_read_lock(), which renders
rcu_read_lock() ineffective and could lead to a use-after-free.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-68373" data-description="in the linux kernel, the following vulnerability has been resolved:

md: avoid repeated calls to del_gendisk

there is a uaf problem which is found by case 23rdev-lifetime:

oops: general protection fault, probably for non-canonical address 0xdead000000000122
rip: 0010:bdi_unregister+0x4b/0x170
call trace:
 <task>
 __del_gendisk+0x356/0x3e0
 mddev_unlock+0x351/0x360
 rdev_attr_store+0x217/0x280
 kernfs_fop_write_iter+0x14a/0x210
 vfs_write+0x29e/0x550
 ksys_write+0x74/0xf0
 do_syscall_64+0xbb/0x380
 entry_syscall_64_after_hwframe+0x77/0x7f
rip: 0033:0x7ff5250a177e

the sequence is:
1. rdev remove path gets reconfig_mutex
2. rdev remove path release reconfig_mutex in mddev_unlock
3. md stop calls do_md_stop and sets md_deleted
4. rdev remove path calls del_gendisk because md_deleted is set
5. md stop path release reconfig_mutex and calls del_gendisk again

so there is a race condition we should resolve. this patch adds a
flag md_do_delete to avoid the race condition.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-68373" target="_blank">CVE-2025-68373</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-12-24 05:16:00 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">N/A</span></p>
                    <p><span class="feed-label">CVSS Score:</span> N/A</p>
                    <p>In the Linux kernel, the following vulnerability has been resolved:

md: avoid repeated calls to del_gendisk

There is a uaf problem which is found by case 23rdev-lifetime:

Oops: general protection fault, probably for non-canonical address 0xdead000000000122
RIP: 0010:bdi_unregister+0x4b/0x170
Call Trace:
 <TASK>
 __del_gendisk+0x356/0x3e0
 mddev_unlock+0x351/0x360
 rdev_attr_store+0x217/0x280
 kernfs_fop_write_iter+0x14a/0x210
 vfs_write+0x29e/0x550
 ksys_write+0x74/0xf0
 do_syscall_64+0xbb/0x380
 entry_SYSCALL_64_after_hwframe+0x77/0x7f
RIP: 0033:0x7ff5250a177e

The sequence is:
1. rdev remove path gets reconfig_mutex
2. rdev remove path release reconfig_mutex in mddev_unlock
3. md stop calls do_md_stop and sets MD_DELETED
4. rdev remove path calls del_gendisk because MD_DELETED is set
5. md stop path release reconfig_mutex and calls del_gendisk again

So there is a race condition we should resolve. This patch adds a
flag MD_DO_DELETE to avoid the race condition.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-68372" data-description="in the linux kernel, the following vulnerability has been resolved:

nbd: defer config put in recv_work

there is one uaf issue in recv_work when running nbd_clear_sock and
nbd_cmd_reconfigure:
  nbd_genl_connect     // conf_ref=2 (connect and recv_work a)
  nbd_open	       // conf_ref=3
  recv_work a done     // conf_ref=2
  nbd_clear_sock       // conf_ref=1
  nbd_genl_reconfigure // conf_ref=2 (trigger recv_work b)
  close nbd	       // conf_ref=1
  recv_work b
    config_put         // conf_ref=0
    atomic_dec(&config->recv_threads); -> uaf

or only running nbd_clear_sock:
  nbd_genl_connect   // conf_ref=2
  nbd_open 	     // conf_ref=3
  nbd_clear_sock     // conf_ref=2
  close nbd
    nbd_release
      config_put     // conf_ref=1
  recv_work
    config_put 	     // conf_ref=0
    atomic_dec(&config->recv_threads); -> uaf

commit 87aac3a80af5 ("nbd: call nbd_config_put() before notifying the
waiter") moved nbd_config_put() to run before waking up the waiter in
recv_work, in order to ensure that nbd_start_device_ioctl() would not
be woken up while nbd->task_recv was still uncleared.

however, in nbd_start_device_ioctl(), after being woken up it explicitly
calls flush_workqueue() to make sure all current works are finished.
therefore, there is no need to move the config put ahead of the wakeup.

move nbd_config_put() to the end of recv_work, so that the reference is
held for the whole lifetime of the worker thread. this makes sure the
config cannot be freed while recv_work is still running, even if clear
+ reconfigure interleave.

in addition, we don't need to worry about recv_work dropping the last
nbd_put (which causes deadlock):

path a (netlink with nbd_cflag_destroy_on_disconnect):
  connect  // nbd_refs=1 (trigger recv_work)
  open nbd // nbd_refs=2
  nbd_clear_sock
  close nbd
    nbd_release
      nbd_disconnect_and_put
        flush_workqueue // recv_work done
      nbd_config_put
        nbd_put // nbd_refs=1
      nbd_put // nbd_refs=0
        queue_work

path b (netlink without nbd_cflag_destroy_on_disconnect):
  connect  // nbd_refs=2 (trigger recv_work)
  open nbd // nbd_refs=3
  nbd_clear_sock // conf_refs=2
  close nbd
    nbd_release
      nbd_config_put // conf_refs=1
      nbd_put // nbd_refs=2
  recv_work done // conf_refs=0, nbd_refs=1
  rmmod // nbd_refs=0

depends-on: e2daec488c57 ("nbd: fix hungtask when nbd_config_put")">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-68372" target="_blank">CVE-2025-68372</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-12-24 05:16:00 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">N/A</span></p>
                    <p><span class="feed-label">CVSS Score:</span> N/A</p>
                    <p>In the Linux kernel, the following vulnerability has been resolved:

nbd: defer config put in recv_work

There is one uaf issue in recv_work when running NBD_CLEAR_SOCK and
NBD_CMD_RECONFIGURE:
  nbd_genl_connect     // conf_ref=2 (connect and recv_work A)
  nbd_open	       // conf_ref=3
  recv_work A done     // conf_ref=2
  NBD_CLEAR_SOCK       // conf_ref=1
  nbd_genl_reconfigure // conf_ref=2 (trigger recv_work B)
  close nbd	       // conf_ref=1
  recv_work B
    config_put         // conf_ref=0
    atomic_dec(&config->recv_threads); -> UAF

Or only running NBD_CLEAR_SOCK:
  nbd_genl_connect   // conf_ref=2
  nbd_open 	     // conf_ref=3
  NBD_CLEAR_SOCK     // conf_ref=2
  close nbd
    nbd_release
      config_put     // conf_ref=1
  recv_work
    config_put 	     // conf_ref=0
    atomic_dec(&config->recv_threads); -> UAF

Commit 87aac3a80af5 ("nbd: call nbd_config_put() before notifying the
waiter") moved nbd_config_put() to run before waking up the waiter in
recv_work, in order to ensure that nbd_start_device_ioctl() would not
be woken up while nbd->task_recv was still uncleared.

However, in nbd_start_device_ioctl(), after being woken up it explicitly
calls flush_workqueue() to make sure all current works are finished.
Therefore, there is no need to move the config put ahead of the wakeup.

Move nbd_config_put() to the end of recv_work, so that the reference is
held for the whole lifetime of the worker thread. This makes sure the
config cannot be freed while recv_work is still running, even if clear
+ reconfigure interleave.

In addition, we don't need to worry about recv_work dropping the last
nbd_put (which causes deadlock):

path A (netlink with NBD_CFLAG_DESTROY_ON_DISCONNECT):
  connect  // nbd_refs=1 (trigger recv_work)
  open nbd // nbd_refs=2
  NBD_CLEAR_SOCK
  close nbd
    nbd_release
      nbd_disconnect_and_put
        flush_workqueue // recv_work done
      nbd_config_put
        nbd_put // nbd_refs=1
      nbd_put // nbd_refs=0
        queue_work

path B (netlink without NBD_CFLAG_DESTROY_ON_DISCONNECT):
  connect  // nbd_refs=2 (trigger recv_work)
  open nbd // nbd_refs=3
  NBD_CLEAR_SOCK // conf_refs=2
  close nbd
    nbd_release
      nbd_config_put // conf_refs=1
      nbd_put // nbd_refs=2
  recv_work done // conf_refs=0, nbd_refs=1
  rmmod // nbd_refs=0

Depends-on: e2daec488c57 ("nbd: Fix hungtask when nbd_config_put")</p>
                </div>
        
            </div>
        </div>

        <footer class="footer">
            <p>© 2025 dotne1 - Cybersecurity Portfolio</p>
        </footer>

        <script>
            function searchCVEs() {
                const input = document.getElementById('searchInput').value.toLowerCase();
                const cveEntries = document.getElementsByClassName('cve-entry');
                for (let i = 0; i < cveEntries.length; i++) {
                    const cveId = cveEntries[i].getAttribute('data-cve-id').toLowerCase();
                    const description = cveEntries[i].getAttribute('data-description');
                    if (cveId.includes(input) || description.includes(input)) {
                        cveEntries[i].style.display = '';
                    } else {
                        cveEntries[i].style.display = 'none';
                    }
                }
            }
        </script>
    </body>
    </html>
    