
    <!DOCTYPE html>
    <html lang="en">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <meta name="description" content="Security alerts and cybersecurity news feeds">
        <meta name="keywords" content="cybersecurity news, security alerts, vulnerability feeds, threat intelligence">
        <meta name="author" content="dotne1">
        <meta property="og:title" content="Security Feeds - dotne1's Cybersecurity Portfolio">
        <meta property="og:description" content="Stay updated with the latest cybersecurity news and alerts">
        <meta property="og:type" content="website">
        <title>Security Feeds - dotne1's Cybersecurity Portfolio</title>
        <link rel="stylesheet" href="styles.css">
        <link rel="icon" type="image/x-icon" href="/favicon.ico">
    </head>
    <body>
        <nav class="navbar">
            <div class="nav-links">
                <a href="index.html" class="nav-link">Home</a>
                <a href="about-me.html" class="nav-link">About Me</a>
                <a href="projects.html" class="nav-link">Projects</a>
                <a href="resume.html" class="nav-link">Resume</a>
                <a href="feeds.html" class="nav-link">Feeds</a>
            </div>
        </nav>

        <div class="container" role="main">
            <h1 class="main-header">Security Feeds</h1>
            <div class="search-bar">
                <input type="text" id="searchInput" placeholder="Search CVEs..." onkeyup="searchCVEs()">
            </div>
            <div class="feed-preview" id="cveFeed">
                <div class="feed-header">Latest Vulnerabilities</div>
    
                <div class="cve-entry" data-cve-id="CVE-2025-48952" data-description="netalertx is a network, presence scanner, and alert framework. prior to version 25.6.7, a vulnerability in the authentication logic allows users to bypass password verification using sha-256 magic hashes, due to loose comparison in php. in vulnerable versions of the application, a password comparison is performed using the `==` operator at line 40 in front/index.php. this introduces a security issue where specially crafted "magic hash" values that evaluate to true in a loose comparison can bypass authentication. because of the use of `==` instead of the strict `===`, different strings that begin with 0e and are followed by only digits can be interpreted as scientific notation (i.e., zero) and treated as equal. this issue falls under the login bypass vulnerability class. users with certain "weird" passwords that produce magic hashes are particularly affected. services relying on this logic are at risk of unauthorized access. version 25.6.7 fixes the vulnerability.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-48952" target="_blank">CVE-2025-48952</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-07-04 18:15:21 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-online">CRITICAL</span></p>
                    <p><span class="feed-label">CVSS Score:</span> 9.4</p>
                    <p>NetAlertX is a network, presence scanner, and alert framework. Prior to version 25.6.7, a vulnerability in the authentication logic allows users to bypass password verification using SHA-256 magic hashes, due to loose comparison in PHP. In vulnerable versions of the application, a password comparison is performed using the `==` operator at line 40 in front/index.php. This introduces a security issue where specially crafted "magic hash" values that evaluate to true in a loose comparison can bypass authentication. Because of the use of `==` instead of the strict `===`, different strings that begin with 0e and are followed by only digits can be interpreted as scientific notation (i.e., zero) and treated as equal. This issue falls under the Login Bypass vulnerability class. Users with certain "weird" passwords that produce magic hashes are particularly affected. Services relying on this logic are at risk of unauthorized access. Version 25.6.7 fixes the vulnerability.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-7070" data-description="a vulnerability has been found in iroad dashcam q9 up to 20250624 and classified as problematic. affected by this vulnerability is an unknown functionality of the component mfa pairing request handler. the manipulation leads to allocation of resources. the attack needs to be done within the local network. the vendor was contacted early about this disclosure but did not respond in any way.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-7070" target="_blank">CVE-2025-7070</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-07-04 17:15:22 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">MEDIUM</span></p>
                    <p><span class="feed-label">CVSS Score:</span> 4.3</p>
                    <p>A vulnerability has been found in IROAD Dashcam Q9 up to 20250624 and classified as problematic. Affected by this vulnerability is an unknown functionality of the component MFA Pairing Request Handler. The manipulation leads to allocation of resources. The attack needs to be done within the local network. The vendor was contacted early about this disclosure but did not respond in any way.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-53366" data-description="the mcp python sdk, called `mcp` on pypi, is a python implementation of the model context protocol (mcp). prior to version 1.9.4, a validation error in the mcp sdk can cause an unhandled exception when processing malformed requests, resulting in service unavailability (500 errors) until manually restarted. impact may vary depending on the deployment conditions, and presence of infrastructure-level resilience measures. version 1.9.4 contains a patch for the issue.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-53366" target="_blank">CVE-2025-53366</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-07-04 17:15:22 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">N/A</span></p>
                    <p><span class="feed-label">CVSS Score:</span> N/A</p>
                    <p>The MCP Python SDK, called `mcp` on PyPI, is a Python implementation of the Model Context Protocol (MCP). Prior to version 1.9.4, a validation error in the MCP SDK can cause an unhandled exception when processing malformed requests, resulting in service unavailability (500 errors) until manually restarted. Impact may vary depending on the deployment conditions, and presence of infrastructure-level resilience measures. Version 1.9.4 contains a patch for the issue.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-53365" data-description="the mcp python sdk, called `mcp` on pypi, is a python implementation of the model context protocol (mcp). prior to version 1.10.0, if a client deliberately triggers an exception after establishing a streamable http session, this can lead to an uncaught closedresourceerror on the server side, causing the server to crash and requiring a restart to restore service. impact may vary depending on the deployment conditions, and presence of infrastructure-level resilience measures. version 1.10.0 contains a patch for the issue.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-53365" target="_blank">CVE-2025-53365</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-07-04 17:15:22 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">N/A</span></p>
                    <p><span class="feed-label">CVSS Score:</span> N/A</p>
                    <p>The MCP Python SDK, called `mcp` on PyPI, is a Python implementation of the Model Context Protocol (MCP). Prior to version 1.10.0, if a client deliberately triggers an exception after establishing a streamable HTTP session, this can lead to an uncaught ClosedResourceError on the server side, causing the server to crash and requiring a restart to restore service. Impact may vary depending on the deployment conditions, and presence of infrastructure-level resilience measures. Version 1.10.0 contains a patch for the issue.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-7069" data-description="a vulnerability, which was classified as problematic, was found in hdf5 1.14.6. affected is the function h5fs__sect_link_size of the file src/h5fssection.c. the manipulation leads to heap-based buffer overflow. it is possible to launch the attack on the local host. the exploit has been disclosed to the public and may be used.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-7069" target="_blank">CVE-2025-7069</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-07-04 16:15:23 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">LOW</span></p>
                    <p><span class="feed-label">CVSS Score:</span> 3.3</p>
                    <p>A vulnerability, which was classified as problematic, was found in HDF5 1.14.6. Affected is the function H5FS__sect_link_size of the file src/H5FSsection.c. The manipulation leads to heap-based buffer overflow. It is possible to launch the attack on the local host. The exploit has been disclosed to the public and may be used.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-7068" data-description="a vulnerability, which was classified as problematic, has been found in hdf5 1.14.6. this issue affects the function h5fl__malloc of the file src/h5fl.c. the manipulation leads to memory leak. attacking locally is a requirement. the exploit has been disclosed to the public and may be used.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-7068" target="_blank">CVE-2025-7068</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-07-04 16:15:23 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">LOW</span></p>
                    <p><span class="feed-label">CVSS Score:</span> 3.3</p>
                    <p>A vulnerability, which was classified as problematic, has been found in HDF5 1.14.6. This issue affects the function H5FL__malloc of the file src/H5FL.c. The manipulation leads to memory leak. Attacking locally is a requirement. The exploit has been disclosed to the public and may be used.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-53602" data-description="zipkin through 3.5.1 has a /heapdump endpoint (associated with the use of spring boot actuator), a similar issue to cve-2025-48927.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-53602" target="_blank">CVE-2025-53602</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-07-04 16:15:23 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">MEDIUM</span></p>
                    <p><span class="feed-label">CVSS Score:</span> 5.3</p>
                    <p>Zipkin through 3.5.1 has a /heapdump endpoint (associated with the use of Spring Boot Actuator), a similar issue to CVE-2025-48927.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-7067" data-description="a vulnerability classified as problematic was found in hdf5 1.14.6. this vulnerability affects the function h5fs__sinfo_serialize_node_cb of the file src/h5fscache.c. the manipulation leads to heap-based buffer overflow. local access is required to approach this attack. the exploit has been disclosed to the public and may be used.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-7067" target="_blank">CVE-2025-7067</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-07-04 13:15:23 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">LOW</span></p>
                    <p><span class="feed-label">CVSS Score:</span> 3.3</p>
                    <p>A vulnerability classified as problematic was found in HDF5 1.14.6. This vulnerability affects the function H5FS__sinfo_serialize_node_cb of the file src/H5FScache.c. The manipulation leads to heap-based buffer overflow. Local access is required to approach this attack. The exploit has been disclosed to the public and may be used.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-53485" data-description="settranslationhandler.php does not validate that the user is an election admin, allowing any (even unauthenticated) user to change election-related translation text. while partially broken in newer mediawiki versions, the check is still missing.




this issue affects mediawiki - securepoll extension: from 1.39.x before 1.39.13, from 1.42.x before 1.42.7, from 1.43.x before 1.43.2.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-53485" target="_blank">CVE-2025-53485</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-07-04 13:15:23 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">N/A</span></p>
                    <p><span class="feed-label">CVSS Score:</span> N/A</p>
                    <p>SetTranslationHandler.php does not validate that the user is an election admin, allowing any (even unauthenticated) user to change election-related translation text. While partially broken in newer MediaWiki versions, the check is still missing.




This issue affects Mediawiki - SecurePoll extension: from 1.39.X before 1.39.13, from 1.42.X before 1.42.7, from 1.43.X before 1.43.2.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-53484" data-description="user-controlled inputs are improperly escaped in:




  *  
votepage.php (poll option input)



  *  
resultpage::getpagestab() and geterrorstab() (user-controllable page names)












this allows attackers to inject javascript and compromise user sessions under certain conditions.




this issue affects mediawiki - securepoll extension: from 1.39.x before 1.39.13, from 1.42.x before 1.42.7, from 1.43.x before 1.43.2.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-53484" target="_blank">CVE-2025-53484</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-07-04 13:15:23 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">N/A</span></p>
                    <p><span class="feed-label">CVSS Score:</span> N/A</p>
                    <p>User-controlled inputs are improperly escaped in:




  *  
VotePage.php (poll option input)



  *  
ResultPage::getPagesTab() and getErrorsTab() (user-controllable page names)












This allows attackers to inject JavaScript and compromise user sessions under certain conditions.




This issue affects Mediawiki - SecurePoll extension: from 1.39.X before 1.39.13, from 1.42.X before 1.42.7, from 1.43.X before 1.43.2.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-53483" data-description="archivepage.php, unarchivepage.php, and votereligibilitypage#executeclear() do not validate request methods or csrf tokens, allowing attackers to trigger sensitive actions if an admin visits a malicious site.




this issue affects mediawiki - securepoll extension: from 1.39.x before 1.39.13, from 1.42.x before 1.42.7, from 1.43.x before 1.43.2.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-53483" target="_blank">CVE-2025-53483</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-07-04 13:15:22 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">N/A</span></p>
                    <p><span class="feed-label">CVSS Score:</span> N/A</p>
                    <p>ArchivePage.php, UnarchivePage.php, and VoterEligibilityPage#executeClear() do not validate request methods or CSRF tokens, allowing attackers to trigger sensitive actions if an admin visits a malicious site.




This issue affects Mediawiki - SecurePoll extension: from 1.39.X before 1.39.13, from 1.42.X before 1.42.7, from 1.43.X before 1.43.2.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-53482" data-description="improper neutralization of input during web page generation (xss or 'cross-site scripting') vulnerability in wikimedia foundation mediawiki - ipinfo extension allows cross-site scripting (xss).this issue affects mediawiki - ipinfo extension: from 1.39.x before 1.39.13, from 1.42.x before 1.42.7, from 1.43.x before 1.43.2.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-53482" target="_blank">CVE-2025-53482</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-07-04 11:15:22 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">N/A</span></p>
                    <p><span class="feed-label">CVSS Score:</span> N/A</p>
                    <p>Improper Neutralization of Input During Web Page Generation (XSS or 'Cross-site Scripting') vulnerability in Wikimedia Foundation Mediawiki - IPInfo Extension allows Cross-Site Scripting (XSS).This issue affects Mediawiki - IPInfo Extension: from 1.39.X before 1.39.13, from 1.42.X before 1.42.7, from 1.43.X before 1.43.2.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-53481" data-description="uncontrolled resource consumption vulnerability in wikimedia foundation mediawiki - ipinfo extension allows excessive allocation.this issue affects mediawiki - ipinfo extension: from 1.39.x before 1.39.13, from 1.42.x before 1.42.7, from 1.43.x before 1.43.2.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-53481" target="_blank">CVE-2025-53481</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-07-04 11:15:22 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">N/A</span></p>
                    <p><span class="feed-label">CVSS Score:</span> N/A</p>
                    <p>Uncontrolled Resource Consumption vulnerability in Wikimedia Foundation Mediawiki - IPInfo Extension allows Excessive Allocation.This issue affects Mediawiki - IPInfo Extension: from 1.39.X before 1.39.13, from 1.42.X before 1.42.7, from 1.43.X before 1.43.2.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-52497" data-description="mbed tls before 3.6.4 has a pem parsing one-byte heap-based buffer underflow, in mbedtls_pem_read_buffer and two mbedtls_pk_parse functions, via untrusted pem input.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-52497" target="_blank">CVE-2025-52497</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-07-04 10:15:22 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">MEDIUM</span></p>
                    <p><span class="feed-label">CVSS Score:</span> 4.8</p>
                    <p>Mbed TLS before 3.6.4 has a PEM parsing one-byte heap-based buffer underflow, in mbedtls_pem_read_buffer and two mbedtls_pk_parse functions, via untrusted PEM input.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-52496" data-description="mbed tls before 3.6.4 has a race condition in aesni detection if certain compiler optimizations occur. an attacker may be able to extract an aes key from a multithreaded program, or perform a gcm forgery.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-52496" target="_blank">CVE-2025-52496</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-07-04 10:15:22 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-online">HIGH</span></p>
                    <p><span class="feed-label">CVSS Score:</span> 7.8</p>
                    <p>Mbed TLS before 3.6.4 has a race condition in AESNI detection if certain compiler optimizations occur. An attacker may be able to extract an AES key from a multithreaded program, or perform a GCM forgery.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-49601" data-description="in mbedtls 3.3.0 before 3.6.4, mbedtls_lms_import_public_key does not check that the input buffer is at least 4 bytes before reading a 32-bit field, allowing a possible out-of-bounds read on truncated input. specifically, an out-of-bounds read in mbedtls_lms_import_public_key allows context-dependent attackers to trigger a crash or limited adjacent-memory disclosure by supplying a truncated lms (leighton-micali signature) public-key buffer under four bytes. an lms public key starts with a 4-byte type indicator. the function mbedtls_lms_import_public_key reads this type indicator before validating the size of its input.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-49601" target="_blank">CVE-2025-49601</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-07-04 10:15:22 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">MEDIUM</span></p>
                    <p><span class="feed-label">CVSS Score:</span> 4.8</p>
                    <p>In MbedTLS 3.3.0 before 3.6.4, mbedtls_lms_import_public_key does not check that the input buffer is at least 4 bytes before reading a 32-bit field, allowing a possible out-of-bounds read on truncated input. Specifically, an out-of-bounds read in mbedtls_lms_import_public_key allows context-dependent attackers to trigger a crash or limited adjacent-memory disclosure by supplying a truncated LMS (Leighton-Micali Signature) public-key buffer under four bytes. An LMS public key starts with a 4-byte type indicator. The function mbedtls_lms_import_public_key reads this type indicator before validating the size of its input.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-49600" data-description="in mbedtls 3.3.0 before 3.6.4, mbedtls_lms_verify may accept invalid signatures if hash computation fails and internal errors go unchecked, enabling lms (leighton-micali signature) forgery in a fault scenario. specifically, unchecked return values in mbedtls_lms_verify allow an attacker (who can induce a hardware hash accelerator fault) to bypass lms signature verification by reusing stale stack data, resulting in acceptance of an invalid signature. in mbedtls_lms_verify, the return values of the internal merkle tree functions create_merkle_leaf_value and create_merkle_internal_value are not checked. these functions return an integer that indicates whether the call succeeded or not. if a failure occurs, the output buffer (tc_candidate_root_node) may remain uninitialized, and the result of the signature verification is unpredictable. when the software implementation of sha-256 is used, these functions will not fail. however, with hardware-accelerated hashing, an attacker could use fault injection against the accelerator to bypass verification.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-49600" target="_blank">CVE-2025-49600</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-07-04 10:15:22 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">MEDIUM</span></p>
                    <p><span class="feed-label">CVSS Score:</span> 4.9</p>
                    <p>In MbedTLS 3.3.0 before 3.6.4, mbedtls_lms_verify may accept invalid signatures if hash computation fails and internal errors go unchecked, enabling LMS (Leighton-Micali Signature) forgery in a fault scenario. Specifically, unchecked return values in mbedtls_lms_verify allow an attacker (who can induce a hardware hash accelerator fault) to bypass LMS signature verification by reusing stale stack data, resulting in acceptance of an invalid signature. In mbedtls_lms_verify, the return values of the internal Merkle tree functions create_merkle_leaf_value and create_merkle_internal_value are not checked. These functions return an integer that indicates whether the call succeeded or not. If a failure occurs, the output buffer (Tc_candidate_root_node) may remain uninitialized, and the result of the signature verification is unpredictable. When the software implementation of SHA-256 is used, these functions will not fail. However, with hardware-accelerated hashing, an attacker could use fault injection against the accelerator to bypass verification.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-46733" data-description="op-tee is a trusted execution environment (tee) designed as companion to a non-secure linux kernel running on arm; cortex-a cores using the trustzone technology. in version 4.5.0, using a specially crafted tee-supplicant binary running in ree userspace, an attacker can trigger a panic in a ta that uses the libutee secure storage api. many functions in libutee, specifically those which make up the secure storage api, will panic if a system call returns an unexpected return code. this behavior is mandated by the tee internal core api specification. however, in op-tee’s implementation, return codes of secure storage operations are passed through unsanitized from the ree tee-supplicant, through the linux kernel tee-driver, through the op-tee kernel, back to libutee. thus, an attacker with access to ree userspace, and the ability to stop tee-supplicant and replace it with their own process (generally trivial for a root user, and depending on the way permissions are set up, potentially available even to less privileged users) can run a malicious tee-supplicant process that responds to storage requests with unexpected response codes, triggering a panic in the requesting ta. this is particularly dangerous for tas built with `ta_flag_single_instance` (corresponding to `gpd.ta.singleinstance` and `ta_flag_instance_keep_alive` (corresponding to `gpd.ta.keepalive`). the behavior of these tas may depend on memory that is preserved between sessions, and the ability of an attacker to panic the ta and reload it with a clean memory space can compromise the behavior of those tas. a critical example of this is the optee_ftpm ta. it uses the kept alive memory to hold pcr values, which crucially must be non-resettable. an attacker who can trigger a panic in the ftpm ta can reset the pcrs, and then extend them pcrs with whatever they choose, falsifying boot measurements, accessing sealed data, and potentially more. the impact of this issue depends significantly on the behavior of affected tas. for some, it could manifest as a denial of service, while for others, like the ftpm ta, it can result in the disclosure of sensitive data. anyone running the ftpm ta is affected, but similar attacks may be possible on other tas that leverage the secure storage api. a fix is available in commit 941a58d78c99c4754fbd4ec3079ec9e1d596af8f.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-46733" target="_blank">CVE-2025-46733</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-07-04 09:15:33 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-online">HIGH</span></p>
                    <p><span class="feed-label">CVSS Score:</span> 7.9</p>
                    <p>OP-TEE is a Trusted Execution Environment (TEE) designed as companion to a non-secure Linux kernel running on Arm; Cortex-A cores using the TrustZone technology. In version 4.5.0, using a specially crafted tee-supplicant binary running in REE userspace, an attacker can trigger a panic in a TA that uses the libutee Secure Storage API. Many functions in libutee, specifically those which make up the Secure Storage API, will panic if a system call returns an unexpected return code. This behavior is mandated by the TEE Internal Core API specification. However, in OP-TEE’s implementation, return codes of secure storage operations are passed through unsanitized from the REE tee-supplicant, through the Linux kernel tee-driver, through the OP-TEE kernel, back to libutee. Thus, an attacker with access to REE userspace, and the ability to stop tee-supplicant and replace it with their own process (generally trivial for a root user, and depending on the way permissions are set up, potentially available even to less privileged users) can run a malicious tee-supplicant process that responds to storage requests with unexpected response codes, triggering a panic in the requesting TA. This is particularly dangerous for TAs built with `TA_FLAG_SINGLE_INSTANCE` (corresponding to `gpd.ta.singleInstance` and `TA_FLAG_INSTANCE_KEEP_ALIVE` (corresponding to `gpd.ta.keepAlive`). The behavior of these TAs may depend on memory that is preserved between sessions, and the ability of an attacker to panic the TA and reload it with a clean memory space can compromise the behavior of those TAs. A critical example of this is the optee_ftpm TA. It uses the kept alive memory to hold PCR values, which crucially must be non-resettable. An attacker who can trigger a panic in the fTPM TA can reset the PCRs, and then extend them PCRs with whatever they choose, falsifying boot measurements, accessing sealed data, and potentially more. The impact of this issue depends significantly on the behavior of affected TAs. For some, it could manifest as a denial of service, while for others, like the fTPM TA, it can result in the disclosure of sensitive data. Anyone running the fTPM TA is affected, but similar attacks may be possible on other TAs that leverage the Secure Storage API. A fix is available in commit 941a58d78c99c4754fbd4ec3079ec9e1d596af8f.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-38234" data-description="in the linux kernel, the following vulnerability has been resolved:

sched/rt: fix race in push_rt_task

overview
========
when a cpu chooses to call push_rt_task and picks a task to push to
another cpu's runqueue then it will call find_lock_lowest_rq method
which would take a double lock on both cpus' runqueues. if one of the
locks aren't readily available, it may lead to dropping the current
runqueue lock and reacquiring both the locks at once. during this window
it is possible that the task is already migrated and is running on some
other cpu. these cases are already handled. however, if the task is
migrated and has already been executed and another cpu is now trying to
wake it up (ttwu) such that it is queued again on the runqeue
(on_rq is 1) and also if the task was run by the same cpu, then the
current checks will pass even though the task was migrated out and is no
longer in the pushable tasks list.

crashes
=======
this bug resulted in quite a few flavors of crashes triggering kernel
panics with various crash signatures such as assert failures, page
faults, null pointer dereferences, and queue corruption errors all
coming from scheduler itself.

some of the crashes:
-> kernel bug at kernel/sched/rt.c:1616! bug_on(idx >= max_rt_prio)
   call trace:
   ? __die_body+0x1a/0x60
   ? die+0x2a/0x50
   ? do_trap+0x85/0x100
   ? pick_next_task_rt+0x6e/0x1d0
   ? do_error_trap+0x64/0xa0
   ? pick_next_task_rt+0x6e/0x1d0
   ? exc_invalid_op+0x4c/0x60
   ? pick_next_task_rt+0x6e/0x1d0
   ? asm_exc_invalid_op+0x12/0x20
   ? pick_next_task_rt+0x6e/0x1d0
   __schedule+0x5cb/0x790
   ? update_ts_time_stats+0x55/0x70
   schedule_idle+0x1e/0x40
   do_idle+0x15e/0x200
   cpu_startup_entry+0x19/0x20
   start_secondary+0x117/0x160
   secondary_startup_64_no_verify+0xb0/0xbb

-> bug: kernel null pointer dereference, address: 00000000000000c0
   call trace:
   ? __die_body+0x1a/0x60
   ? no_context+0x183/0x350
   ? __warn+0x8a/0xe0
   ? exc_page_fault+0x3d6/0x520
   ? asm_exc_page_fault+0x1e/0x30
   ? pick_next_task_rt+0xb5/0x1d0
   ? pick_next_task_rt+0x8c/0x1d0
   __schedule+0x583/0x7e0
   ? update_ts_time_stats+0x55/0x70
   schedule_idle+0x1e/0x40
   do_idle+0x15e/0x200
   cpu_startup_entry+0x19/0x20
   start_secondary+0x117/0x160
   secondary_startup_64_no_verify+0xb0/0xbb

-> bug: unable to handle page fault for address: ffff9464daea5900
   kernel bug at kernel/sched/rt.c:1861! bug_on(rq->cpu != task_cpu(p))

-> kernel bug at kernel/sched/rt.c:1055! bug_on(!rq->nr_running)
   call trace:
   ? __die_body+0x1a/0x60
   ? die+0x2a/0x50
   ? do_trap+0x85/0x100
   ? dequeue_top_rt_rq+0xa2/0xb0
   ? do_error_trap+0x64/0xa0
   ? dequeue_top_rt_rq+0xa2/0xb0
   ? exc_invalid_op+0x4c/0x60
   ? dequeue_top_rt_rq+0xa2/0xb0
   ? asm_exc_invalid_op+0x12/0x20
   ? dequeue_top_rt_rq+0xa2/0xb0
   dequeue_rt_entity+0x1f/0x70
   dequeue_task_rt+0x2d/0x70
   __schedule+0x1a8/0x7e0
   ? blk_finish_plug+0x25/0x40
   schedule+0x3c/0xb0
   futex_wait_queue_me+0xb6/0x120
   futex_wait+0xd9/0x240
   do_futex+0x344/0xa90
   ? get_mm_exe_file+0x30/0x60
   ? audit_exe_compare+0x58/0x70
   ? audit_filter_rules.constprop.26+0x65e/0x1220
   __x64_sys_futex+0x148/0x1f0
   do_syscall_64+0x30/0x80
   entry_syscall_64_after_hwframe+0x62/0xc7

-> bug: unable to handle page fault for address: ffff8cf3608bc2c0
   call trace:
   ? __die_body+0x1a/0x60
   ? no_context+0x183/0x350
   ? spurious_kernel_fault+0x171/0x1c0
   ? exc_page_fault+0x3b6/0x520
   ? plist_check_list+0x15/0x40
   ? plist_check_list+0x2e/0x40
   ? asm_exc_page_fault+0x1e/0x30
   ? _cond_resched+0x15/0x30
   ? futex_wait_queue_me+0xc8/0x120
   ? futex_wait+0xd9/0x240
   ? try_to_wake_up+0x1b8/0x490
   ? futex_wake+0x78/0x160
   ? do_futex+0xcd/0xa90
   ? plist_check_list+0x15/0x40
   ? plist_check_list+0x2e/0x40
   ? plist_del+0x6a/0xd0
   ? plist_check_list+0x15/0x40
   ? plist_check_list+0x2e/0x40
   ? dequeue_pushable_task+0x20/0x70
   ? __schedule+0x382/0x7e0
   ? asm_sysvec_reschedule_i
---truncated---">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-38234" target="_blank">CVE-2025-38234</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-07-04 09:15:33 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">N/A</span></p>
                    <p><span class="feed-label">CVSS Score:</span> N/A</p>
                    <p>In the Linux kernel, the following vulnerability has been resolved:

sched/rt: Fix race in push_rt_task

Overview
========
When a CPU chooses to call push_rt_task and picks a task to push to
another CPU's runqueue then it will call find_lock_lowest_rq method
which would take a double lock on both CPUs' runqueues. If one of the
locks aren't readily available, it may lead to dropping the current
runqueue lock and reacquiring both the locks at once. During this window
it is possible that the task is already migrated and is running on some
other CPU. These cases are already handled. However, if the task is
migrated and has already been executed and another CPU is now trying to
wake it up (ttwu) such that it is queued again on the runqeue
(on_rq is 1) and also if the task was run by the same CPU, then the
current checks will pass even though the task was migrated out and is no
longer in the pushable tasks list.

Crashes
=======
This bug resulted in quite a few flavors of crashes triggering kernel
panics with various crash signatures such as assert failures, page
faults, null pointer dereferences, and queue corruption errors all
coming from scheduler itself.

Some of the crashes:
-> kernel BUG at kernel/sched/rt.c:1616! BUG_ON(idx >= MAX_RT_PRIO)
   Call Trace:
   ? __die_body+0x1a/0x60
   ? die+0x2a/0x50
   ? do_trap+0x85/0x100
   ? pick_next_task_rt+0x6e/0x1d0
   ? do_error_trap+0x64/0xa0
   ? pick_next_task_rt+0x6e/0x1d0
   ? exc_invalid_op+0x4c/0x60
   ? pick_next_task_rt+0x6e/0x1d0
   ? asm_exc_invalid_op+0x12/0x20
   ? pick_next_task_rt+0x6e/0x1d0
   __schedule+0x5cb/0x790
   ? update_ts_time_stats+0x55/0x70
   schedule_idle+0x1e/0x40
   do_idle+0x15e/0x200
   cpu_startup_entry+0x19/0x20
   start_secondary+0x117/0x160
   secondary_startup_64_no_verify+0xb0/0xbb

-> BUG: kernel NULL pointer dereference, address: 00000000000000c0
   Call Trace:
   ? __die_body+0x1a/0x60
   ? no_context+0x183/0x350
   ? __warn+0x8a/0xe0
   ? exc_page_fault+0x3d6/0x520
   ? asm_exc_page_fault+0x1e/0x30
   ? pick_next_task_rt+0xb5/0x1d0
   ? pick_next_task_rt+0x8c/0x1d0
   __schedule+0x583/0x7e0
   ? update_ts_time_stats+0x55/0x70
   schedule_idle+0x1e/0x40
   do_idle+0x15e/0x200
   cpu_startup_entry+0x19/0x20
   start_secondary+0x117/0x160
   secondary_startup_64_no_verify+0xb0/0xbb

-> BUG: unable to handle page fault for address: ffff9464daea5900
   kernel BUG at kernel/sched/rt.c:1861! BUG_ON(rq->cpu != task_cpu(p))

-> kernel BUG at kernel/sched/rt.c:1055! BUG_ON(!rq->nr_running)
   Call Trace:
   ? __die_body+0x1a/0x60
   ? die+0x2a/0x50
   ? do_trap+0x85/0x100
   ? dequeue_top_rt_rq+0xa2/0xb0
   ? do_error_trap+0x64/0xa0
   ? dequeue_top_rt_rq+0xa2/0xb0
   ? exc_invalid_op+0x4c/0x60
   ? dequeue_top_rt_rq+0xa2/0xb0
   ? asm_exc_invalid_op+0x12/0x20
   ? dequeue_top_rt_rq+0xa2/0xb0
   dequeue_rt_entity+0x1f/0x70
   dequeue_task_rt+0x2d/0x70
   __schedule+0x1a8/0x7e0
   ? blk_finish_plug+0x25/0x40
   schedule+0x3c/0xb0
   futex_wait_queue_me+0xb6/0x120
   futex_wait+0xd9/0x240
   do_futex+0x344/0xa90
   ? get_mm_exe_file+0x30/0x60
   ? audit_exe_compare+0x58/0x70
   ? audit_filter_rules.constprop.26+0x65e/0x1220
   __x64_sys_futex+0x148/0x1f0
   do_syscall_64+0x30/0x80
   entry_SYSCALL_64_after_hwframe+0x62/0xc7

-> BUG: unable to handle page fault for address: ffff8cf3608bc2c0
   Call Trace:
   ? __die_body+0x1a/0x60
   ? no_context+0x183/0x350
   ? spurious_kernel_fault+0x171/0x1c0
   ? exc_page_fault+0x3b6/0x520
   ? plist_check_list+0x15/0x40
   ? plist_check_list+0x2e/0x40
   ? asm_exc_page_fault+0x1e/0x30
   ? _cond_resched+0x15/0x30
   ? futex_wait_queue_me+0xc8/0x120
   ? futex_wait+0xd9/0x240
   ? try_to_wake_up+0x1b8/0x490
   ? futex_wake+0x78/0x160
   ? do_futex+0xcd/0xa90
   ? plist_check_list+0x15/0x40
   ? plist_check_list+0x2e/0x40
   ? plist_del+0x6a/0xd0
   ? plist_check_list+0x15/0x40
   ? plist_check_list+0x2e/0x40
   ? dequeue_pushable_task+0x20/0x70
   ? __schedule+0x382/0x7e0
   ? asm_sysvec_reschedule_i
---truncated---</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-38233" data-description="in the linux kernel, the following vulnerability has been resolved:

powerpc64/ftrace: fix clobbered r15 during livepatching

while r15 is clobbered always with ppc_ftrace_out_of_line, it is
not restored in livepatch sequence leading to not so obvious fails
like below:

  bug: unable to handle kernel data access on write at 0xc0000000000f9078
  faulting instruction address: 0xc0000000018ff958
  oops: kernel access of bad area, sig: 11 [#1]
  ...
  nip:  c0000000018ff958 lr: c0000000018ff930 ctr: c0000000009c0790
  regs: c00000005f2e7790 trap: 0300   tainted: g              k      (6.14.0+)
  msr:  8000000000009033 <sf,ee,me,ir,dr,ri,le>  cr: 2822880b  xer: 20040000
  cfar: c0000000008addc0 dar: c0000000000f9078 dsisr: 0a000000 irqmask: 1
  gpr00: c0000000018f2584 c00000005f2e7a30 c00000000280a900 c000000017ffa488
  gpr04: 0000000000000008 0000000000000000 c0000000018f24fc 000000000000000d
  gpr08: fffffffffffe0000 000000000000000d 0000000000000000 0000000000008000
  gpr12: c0000000009c0790 c000000017ffa480 c00000005f2e7c78 c0000000000f9070
  gpr16: c00000005f2e7c90 0000000000000000 0000000000000000 0000000000000000
  gpr20: 0000000000000000 c00000005f3efa80 c00000005f2e7c60 c00000005f2e7c88
  gpr24: c00000005f2e7c60 0000000000000001 c0000000000f9078 0000000000000000
  gpr28: 00007fff97960000 c000000017ffa480 0000000000000000 c0000000000f9078
  ...
  call trace:
    check_heap_object+0x34/0x390 (unreliable)
  __mutex_unlock_slowpath.isra.0+0xe4/0x230
  seq_read_iter+0x430/0xa90
  proc_reg_read_iter+0xa4/0x200
  vfs_read+0x41c/0x510
  ksys_read+0xa4/0x190
  system_call_exception+0x1d0/0x440
  system_call_vectored_common+0x15c/0x2ec

fix it by restoring r15 always.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-38233" target="_blank">CVE-2025-38233</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-07-04 09:15:32 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">N/A</span></p>
                    <p><span class="feed-label">CVSS Score:</span> N/A</p>
                    <p>In the Linux kernel, the following vulnerability has been resolved:

powerpc64/ftrace: fix clobbered r15 during livepatching

While r15 is clobbered always with PPC_FTRACE_OUT_OF_LINE, it is
not restored in livepatch sequence leading to not so obvious fails
like below:

  BUG: Unable to handle kernel data access on write at 0xc0000000000f9078
  Faulting instruction address: 0xc0000000018ff958
  Oops: Kernel access of bad area, sig: 11 [#1]
  ...
  NIP:  c0000000018ff958 LR: c0000000018ff930 CTR: c0000000009c0790
  REGS: c00000005f2e7790 TRAP: 0300   Tainted: G              K      (6.14.0+)
  MSR:  8000000000009033 <SF,EE,ME,IR,DR,RI,LE>  CR: 2822880b  XER: 20040000
  CFAR: c0000000008addc0 DAR: c0000000000f9078 DSISR: 0a000000 IRQMASK: 1
  GPR00: c0000000018f2584 c00000005f2e7a30 c00000000280a900 c000000017ffa488
  GPR04: 0000000000000008 0000000000000000 c0000000018f24fc 000000000000000d
  GPR08: fffffffffffe0000 000000000000000d 0000000000000000 0000000000008000
  GPR12: c0000000009c0790 c000000017ffa480 c00000005f2e7c78 c0000000000f9070
  GPR16: c00000005f2e7c90 0000000000000000 0000000000000000 0000000000000000
  GPR20: 0000000000000000 c00000005f3efa80 c00000005f2e7c60 c00000005f2e7c88
  GPR24: c00000005f2e7c60 0000000000000001 c0000000000f9078 0000000000000000
  GPR28: 00007fff97960000 c000000017ffa480 0000000000000000 c0000000000f9078
  ...
  Call Trace:
    check_heap_object+0x34/0x390 (unreliable)
  __mutex_unlock_slowpath.isra.0+0xe4/0x230
  seq_read_iter+0x430/0xa90
  proc_reg_read_iter+0xa4/0x200
  vfs_read+0x41c/0x510
  ksys_read+0xa4/0x190
  system_call_exception+0x1d0/0x440
  system_call_vectored_common+0x15c/0x2ec

Fix it by restoring r15 always.</p>
                </div>
        
            </div>
        </div>

        <footer class="footer">
            <p>© 2025 dotne1 - Cybersecurity Portfolio</p>
        </footer>

        <script>
            function searchCVEs() {
                const input = document.getElementById('searchInput').value.toLowerCase();
                const cveEntries = document.getElementsByClassName('cve-entry');
                for (let i = 0; i < cveEntries.length; i++) {
                    const cveId = cveEntries[i].getAttribute('data-cve-id').toLowerCase();
                    const description = cveEntries[i].getAttribute('data-description');
                    if (cveId.includes(input) || description.includes(input)) {
                        cveEntries[i].style.display = '';
                    } else {
                        cveEntries[i].style.display = 'none';
                    }
                }
            }
        </script>
    </body>
    </html>
    