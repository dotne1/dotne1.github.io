
    <!DOCTYPE html>
    <html lang="en">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <meta name="description" content="Security alerts and cybersecurity news feeds">
        <meta name="keywords" content="cybersecurity news, security alerts, vulnerability feeds, threat intelligence">
        <meta name="author" content="dotne1">
        <meta property="og:title" content="Security Feeds - dotne1's Cybersecurity Portfolio">
        <meta property="og:description" content="Stay updated with the latest cybersecurity news and alerts">
        <meta property="og:type" content="website">
        <title>Security Feeds - dotne1's Cybersecurity Portfolio</title>
        <link rel="stylesheet" href="styles.css">
        <link rel="icon" type="image/x-icon" href="/favicon.ico">
    </head>
    <body>
        <nav class="navbar">
            <div class="nav-links">
                <a href="index.html" class="nav-link">Home</a>
                <a href="about-me.html" class="nav-link">About Me</a>
                <a href="projects.html" class="nav-link">Projects</a>
                <a href="resume.html" class="nav-link">Resume</a>
                <a href="feeds.html" class="nav-link">Feeds</a>
            </div>
        </nav>

        <div class="container" role="main">
            <h1 class="main-header">Security Feeds</h1>
            <div class="search-bar">
                <input type="text" id="searchInput" placeholder="Search CVEs..." onkeyup="searchCVEs()">
            </div>
            <div class="feed-preview" id="cveFeed">
                <div class="feed-header">Latest Vulnerabilities</div>
    
                <div class="cve-entry" data-cve-id="CVE-2025-68749" data-description="in the linux kernel, the following vulnerability has been resolved:

accel/ivpu: fix race condition when unbinding bos

fix 'memory manager not clean during takedown' warning that occurs
when ivpu_gem_bo_free() removes the bo from the bos list before it
gets unmapped. then file_priv_unbind() triggers a warning in
drm_mm_takedown() during context teardown.

protect the unmapping sequence with bo_list_lock to ensure the bo is
always fully unmapped when removed from the list. this ensures the bo
is either fully unmapped at context teardown time or present on the
list and unmapped by file_priv_unbind().">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-68749" target="_blank">CVE-2025-68749</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-12-24 07:16:29 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">N/A</span></p>
                    <p><span class="feed-label">CVSS Score:</span> N/A</p>
                    <p>In the Linux kernel, the following vulnerability has been resolved:

accel/ivpu: Fix race condition when unbinding BOs

Fix 'Memory manager not clean during takedown' warning that occurs
when ivpu_gem_bo_free() removes the BO from the BOs list before it
gets unmapped. Then file_priv_unbind() triggers a warning in
drm_mm_takedown() during context teardown.

Protect the unmapping sequence with bo_list_lock to ensure the BO is
always fully unmapped when removed from the list. This ensures the BO
is either fully unmapped at context teardown time or present on the
list and unmapped by file_priv_unbind().</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-68748" data-description="in the linux kernel, the following vulnerability has been resolved:

drm/panthor: fix uaf race between device unplug and fw event processing

the function panthor_fw_unplug() will free the fw memory sections.
the problem is that there could still be pending fw events which are yet
not handled at this point. process_fw_events_work() can in this case try
to access said freed memory.

simply call disable_work_sync() to both drain and prevent future
invocation of process_fw_events_work().">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-68748" target="_blank">CVE-2025-68748</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-12-24 07:16:29 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">N/A</span></p>
                    <p><span class="feed-label">CVSS Score:</span> N/A</p>
                    <p>In the Linux kernel, the following vulnerability has been resolved:

drm/panthor: Fix UAF race between device unplug and FW event processing

The function panthor_fw_unplug() will free the FW memory sections.
The problem is that there could still be pending FW events which are yet
not handled at this point. process_fw_events_work() can in this case try
to access said freed memory.

Simply call disable_work_sync() to both drain and prevent future
invocation of process_fw_events_work().</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-68747" data-description="in the linux kernel, the following vulnerability has been resolved:

drm/panthor: fix uaf on kernel bo va nodes

if the mmu is down, panthor_vm_unmap_range() might return an error.
we expect the page table to be updated still, and if the mmu is blocked,
the rest of the gpu should be blocked too, so no risk of accessing
physical memory returned to the system (which the current code doesn't
cover for anyway).

proceed with the rest of the cleanup instead of bailing out and leaving
the va_node inserted in the drm_mm, which leads to uaf when other
adjacent nodes are removed from the drm_mm tree.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-68747" target="_blank">CVE-2025-68747</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-12-24 07:16:29 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">N/A</span></p>
                    <p><span class="feed-label">CVSS Score:</span> N/A</p>
                    <p>In the Linux kernel, the following vulnerability has been resolved:

drm/panthor: Fix UAF on kernel BO VA nodes

If the MMU is down, panthor_vm_unmap_range() might return an error.
We expect the page table to be updated still, and if the MMU is blocked,
the rest of the GPU should be blocked too, so no risk of accessing
physical memory returned to the system (which the current code doesn't
cover for anyway).

Proceed with the rest of the cleanup instead of bailing out and leaving
the va_node inserted in the drm_mm, which leads to UAF when other
adjacent nodes are removed from the drm_mm tree.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-68746" data-description="in the linux kernel, the following vulnerability has been resolved:

spi: tegra210-quad: fix timeout handling

when the cpu that the qspi interrupt handler runs on (typically cpu 0)
is excessively busy, it can lead to rare cases of the irq thread not
running before the transfer timeout is reached.

while handling the timeouts, any pending transfers are cleaned up and
the message that they correspond to is marked as failed, which leaves
the curr_xfer field pointing at stale memory.

to avoid this, clear curr_xfer to null upon timeout and check for this
condition when the irq thread is finally run.

while at it, also make sure to clear interrupts on failure so that new
interrupts can be run.

a better, more involved, fix would move the interrupt clearing into a
hard irq handler. ideally we would also want to signal that the irq
thread no longer needs to be run after the timeout is hit to avoid the
extra check for a valid transfer.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-68746" target="_blank">CVE-2025-68746</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-12-24 07:16:29 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">N/A</span></p>
                    <p><span class="feed-label">CVSS Score:</span> N/A</p>
                    <p>In the Linux kernel, the following vulnerability has been resolved:

spi: tegra210-quad: Fix timeout handling

When the CPU that the QSPI interrupt handler runs on (typically CPU 0)
is excessively busy, it can lead to rare cases of the IRQ thread not
running before the transfer timeout is reached.

While handling the timeouts, any pending transfers are cleaned up and
the message that they correspond to is marked as failed, which leaves
the curr_xfer field pointing at stale memory.

To avoid this, clear curr_xfer to NULL upon timeout and check for this
condition when the IRQ thread is finally run.

While at it, also make sure to clear interrupts on failure so that new
interrupts can be run.

A better, more involved, fix would move the interrupt clearing into a
hard IRQ handler. Ideally we would also want to signal that the IRQ
thread no longer needs to be run after the timeout is hit to avoid the
extra check for a valid transfer.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-68745" data-description="in the linux kernel, the following vulnerability has been resolved:

scsi: qla2xxx: clear cmds after chip reset

commit aefed3e5548f ("scsi: qla2xxx: target: fix offline port handling
and host reset handling") caused two problems:

1. commands sent to fw, after chip reset got stuck and never freed as fw
   is not going to respond to them anymore.

2. bug_on(cmd->sg_mapped) in qlt_free_cmd().  commit 26f9ce53817a
   ("scsi: qla2xxx: fix missed dma unmap for aborted commands")
   attempted to fix this, but introduced another bug under different
   circumstances when two different cpus were racing to call
   qlt_unmap_sg() at the same time: bug_on(!valid_dma_direction(dir)) in
   dma_unmap_sg_attrs().

so revert "scsi: qla2xxx: fix missed dma unmap for aborted commands" and
partially revert "scsi: qla2xxx: target: fix offline port handling and
host reset handling" at __qla2x00_abort_all_cmds.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-68745" target="_blank">CVE-2025-68745</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-12-24 07:16:29 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">N/A</span></p>
                    <p><span class="feed-label">CVSS Score:</span> N/A</p>
                    <p>In the Linux kernel, the following vulnerability has been resolved:

scsi: qla2xxx: Clear cmds after chip reset

Commit aefed3e5548f ("scsi: qla2xxx: target: Fix offline port handling
and host reset handling") caused two problems:

1. Commands sent to FW, after chip reset got stuck and never freed as FW
   is not going to respond to them anymore.

2. BUG_ON(cmd->sg_mapped) in qlt_free_cmd().  Commit 26f9ce53817a
   ("scsi: qla2xxx: Fix missed DMA unmap for aborted commands")
   attempted to fix this, but introduced another bug under different
   circumstances when two different CPUs were racing to call
   qlt_unmap_sg() at the same time: BUG_ON(!valid_dma_direction(dir)) in
   dma_unmap_sg_attrs().

So revert "scsi: qla2xxx: Fix missed DMA unmap for aborted commands" and
partially revert "scsi: qla2xxx: target: Fix offline port handling and
host reset handling" at __qla2x00_abort_all_cmds.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-68744" data-description="in the linux kernel, the following vulnerability has been resolved:

bpf: free special fields when update [lru_,]percpu_hash maps

as [lru_,]percpu_hash maps support bpf_kptr_{ref,percpu}, missing
calls to 'bpf_obj_free_fields()' in 'pcpu_copy_value()' could cause the
memory referenced by bpf_kptr_{ref,percpu} fields to be held until the
map gets freed.

fix this by calling 'bpf_obj_free_fields()' after
'copy_map_value[,_long]()' in 'pcpu_copy_value()'.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-68744" target="_blank">CVE-2025-68744</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-12-24 07:16:29 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">N/A</span></p>
                    <p><span class="feed-label">CVSS Score:</span> N/A</p>
                    <p>In the Linux kernel, the following vulnerability has been resolved:

bpf: Free special fields when update [lru_,]percpu_hash maps

As [lru_,]percpu_hash maps support BPF_KPTR_{REF,PERCPU}, missing
calls to 'bpf_obj_free_fields()' in 'pcpu_copy_value()' could cause the
memory referenced by BPF_KPTR_{REF,PERCPU} fields to be held until the
map gets freed.

Fix this by calling 'bpf_obj_free_fields()' after
'copy_map_value[,_long]()' in 'pcpu_copy_value()'.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-68743" data-description="in the linux kernel, the following vulnerability has been resolved:

mshv: fix create memory region overlap check

the current check is incorrect; it only checks if the beginning or end
of a region is within an existing region. this doesn't account for
userspace specifying a region that begins before and ends after an
existing region.

change the logic to a range intersection check against gfns and uaddrs
for each region.

remove mshv_partition_region_by_uaddr() as it is no longer used.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-68743" target="_blank">CVE-2025-68743</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-12-24 07:16:29 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">N/A</span></p>
                    <p><span class="feed-label">CVSS Score:</span> N/A</p>
                    <p>In the Linux kernel, the following vulnerability has been resolved:

mshv: Fix create memory region overlap check

The current check is incorrect; it only checks if the beginning or end
of a region is within an existing region. This doesn't account for
userspace specifying a region that begins before and ends after an
existing region.

Change the logic to a range intersection check against gfns and uaddrs
for each region.

Remove mshv_partition_region_by_uaddr() as it is no longer used.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-68742" data-description="in the linux kernel, the following vulnerability has been resolved:

bpf: fix invalid prog->stats access when update_effective_progs fails

syzkaller triggers an invalid memory access issue following fault
injection in update_effective_progs. the issue can be described as
follows:

__cgroup_bpf_detach
  update_effective_progs
    compute_effective_progs
      bpf_prog_array_alloc <-- fault inject
  purge_effective_progs
    /* change to dummy_bpf_prog */
    array->items[index] = &dummy_bpf_prog.prog

---softirq start---
__do_softirq
  ...
    __cgroup_bpf_run_filter_skb
      __bpf_prog_run_save_cb
        bpf_prog_run
          stats = this_cpu_ptr(prog->stats)
          /* invalid memory access */
          flags = u64_stats_update_begin_irqsave(&stats->syncp)
---softirq end---

  static_branch_dec(&cgroup_bpf_enabled_key[atype])

the reason is that fault injection caused update_effective_progs to fail
and then changed the original prog into dummy_bpf_prog.prog in
purge_effective_progs. then a softirq came, and accessing the members of
dummy_bpf_prog.prog in the softirq triggers invalid mem access.

to fix it, skip updating stats when stats is null.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-68742" target="_blank">CVE-2025-68742</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-12-24 07:16:29 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">N/A</span></p>
                    <p><span class="feed-label">CVSS Score:</span> N/A</p>
                    <p>In the Linux kernel, the following vulnerability has been resolved:

bpf: Fix invalid prog->stats access when update_effective_progs fails

Syzkaller triggers an invalid memory access issue following fault
injection in update_effective_progs. The issue can be described as
follows:

__cgroup_bpf_detach
  update_effective_progs
    compute_effective_progs
      bpf_prog_array_alloc <-- fault inject
  purge_effective_progs
    /* change to dummy_bpf_prog */
    array->items[index] = &dummy_bpf_prog.prog

---softirq start---
__do_softirq
  ...
    __cgroup_bpf_run_filter_skb
      __bpf_prog_run_save_cb
        bpf_prog_run
          stats = this_cpu_ptr(prog->stats)
          /* invalid memory access */
          flags = u64_stats_update_begin_irqsave(&stats->syncp)
---softirq end---

  static_branch_dec(&cgroup_bpf_enabled_key[atype])

The reason is that fault injection caused update_effective_progs to fail
and then changed the original prog into dummy_bpf_prog.prog in
purge_effective_progs. Then a softirq came, and accessing the members of
dummy_bpf_prog.prog in the softirq triggers invalid mem access.

To fix it, skip updating stats when stats is NULL.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-68741" data-description="in the linux kernel, the following vulnerability has been resolved:

scsi: qla2xxx: fix improper freeing of purex item

in qla2xxx_process_purls_iocb(), an item is allocated via
qla27xx_copy_multiple_pkt(), which internally calls
qla24xx_alloc_purex_item().

the qla24xx_alloc_purex_item() function may return a pre-allocated item
from a per-adapter pool for small allocations, instead of dynamically
allocating memory with kzalloc().

an error handling path in qla2xxx_process_purls_iocb() incorrectly uses
kfree() to release the item. if the item was from the pre-allocated
pool, calling kfree() on it is a bug that can lead to memory corruption.

fix this by using the correct deallocation function,
qla24xx_free_purex_item(), which properly handles both dynamically
allocated and pre-allocated items.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-68741" target="_blank">CVE-2025-68741</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-12-24 07:16:29 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">N/A</span></p>
                    <p><span class="feed-label">CVSS Score:</span> N/A</p>
                    <p>In the Linux kernel, the following vulnerability has been resolved:

scsi: qla2xxx: Fix improper freeing of purex item

In qla2xxx_process_purls_iocb(), an item is allocated via
qla27xx_copy_multiple_pkt(), which internally calls
qla24xx_alloc_purex_item().

The qla24xx_alloc_purex_item() function may return a pre-allocated item
from a per-adapter pool for small allocations, instead of dynamically
allocating memory with kzalloc().

An error handling path in qla2xxx_process_purls_iocb() incorrectly uses
kfree() to release the item. If the item was from the pre-allocated
pool, calling kfree() on it is a bug that can lead to memory corruption.

Fix this by using the correct deallocation function,
qla24xx_free_purex_item(), which properly handles both dynamically
allocated and pre-allocated items.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-68740" data-description="in the linux kernel, the following vulnerability has been resolved:

ima: handle error code returned by ima_filter_rule_match()

in ima_match_rules(), if ima_filter_rule_match() returns -enoent due to
the rule being null, the function incorrectly skips the 'if (!rc)' check
and sets 'result = true'. the lsm rule is considered a match, causing
extra files to be measured by ima.

this issue can be reproduced in the following scenario:
after unloading the selinux policy module via 'semodule -d', if an ima
measurement is triggered before ima_lsm_rules is updated,
in ima_match_rules(), the first call to ima_filter_rule_match() returns
-estale. this causes the code to enter the 'if (rc == -estale &&
!rule_reinitialized)' block, perform ima_lsm_copy_rule() and retry. in
ima_lsm_copy_rule(), since the selinux module has been removed, the rule
becomes null, and the second call to ima_filter_rule_match() returns
-enoent. this bypasses the 'if (!rc)' check and results in a false match.

call trace:
  selinux_audit_rule_match+0x310/0x3b8
  security_audit_rule_match+0x60/0xa0
  ima_match_rules+0x2e4/0x4a0
  ima_match_policy+0x9c/0x1e8
  ima_get_action+0x48/0x60
  process_measurement+0xf8/0xa98
  ima_bprm_check+0x98/0xd8
  security_bprm_check+0x5c/0x78
  search_binary_handler+0x6c/0x318
  exec_binprm+0x58/0x1b8
  bprm_execve+0xb8/0x130
  do_execveat_common.isra.0+0x1a8/0x258
  __arm64_sys_execve+0x48/0x68
  invoke_syscall+0x50/0x128
  el0_svc_common.constprop.0+0xc8/0xf0
  do_el0_svc+0x24/0x38
  el0_svc+0x44/0x200
  el0t_64_sync_handler+0x100/0x130
  el0t_64_sync+0x3c8/0x3d0

fix this by changing 'if (!rc)' to 'if (rc <= 0)' to ensure that error
codes like -enoent do not bypass the check and accidentally result in a
successful match.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-68740" target="_blank">CVE-2025-68740</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-12-24 07:16:28 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">N/A</span></p>
                    <p><span class="feed-label">CVSS Score:</span> N/A</p>
                    <p>In the Linux kernel, the following vulnerability has been resolved:

ima: Handle error code returned by ima_filter_rule_match()

In ima_match_rules(), if ima_filter_rule_match() returns -ENOENT due to
the rule being NULL, the function incorrectly skips the 'if (!rc)' check
and sets 'result = true'. The LSM rule is considered a match, causing
extra files to be measured by IMA.

This issue can be reproduced in the following scenario:
After unloading the SELinux policy module via 'semodule -d', if an IMA
measurement is triggered before ima_lsm_rules is updated,
in ima_match_rules(), the first call to ima_filter_rule_match() returns
-ESTALE. This causes the code to enter the 'if (rc == -ESTALE &&
!rule_reinitialized)' block, perform ima_lsm_copy_rule() and retry. In
ima_lsm_copy_rule(), since the SELinux module has been removed, the rule
becomes NULL, and the second call to ima_filter_rule_match() returns
-ENOENT. This bypasses the 'if (!rc)' check and results in a false match.

Call trace:
  selinux_audit_rule_match+0x310/0x3b8
  security_audit_rule_match+0x60/0xa0
  ima_match_rules+0x2e4/0x4a0
  ima_match_policy+0x9c/0x1e8
  ima_get_action+0x48/0x60
  process_measurement+0xf8/0xa98
  ima_bprm_check+0x98/0xd8
  security_bprm_check+0x5c/0x78
  search_binary_handler+0x6c/0x318
  exec_binprm+0x58/0x1b8
  bprm_execve+0xb8/0x130
  do_execveat_common.isra.0+0x1a8/0x258
  __arm64_sys_execve+0x48/0x68
  invoke_syscall+0x50/0x128
  el0_svc_common.constprop.0+0xc8/0xf0
  do_el0_svc+0x24/0x38
  el0_svc+0x44/0x200
  el0t_64_sync_handler+0x100/0x130
  el0t_64_sync+0x3c8/0x3d0

Fix this by changing 'if (!rc)' to 'if (rc <= 0)' to ensure that error
codes like -ENOENT do not bypass the check and accidentally result in a
successful match.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-68739" data-description="in the linux kernel, the following vulnerability has been resolved:

pm / devfreq: hisi: fix potential uaf in opp handling

ensure all required data is acquired before calling dev_pm_opp_put(opp)
to maintain correct resource acquisition and release order.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-68739" target="_blank">CVE-2025-68739</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-12-24 07:16:28 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">N/A</span></p>
                    <p><span class="feed-label">CVSS Score:</span> N/A</p>
                    <p>In the Linux kernel, the following vulnerability has been resolved:

PM / devfreq: hisi: Fix potential UAF in OPP handling

Ensure all required data is acquired before calling dev_pm_opp_put(opp)
to maintain correct resource acquisition and release order.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-68738" data-description="in the linux kernel, the following vulnerability has been resolved:

wifi: mt76: mt7996: fix null pointer deref in mt7996_conf_tx()

if a link does not have an assigned channel yet, mt7996_vif_link returns
null. we still need to store the updated queue settings in that case, and
apply them later.
move the location of the queue params to within struct mt7996_vif_link.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-68738" target="_blank">CVE-2025-68738</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-12-24 07:16:28 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">N/A</span></p>
                    <p><span class="feed-label">CVSS Score:</span> N/A</p>
                    <p>In the Linux kernel, the following vulnerability has been resolved:

wifi: mt76: mt7996: fix null pointer deref in mt7996_conf_tx()

If a link does not have an assigned channel yet, mt7996_vif_link returns
NULL. We still need to store the updated queue settings in that case, and
apply them later.
Move the location of the queue params to within struct mt7996_vif_link.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-68737" data-description="in the linux kernel, the following vulnerability has been resolved:

arm64/pageattr: propagate return value from __change_memory_common

the rodata=on security measure requires that any code path which does
vmalloc -> set_memory_ro/set_memory_rox must protect the linear map alias
too. therefore, if such a call fails, we must abort set_memory_* and caller
must take appropriate action; currently we are suppressing the error, and
there is a real chance of such an error arising post commit a166563e7ec3
("arm64: mm: support large block mapping when rodata=full"). therefore,
propagate any error to the caller.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-68737" target="_blank">CVE-2025-68737</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-12-24 07:16:28 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">N/A</span></p>
                    <p><span class="feed-label">CVSS Score:</span> N/A</p>
                    <p>In the Linux kernel, the following vulnerability has been resolved:

arm64/pageattr: Propagate return value from __change_memory_common

The rodata=on security measure requires that any code path which does
vmalloc -> set_memory_ro/set_memory_rox must protect the linear map alias
too. Therefore, if such a call fails, we must abort set_memory_* and caller
must take appropriate action; currently we are suppressing the error, and
there is a real chance of such an error arising post commit a166563e7ec3
("arm64: mm: support large block mapping when rodata=full"). Therefore,
propagate any error to the caller.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-68736" data-description="in the linux kernel, the following vulnerability has been resolved:

landlock: fix handling of disconnected directories

disconnected files or directories can appear when they are visible and
opened from a bind mount, but have been renamed or moved from the source
of the bind mount in a way that makes them inaccessible from the mount
point (i.e. out of scope).

previously, access rights tied to files or directories opened through a
disconnected directory were collected by walking the related hierarchy
down to the root of the filesystem, without taking into account the
mount point because it couldn't be found. this could lead to
inconsistent access results, potential access right widening, and
hard-to-debug renames, especially since such paths cannot be printed.

for a sandboxed task to create a disconnected directory, it needs to
have write access (i.e. fs_make_reg, fs_remove_file, and fs_refer) to
the underlying source of the bind mount, and read access to the related
mount point.   because a sandboxed task cannot acquire more access
rights than those defined by its landlock domain, this could lead to
inconsistent access rights due to missing permissions that should be
inherited from the mount point hierarchy, while inheriting permissions
from the filesystem hierarchy hidden by this mount point instead.

landlock now handles files and directories opened from disconnected
directories by taking into account the filesystem hierarchy when the
mount point is not found in the hierarchy walk, and also always taking
into account the mount point from which these disconnected directories
were opened.  this ensures that a rename is not allowed if it would
widen access rights [1].

the rationale is that, even if disconnected hierarchies might not be
visible or accessible to a sandboxed task, relying on the collected
access rights from them improves the guarantee that access rights will
not be widened during a rename because of the access right comparison
between the source and the destination (see landlock_access_fs_refer).
it may look like this would grant more access on disconnected files and
directories, but the security policies are always enforced for all the
evaluated hierarchies.  this new behavior should be less surprising to
users and safer from an access control perspective.

remove a wrong warn_on_once() canary in collect_domain_accesses() and
fix the related comment.

because opened files have their access rights stored in the related file
security properties, there is no impact for disconnected or unlinked
files.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-68736" target="_blank">CVE-2025-68736</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-12-24 07:16:28 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">N/A</span></p>
                    <p><span class="feed-label">CVSS Score:</span> N/A</p>
                    <p>In the Linux kernel, the following vulnerability has been resolved:

landlock: Fix handling of disconnected directories

Disconnected files or directories can appear when they are visible and
opened from a bind mount, but have been renamed or moved from the source
of the bind mount in a way that makes them inaccessible from the mount
point (i.e. out of scope).

Previously, access rights tied to files or directories opened through a
disconnected directory were collected by walking the related hierarchy
down to the root of the filesystem, without taking into account the
mount point because it couldn't be found. This could lead to
inconsistent access results, potential access right widening, and
hard-to-debug renames, especially since such paths cannot be printed.

For a sandboxed task to create a disconnected directory, it needs to
have write access (i.e. FS_MAKE_REG, FS_REMOVE_FILE, and FS_REFER) to
the underlying source of the bind mount, and read access to the related
mount point.   Because a sandboxed task cannot acquire more access
rights than those defined by its Landlock domain, this could lead to
inconsistent access rights due to missing permissions that should be
inherited from the mount point hierarchy, while inheriting permissions
from the filesystem hierarchy hidden by this mount point instead.

Landlock now handles files and directories opened from disconnected
directories by taking into account the filesystem hierarchy when the
mount point is not found in the hierarchy walk, and also always taking
into account the mount point from which these disconnected directories
were opened.  This ensures that a rename is not allowed if it would
widen access rights [1].

The rationale is that, even if disconnected hierarchies might not be
visible or accessible to a sandboxed task, relying on the collected
access rights from them improves the guarantee that access rights will
not be widened during a rename because of the access right comparison
between the source and the destination (see LANDLOCK_ACCESS_FS_REFER).
It may look like this would grant more access on disconnected files and
directories, but the security policies are always enforced for all the
evaluated hierarchies.  This new behavior should be less surprising to
users and safer from an access control perspective.

Remove a wrong WARN_ON_ONCE() canary in collect_domain_accesses() and
fix the related comment.

Because opened files have their access rights stored in the related file
security properties, there is no impact for disconnected or unlinked
files.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-68735" data-description="in the linux kernel, the following vulnerability has been resolved:

drm/panthor: prevent potential uaf in group creation

this commit prevents the possibility of a use after free issue in the
group_create ioctl function, which arose as pointer to the group is
accessed in that ioctl function after storing it in the xarray.
a malicious userspace can second guess the handle of a group and try
to call group_destroy ioctl from another thread around the same time
as group_create ioctl.

to prevent the use after free exploit, this commit uses a mark on an
entry of group pool xarray which is added just before returning from
the group_create ioctl function. the mark is checked for all ioctls
that specify the group handle and so userspace won't be abe to delete
a group that isn't marked yet.

v2: add r-bs and fixes tags">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-68735" target="_blank">CVE-2025-68735</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-12-24 07:16:28 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">N/A</span></p>
                    <p><span class="feed-label">CVSS Score:</span> N/A</p>
                    <p>In the Linux kernel, the following vulnerability has been resolved:

drm/panthor: Prevent potential UAF in group creation

This commit prevents the possibility of a use after free issue in the
GROUP_CREATE ioctl function, which arose as pointer to the group is
accessed in that ioctl function after storing it in the Xarray.
A malicious userspace can second guess the handle of a group and try
to call GROUP_DESTROY ioctl from another thread around the same time
as GROUP_CREATE ioctl.

To prevent the use after free exploit, this commit uses a mark on an
entry of group pool Xarray which is added just before returning from
the GROUP_CREATE ioctl function. The mark is checked for all ioctls
that specify the group handle and so userspace won't be abe to delete
a group that isn't marked yet.

v2: Add R-bs and fixes tags</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-68608" data-description="missing authorization vulnerability in deluxethemes userpro userpro allows exploiting incorrectly configured access control security levels.this issue affects userpro: from n/a through <= 5.1.9.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-68608" target="_blank">CVE-2025-68608</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-12-24 07:16:28 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">N/A</span></p>
                    <p><span class="feed-label">CVSS Score:</span> N/A</p>
                    <p>Missing Authorization vulnerability in DeluxeThemes Userpro userpro allows Exploiting Incorrectly Configured Access Control Security Levels.This issue affects Userpro: from n/a through <= 5.1.9.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-68606" data-description="exposure of sensitive system information to an unauthorized control sphere vulnerability in wpxpo postx ultimate-post allows retrieve embedded sensitive data.this issue affects postx: from n/a through <= 5.0.3.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-68606" target="_blank">CVE-2025-68606</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-12-24 07:16:28 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">N/A</span></p>
                    <p><span class="feed-label">CVSS Score:</span> N/A</p>
                    <p>Exposure of Sensitive System Information to an Unauthorized Control Sphere vulnerability in WPXPO PostX ultimate-post allows Retrieve Embedded Sensitive Data.This issue affects PostX: from n/a through <= 5.0.3.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-68605" data-description="improper neutralization of input during web page generation ('cross-site scripting') vulnerability in pickplugins post grid and gutenberg blocks post-grid allows stored xss.this issue affects post grid and gutenberg blocks: from n/a through <= 2.3.18.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-68605" target="_blank">CVE-2025-68605</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-12-24 07:16:28 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">N/A</span></p>
                    <p><span class="feed-label">CVSS Score:</span> N/A</p>
                    <p>Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting') vulnerability in PickPlugins Post Grid and Gutenberg Blocks post-grid allows Stored XSS.This issue affects Post Grid and Gutenberg Blocks: from n/a through <= 2.3.18.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-68603" data-description="missing authorization vulnerability in marketing fire editorial calendar editorial-calendar allows exploiting incorrectly configured access control security levels.this issue affects editorial calendar: from n/a through <= 3.8.8.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-68603" target="_blank">CVE-2025-68603</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-12-24 07:16:27 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">N/A</span></p>
                    <p><span class="feed-label">CVSS Score:</span> N/A</p>
                    <p>Missing Authorization vulnerability in Marketing Fire Editorial Calendar editorial-calendar allows Exploiting Incorrectly Configured Access Control Security Levels.This issue affects Editorial Calendar: from n/a through <= 3.8.8.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-68602" data-description="url redirection to untrusted site ('open redirect') vulnerability in scott paterson accept donations with paypal easy-paypal-donation allows phishing.this issue affects accept donations with paypal: from n/a through <= 1.5.1.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-68602" target="_blank">CVE-2025-68602</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-12-24 07:16:27 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">N/A</span></p>
                    <p><span class="feed-label">CVSS Score:</span> N/A</p>
                    <p>URL Redirection to Untrusted Site ('Open Redirect') vulnerability in Scott Paterson Accept Donations with PayPal easy-paypal-donation allows Phishing.This issue affects Accept Donations with PayPal: from n/a through <= 1.5.1.</p>
                </div>
        
            </div>
        </div>

        <footer class="footer">
            <p>Â© 2025 dotne1 - Cybersecurity Portfolio</p>
        </footer>

        <script>
            function searchCVEs() {
                const input = document.getElementById('searchInput').value.toLowerCase();
                const cveEntries = document.getElementsByClassName('cve-entry');
                for (let i = 0; i < cveEntries.length; i++) {
                    const cveId = cveEntries[i].getAttribute('data-cve-id').toLowerCase();
                    const description = cveEntries[i].getAttribute('data-description');
                    if (cveId.includes(input) || description.includes(input)) {
                        cveEntries[i].style.display = '';
                    } else {
                        cveEntries[i].style.display = 'none';
                    }
                }
            }
        </script>
    </body>
    </html>
    