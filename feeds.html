
    <!DOCTYPE html>
    <html lang="en">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <meta name="description" content="Security alerts and cybersecurity news feeds">
        <meta name="keywords" content="cybersecurity news, security alerts, vulnerability feeds, threat intelligence">
        <meta name="author" content="dotne1">
        <meta property="og:title" content="Security Feeds - dotne1's Cybersecurity Portfolio">
        <meta property="og:description" content="Stay updated with the latest cybersecurity news and alerts">
        <meta property="og:type" content="website">
        <title>Security Feeds - dotne1's Cybersecurity Portfolio</title>
        <link rel="stylesheet" href="styles.css">
        <link rel="icon" type="image/x-icon" href="/favicon.ico">
    </head>
    <body>
        <nav class="navbar">
            <div class="nav-links">
                <a href="index.html" class="nav-link">Home</a>
                <a href="about-me.html" class="nav-link">About Me</a>
                <a href="projects.html" class="nav-link">Projects</a>
                <a href="resume.html" class="nav-link">Resume</a>
                <a href="feeds.html" class="nav-link">Feeds</a>
            </div>
        </nav>

        <div class="container" role="main">
            <h1 class="main-header">Security Feeds</h1>
            <div class="search-bar">
                <input type="text" id="searchInput" placeholder="Search CVEs..." onkeyup="searchCVEs()">
            </div>
            <div class="feed-preview" id="cveFeed">
                <div class="feed-header">Latest Vulnerabilities</div>
    
                <div class="cve-entry" data-cve-id="CVE-2025-58369" data-description="fs2 is a compositional, streaming i/o library for scala. versions 3.12.2 and lower and 3.13.0-m1 through 3.13.0-m6 is vulnerable to denial of service attacks though tls sessions using fs2-io on the jvm using the fs2.io.net.tls package. when establishing a tls session, if one side of the connection shuts down `write` while the peer side is awaiting more data to progress the tls handshake, the peer side will spin loop on the socket read, fully utilizing a cpu. the cpu is consumed until the overall connection is closed, potentially shutting down a fs2-io powered server. this issue is fixed in versions 3.12.1 and 3.13.0-m7.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-58369" target="_blank">CVE-2025-58369</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-09-05 17:15:34 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">MEDIUM</span></p>
                    <p><span class="feed-label">CVSS Score:</span> 5.3</p>
                    <p>fs2 is a compositional, streaming I/O library for Scala. Versions 3.12.2 and lower and 3.13.0-M1 through 3.13.0-M6 is vulnerable to denial of service attacks though TLS sessions using fs2-io on the JVM using the fs2.io.net.tls package. When establishing a TLS session, if one side of the connection shuts down `write` while the peer side is awaiting more data to progress the TLS handshake, the peer side will spin loop on the socket read, fully utilizing a CPU. The CPU is consumed until the overall connection is closed, potentially shutting down a fs2-io powered server. This issue is fixed in versions 3.12.1 and 3.13.0-M7.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-58367" data-description="deepdiff is a project focused on deep difference and search of any python data. versions 5.0.0 through 8.6.0 are vulnerable to class pollution via the delta class constructor, and when combined with a gadget available in deltadiff, it can lead to denial of service and remote code execution (via insecure pickle deserialization) exploitation. the gadget available in deepdiff allows `deepdiff.serialization.safe_to_import` to be modified to allow dangerous classes such as posix.system, and then perform insecure pickle deserialization via the delta class. this potentially allows any python code to be executed, given that the input to delta is user-controlled. depending on the application where deepdiff is used, this can also lead to other vulnerabilities. this is fixed in version 8.6.1.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-58367" target="_blank">CVE-2025-58367</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-09-05 17:15:34 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">N/A</span></p>
                    <p><span class="feed-label">CVSS Score:</span> N/A</p>
                    <p>DeepDiff is a project focused on Deep Difference and search of any Python data. Versions 5.0.0 through 8.6.0 are vulnerable to class pollution via the Delta class constructor, and when combined with a gadget available in DeltaDiff, it can lead to Denial of Service and Remote Code Execution (via insecure Pickle deserialization) exploitation. The gadget available in DeepDiff allows `deepdiff.serialization.SAFE_TO_IMPORT` to be modified to allow dangerous classes such as posix.system, and then perform insecure Pickle deserialization via the Delta class. This potentially allows any Python code to be executed, given that the input to Delta is user-controlled. Depending on the application where DeepDiff is used, this can also lead to other vulnerabilities. This is fixed in version 8.6.1.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-58366" data-description="onyxia is a data science environment for kubernetes. in versions 4.6.0 through 4.8.0, onyxia-api leaked the credentials of private helm repositories in the public (unauthenticated) /public/catalogs endpoint.vonly instances using private helm repositories (i.e setting username & password in the catalogs configuration) are affected. this is fixed in version 4.9.0.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-58366" target="_blank">CVE-2025-58366</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-09-05 17:15:34 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">N/A</span></p>
                    <p><span class="feed-label">CVSS Score:</span> N/A</p>
                    <p>Onyxia is a data science environment for kubernetes. In versions 4.6.0 through 4.8.0, Onyxia-API leaked the credentials of private helm repositories in the public (unauthenticated) /public/catalogs endpoint.vOnly instances using private helm repositories (i.e setting username & password in the catalogs configuration) are affected. This is fixed in version 4.9.0.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-57807" data-description="imagemagick is free and open-source software used for editing and manipulating digital images. imagemagick versions lower than 14.8.2 include  insecure functions: seekblob(), which permits advancing the stream offset beyond the current end without increasing capacity, and writeblob(), which then expands by quantum + length (amortized) instead of offset + length, and copies to data + offset. when offset ≫ extent, the copy targets memory beyond the allocation, producing a deterministic heap write on 64-bit builds. no 2⁶⁴ arithmetic wrap, external delegates, or policy settings are required. this is fixed in version 14.8.2.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-57807" target="_blank">CVE-2025-57807</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-09-05 17:15:34 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">LOW</span></p>
                    <p><span class="feed-label">CVSS Score:</span> 3.8</p>
                    <p>ImageMagick is free and open-source software used for editing and manipulating digital images. ImageMagick versions lower than 14.8.2 include  insecure functions: SeekBlob(), which permits advancing the stream offset beyond the current end without increasing capacity, and WriteBlob(), which then expands by quantum + length (amortized) instead of offset + length, and copies to data + offset. When offset ≫ extent, the copy targets memory beyond the allocation, producing a deterministic heap write on 64-bit builds. No 2⁶⁴ arithmetic wrap, external delegates, or policy settings are required. This is fixed in version 14.8.2.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-10027" data-description="a vulnerability was determined in itsourcecode pos point of sale system 1.0. affected by this issue is some unknown functionality of the file /inventory/main/vendors/datatables/unit_testing/templates/2512.php. this manipulation of the argument scripts causes cross site scripting. the attack can be initiated remotely. the exploit has been publicly disclosed and may be utilized.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-10027" target="_blank">CVE-2025-10027</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-09-05 17:15:34 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">LOW</span></p>
                    <p><span class="feed-label">CVSS Score:</span> 3.5</p>
                    <p>A vulnerability was determined in itsourcecode POS Point of Sale System 1.0. Affected by this issue is some unknown functionality of the file /inventory/main/vendors/datatables/unit_testing/templates/2512.php. This manipulation of the argument scripts causes cross site scripting. The attack can be initiated remotely. The exploit has been publicly disclosed and may be utilized.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-53791" data-description="improper access control in microsoft edge (chromium-based) allows an unauthorized attacker to bypass a security feature over a network.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-53791" target="_blank">CVE-2025-53791</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-09-05 16:15:38 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">MEDIUM</span></p>
                    <p><span class="feed-label">CVSS Score:</span> 4.7</p>
                    <p>Improper access control in Microsoft Edge (Chromium-based) allows an unauthorized attacker to bypass a security feature over a network.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-10061" data-description="an authorized user can cause a crash in the mongodb server through a specially crafted $group query. this vulnerability is related to the incorrect handling of certain accumulator functions when additional parameters are specified within the $group operation. this vulnerability could lead to denial of service if triggered repeatedly. this issue affects mongodb server v6.0 versions prior to 6.0.25, mongodb server v7.0 versions prior to 7.0.22, mongodb server v8.0 versions prior to 8.0.12 and mongodb server v8.1 versions prior to 8.1.2">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-10061" target="_blank">CVE-2025-10061</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-09-05 16:15:35 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">MEDIUM</span></p>
                    <p><span class="feed-label">CVSS Score:</span> 6.5</p>
                    <p>An authorized user can cause a crash in the MongoDB Server through a specially crafted $group query. This vulnerability is related to the incorrect handling of certain accumulator functions when additional parameters are specified within the $group operation. This vulnerability could lead to denial of service if triggered repeatedly. This issue affects MongoDB Server v6.0 versions prior to 6.0.25, MongoDB Server v7.0 versions prior to 7.0.22, MongoDB Server v8.0 versions prior to 8.0.12 and MongoDB Server v8.1 versions prior to 8.1.2</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-10060" data-description="mongodb server may allow upsert operations retried within a transaction to violate unique index constraints, potentially causing an invariant failure and server crash during commit. this issue may be triggered by improper writeunitofwork state management.  this issue affects mongodb server v6.0 versions prior to 6.0.25, mongodb server v7.0 versions prior to 7.0.22 and mongodb server v8.0 versions prior to 8.0.12">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-10060" target="_blank">CVE-2025-10060</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-09-05 16:15:34 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">MEDIUM</span></p>
                    <p><span class="feed-label">CVSS Score:</span> 6.5</p>
                    <p>MongoDB Server may allow upsert operations retried within a transaction to violate unique index constraints, potentially causing an invariant failure and server crash during commit. This issue may be triggered by improper WriteUnitOfWork state management.  This issue affects MongoDB Server v6.0 versions prior to 6.0.25, MongoDB Server v7.0 versions prior to 7.0.22 and MongoDB Server v8.0 versions prior to 8.0.12</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-10059" data-description="an improper setting of the lsid field on any sharded query can cause a crash in mongodb routers. this issue occurs when a generic argument (lsid) is provided in a case when it is not applicable. this affects mongodb server v6.0 versions prior to 6.0.x, mongodb server v7.0 versions prior to 7.0.18 and mongodb server v8.0 versions prior to 8.0.6.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-10059" target="_blank">CVE-2025-10059</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-09-05 16:15:34 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">MEDIUM</span></p>
                    <p><span class="feed-label">CVSS Score:</span> 6.5</p>
                    <p>An improper setting of the lsid field on any sharded query can cause a crash in MongoDB routers. This issue occurs when a generic argument (lsid) is provided in a case when it is not applicable. This affects MongoDB Server v6.0 versions prior to 6.0.x, MongoDB Server v7.0 versions prior to 7.0.18 and MongoDB Server v8.0 versions prior to 8.0.6.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-9566" data-description="there's a vulnerability in podman where an attacker may use the kube play command to overwrite host files when the kube file container a secrete or a configmap volume mount and such volume contains a symbolic link to a host file path. in a successful attack, the attacker can only control the target file to be overwritten but not the content to be written into the file.

binary-affected: podman
upstream-version-introduced: v4.0.0
upstream-version-fixed: v5.6.1">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-9566" target="_blank">CVE-2025-9566</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-09-05 15:15:36 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-online">HIGH</span></p>
                    <p><span class="feed-label">CVSS Score:</span> 8.1</p>
                    <p>There's a vulnerability in podman where an attacker may use the kube play command to overwrite host files when the kube file container a Secrete or a ConfigMap volume mount and such volume contains a symbolic link to a host file path. In a successful attack, the attacker can only control the target file to be overwritten but not the content to be written into the file.

Binary-Affected: podman
Upstream-version-introduced: v4.0.0
Upstream-version-fixed: v5.6.1</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-10044" data-description="a flaw was found in keycloak. keycloak’s account console and other pages accept arbitrary text in the error_description query parameter. this text is directly rendered in error pages without validation or sanitization. while html encoding prevents xss, an attacker can craft urls with misleading messages (e.g., fake support phone numbers or urls), which are displayed within the trusted keycloak ui. this creates a phishing vector, potentially tricking users into contacting malicious actors.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-10044" target="_blank">CVE-2025-10044</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-09-05 15:15:34 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">MEDIUM</span></p>
                    <p><span class="feed-label">CVSS Score:</span> 4.3</p>
                    <p>A flaw was found in Keycloak. Keycloak’s account console and other pages accept arbitrary text in the error_description query parameter. This text is directly rendered in error pages without validation or sanitization. While HTML encoding prevents XSS, an attacker can craft URLs with misleading messages (e.g., fake support phone numbers or URLs), which are displayed within the trusted Keycloak UI. This creates a phishing vector, potentially tricking users into contacting malicious actors.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-10043" data-description="a path traversal validation flaw exists in keycloak’s vault key handling on windows. the previous fix for cve-2024-10492 did not account for the windows file separator (\). as a result, a high-privilege administrator could probe for the existence of files outside the expected realm context through crafted vault secret lookups. this is a platform-specific variant/incomplete fix of cve-2024-10492.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-10043" target="_blank">CVE-2025-10043</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-09-05 15:15:34 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">LOW</span></p>
                    <p><span class="feed-label">CVSS Score:</span> 2.7</p>
                    <p>A path traversal validation flaw exists in Keycloak’s vault key handling on Windows. The previous fix for CVE-2024-10492 did not account for the Windows file separator (\). As a result, a high-privilege administrator could probe for the existence of files outside the expected realm context through crafted vault secret lookups. This is a platform-specific variant/incomplete fix of CVE-2024-10492.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-10026" data-description="a vulnerability was found in itsourcecode pos point of sale system 1.0. affected by this vulnerability is an unknown functionality of the file /inventory/main/vendors/datatables/unit_testing/templates/-complex_header.php. the manipulation of the argument scripts results in cross site scripting. it is possible to launch the attack remotely. the exploit has been made public and could be used.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-10026" target="_blank">CVE-2025-10026</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-09-05 15:15:33 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">LOW</span></p>
                    <p><span class="feed-label">CVSS Score:</span> 3.5</p>
                    <p>A vulnerability was found in itsourcecode POS Point of Sale System 1.0. Affected by this vulnerability is an unknown functionality of the file /inventory/main/vendors/datatables/unit_testing/templates/-complex_header.php. The manipulation of the argument scripts results in cross site scripting. It is possible to launch the attack remotely. The exploit has been made public and could be used.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-10025" data-description="a vulnerability has been found in phpgurukul online course registration 3.1. affected is an unknown function of the file /admin/semester.php. the manipulation of the argument semester leads to sql injection. it is possible to initiate the attack remotely. the exploit has been disclosed to the public and may be used.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-10025" target="_blank">CVE-2025-10025</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-09-05 15:15:33 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-online">HIGH</span></p>
                    <p><span class="feed-label">CVSS Score:</span> 7.3</p>
                    <p>A vulnerability has been found in PHPGurukul Online Course Registration 3.1. Affected is an unknown function of the file /admin/semester.php. The manipulation of the argument semester leads to sql injection. It is possible to initiate the attack remotely. The exploit has been disclosed to the public and may be used.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-9057" data-description="the biagiotti core plugin for wordpress is vulnerable to stored cross-site scripting via shortcodes in versions up to, and including, 2.1.3 due to insufficient input sanitization and output escaping on user supplied attributes. this makes it possible for authenticated attackers with contributor-level and above permissions to inject arbitrary web scripts in pages that will execute whenever a user accesses an injected page.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-9057" target="_blank">CVE-2025-9057</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-09-05 14:15:33 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">MEDIUM</span></p>
                    <p><span class="feed-label">CVSS Score:</span> 6.4</p>
                    <p>The Biagiotti Core plugin for WordPress is vulnerable to Stored Cross-Site Scripting via shortcodes in versions up to, and including, 2.1.3 due to insufficient input sanitization and output escaping on user supplied attributes. This makes it possible for authenticated attackers with contributor-level and above permissions to inject arbitrary web scripts in pages that will execute whenever a user accesses an injected page.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-9709" data-description="on-chip debug and test interface with improper access control and improper protection against electromagnetic fault injection (em-fi) in nordic semiconductor nrf52810 allow attacker to perform em fault injection and bypass approtect at runtime, requiring the least amount of modification to the hardware system possible.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-9709" target="_blank">CVE-2025-9709</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-09-05 13:15:50 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">N/A</span></p>
                    <p><span class="feed-label">CVSS Score:</span> N/A</p>
                    <p>On-Chip Debug and Test Interface With Improper Access Control and Improper Protection against Electromagnetic Fault Injection (EM-FI) in Nordic Semiconductor nRF52810 allow attacker to perform EM Fault Injection and bypass APPROTECT at runtime, requiring the least amount of modification to the hardware system possible.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-39726" data-description="in the linux kernel, the following vulnerability has been resolved:

s390/ism: fix concurrency management in ism_cmd()

the s390x ism device data sheet clearly states that only one
request-response sequence is allowable per ism function at any point in
time.  unfortunately as of today the s390/ism driver in linux does not
honor that requirement. this patch aims to rectify that.

this problem was discovered based on aliaksei's bug report which states
that for certain workloads the ism functions end up entering error state
(with pec 2 as seen from the logs) after a while and as a consequence
connections handled by the respective function break, and for future
connection requests the ism device is not considered -- given it is in a
dysfunctional state. during further debugging pec 3a was observed as
well.

a kernel message like
[ 1211.244319] zpci: 061a:00:00.0: event 0x2 reports an error for pci function 0x61a
is a reliable indicator of the stated function entering error state
with pec 2. let me also point out that a kernel message like
[ 1211.244325] zpci: 061a:00:00.0: the ism driver bound to the device does not support error recovery
is a reliable indicator that the ism function won't be auto-recovered
because the ism driver currently lacks support for it.

on a technical level, without this synchronization, commands (inputs to
the fw) may be partially or fully overwritten (corrupted) by another cpu
trying to issue commands on the same function. there is hard evidence that
this can lead to dmb token values being used as dmb iovas, leading to
pec 2 pci events indicating invalid dma. but this is only one of the
failure modes imaginable. in theory even completely losing one command
and executing another one twice and then trying to interpret the outputs
as if the command we intended to execute was actually executed and not
the other one is also possible.  frankly, i don't feel confident about
providing an exhaustive list of possible consequences.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-39726" target="_blank">CVE-2025-39726</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-09-05 13:15:50 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">N/A</span></p>
                    <p><span class="feed-label">CVSS Score:</span> N/A</p>
                    <p>In the Linux kernel, the following vulnerability has been resolved:

s390/ism: fix concurrency management in ism_cmd()

The s390x ISM device data sheet clearly states that only one
request-response sequence is allowable per ISM function at any point in
time.  Unfortunately as of today the s390/ism driver in Linux does not
honor that requirement. This patch aims to rectify that.

This problem was discovered based on Aliaksei's bug report which states
that for certain workloads the ISM functions end up entering error state
(with PEC 2 as seen from the logs) after a while and as a consequence
connections handled by the respective function break, and for future
connection requests the ISM device is not considered -- given it is in a
dysfunctional state. During further debugging PEC 3A was observed as
well.

A kernel message like
[ 1211.244319] zpci: 061a:00:00.0: Event 0x2 reports an error for PCI function 0x61a
is a reliable indicator of the stated function entering error state
with PEC 2. Let me also point out that a kernel message like
[ 1211.244325] zpci: 061a:00:00.0: The ism driver bound to the device does not support error recovery
is a reliable indicator that the ISM function won't be auto-recovered
because the ISM driver currently lacks support for it.

On a technical level, without this synchronization, commands (inputs to
the FW) may be partially or fully overwritten (corrupted) by another CPU
trying to issue commands on the same function. There is hard evidence that
this can lead to DMB token values being used as DMB IOVAs, leading to
PEC 2 PCI events indicating invalid DMA. But this is only one of the
failure modes imaginable. In theory even completely losing one command
and executing another one twice and then trying to interpret the outputs
as if the command we intended to execute was actually executed and not
the other one is also possible.  Frankly, I don't feel confident about
providing an exhaustive list of possible consequences.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-39725" data-description="in the linux kernel, the following vulnerability has been resolved:

mm/vmscan: fix hwpoisoned large folio handling in shrink_folio_list

in shrink_folio_list(), the hwpoisoned folio may be large folio, which
can't be handled by unmap_poisoned_folio().  for thp, try_to_unmap_one()
must be passed with ttu_split_huge_pmd to split huge pmd first and then
retry.  without ttu_split_huge_pmd, we will trigger null-ptr deref of
pvmw.pte.  even we passed ttu_split_huge_pmd, we will trigger a
warn_on_once due to the page isn't in swapcache.

since uce is rare in real world, and race with reclaimation is more rare,
just skipping the hwpoisoned large folio is enough.  memory_failure() will
handle it if the uce is triggered again.

this happens when memory reclaim for large folio races with
memory_failure(), and will lead to kernel panic.  the race is as
follows:

cpu0      cpu1
 shrink_folio_list memory_failure
  testsetpagehwpoison
  unmap_poisoned_folio
  --> trigger bug_on due to
  unmap_poisoned_folio couldn't
   handle large folio

[tujinjiang@huawei.com: add comment to unmap_poisoned_folio()]">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-39725" target="_blank">CVE-2025-39725</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-09-05 13:15:50 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">N/A</span></p>
                    <p><span class="feed-label">CVSS Score:</span> N/A</p>
                    <p>In the Linux kernel, the following vulnerability has been resolved:

mm/vmscan: fix hwpoisoned large folio handling in shrink_folio_list

In shrink_folio_list(), the hwpoisoned folio may be large folio, which
can't be handled by unmap_poisoned_folio().  For THP, try_to_unmap_one()
must be passed with TTU_SPLIT_HUGE_PMD to split huge PMD first and then
retry.  Without TTU_SPLIT_HUGE_PMD, we will trigger null-ptr deref of
pvmw.pte.  Even we passed TTU_SPLIT_HUGE_PMD, we will trigger a
WARN_ON_ONCE due to the page isn't in swapcache.

Since UCE is rare in real world, and race with reclaimation is more rare,
just skipping the hwpoisoned large folio is enough.  memory_failure() will
handle it if the UCE is triggered again.

This happens when memory reclaim for large folio races with
memory_failure(), and will lead to kernel panic.  The race is as
follows:

cpu0      cpu1
 shrink_folio_list memory_failure
  TestSetPageHWPoison
  unmap_poisoned_folio
  --> trigger BUG_ON due to
  unmap_poisoned_folio couldn't
   handle large folio

[tujinjiang@huawei.com: add comment to unmap_poisoned_folio()]</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-39724" data-description="in the linux kernel, the following vulnerability has been resolved:

serial: 8250: fix panic due to pslverr

when the pslverr_resp_en parameter is set to 1, the device generates
an error response if an attempt is made to read an empty rbr (receive
buffer register) while the fifo is enabled.

in serial8250_do_startup(), calling serial_port_out(port, uart_lcr,
uart_lcr_wlen8) triggers dw8250_check_lcr(), which invokes
dw8250_force_idle() and serial8250_clear_and_reinit_fifos(). the latter
function enables the fifo via serial_out(p, uart_fcr, p->fcr).
execution proceeds to the serial_port_in(port, uart_rx).
this satisfies the pslverr trigger condition.

when another cpu (e.g., using printk()) is accessing the uart (uart
is busy), the current cpu fails the check (value & ~uart_lcr_spar) ==
(lcr & ~uart_lcr_spar) in dw8250_check_lcr(), causing it to enter
dw8250_force_idle().

put serial_port_out(port, uart_lcr, uart_lcr_wlen8) under the port->lock
to fix this issue.

panic backtrace:
[    0.442336] oops - unknown exception [#1]
[    0.442343] epc : dw8250_serial_in32+0x1e/0x4a
[    0.442351]  ra : serial8250_do_startup+0x2c8/0x88e
...
[    0.442416] console_on_rootfs+0x26/0x70">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-39724" target="_blank">CVE-2025-39724</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-09-05 13:15:50 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">N/A</span></p>
                    <p><span class="feed-label">CVSS Score:</span> N/A</p>
                    <p>In the Linux kernel, the following vulnerability has been resolved:

serial: 8250: fix panic due to PSLVERR

When the PSLVERR_RESP_EN parameter is set to 1, the device generates
an error response if an attempt is made to read an empty RBR (Receive
Buffer Register) while the FIFO is enabled.

In serial8250_do_startup(), calling serial_port_out(port, UART_LCR,
UART_LCR_WLEN8) triggers dw8250_check_lcr(), which invokes
dw8250_force_idle() and serial8250_clear_and_reinit_fifos(). The latter
function enables the FIFO via serial_out(p, UART_FCR, p->fcr).
Execution proceeds to the serial_port_in(port, UART_RX).
This satisfies the PSLVERR trigger condition.

When another CPU (e.g., using printk()) is accessing the UART (UART
is busy), the current CPU fails the check (value & ~UART_LCR_SPAR) ==
(lcr & ~UART_LCR_SPAR) in dw8250_check_lcr(), causing it to enter
dw8250_force_idle().

Put serial_port_out(port, UART_LCR, UART_LCR_WLEN8) under the port->lock
to fix this issue.

Panic backtrace:
[    0.442336] Oops - unknown exception [#1]
[    0.442343] epc : dw8250_serial_in32+0x1e/0x4a
[    0.442351]  ra : serial8250_do_startup+0x2c8/0x88e
...
[    0.442416] console_on_rootfs+0x26/0x70</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-39723" data-description="in the linux kernel, the following vulnerability has been resolved:

netfs: fix unbuffered write error handling

if all the subrequests in an unbuffered write stream fail, the subrequest
collector doesn't update the stream->transferred value and it retains its
initial long_max value.  unfortunately, if all active streams fail, then we
take the smallest value of { long_max, long_max, ... } as the value to set
in wreq->transferred - which is then returned from ->write_iter().

long_max was chosen as the initial value so that all the streams can be
quickly assessed by taking the smallest value of all stream->transferred -
but this only works if we've set any of them.

fix this by adding a flag to indicate whether the value in
stream->transferred is valid and checking that when we integrate the
values.  stream->transferred can then be initialised to zero.

this was found by running the generic/750 xfstest against cifs with
cache=none.  it splices data to the target file.  once (if) it has used up
all the available scratch space, the writes start failing with enospc.
this causes ->write_iter() to fail.  however, it was returning
wreq->transferred, i.e. long_max, rather than an error (because it thought
the amount transferred was non-zero) and iter_file_splice_write() would
then try to clean up that amount of pipe bufferage - leading to an oops
when it overran.  the kernel log showed:

    cifs: vfs: send error in write = -28

followed by:

    bug: kernel null pointer dereference, address: 0000000000000008

with:

    rip: 0010:iter_file_splice_write+0x3a4/0x520
    do_splice+0x197/0x4e0

or:

    rip: 0010:pipe_buf_release (include/linux/pipe_fs_i.h:282)
    iter_file_splice_write (fs/splice.c:755)

also put a warning check into splice to announce if ->write_iter() returned
that it had written more than it was asked to.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-39723" target="_blank">CVE-2025-39723</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-09-05 13:15:50 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">N/A</span></p>
                    <p><span class="feed-label">CVSS Score:</span> N/A</p>
                    <p>In the Linux kernel, the following vulnerability has been resolved:

netfs: Fix unbuffered write error handling

If all the subrequests in an unbuffered write stream fail, the subrequest
collector doesn't update the stream->transferred value and it retains its
initial LONG_MAX value.  Unfortunately, if all active streams fail, then we
take the smallest value of { LONG_MAX, LONG_MAX, ... } as the value to set
in wreq->transferred - which is then returned from ->write_iter().

LONG_MAX was chosen as the initial value so that all the streams can be
quickly assessed by taking the smallest value of all stream->transferred -
but this only works if we've set any of them.

Fix this by adding a flag to indicate whether the value in
stream->transferred is valid and checking that when we integrate the
values.  stream->transferred can then be initialised to zero.

This was found by running the generic/750 xfstest against cifs with
cache=none.  It splices data to the target file.  Once (if) it has used up
all the available scratch space, the writes start failing with ENOSPC.
This causes ->write_iter() to fail.  However, it was returning
wreq->transferred, i.e. LONG_MAX, rather than an error (because it thought
the amount transferred was non-zero) and iter_file_splice_write() would
then try to clean up that amount of pipe bufferage - leading to an oops
when it overran.  The kernel log showed:

    CIFS: VFS: Send error in write = -28

followed by:

    BUG: kernel NULL pointer dereference, address: 0000000000000008

with:

    RIP: 0010:iter_file_splice_write+0x3a4/0x520
    do_splice+0x197/0x4e0

or:

    RIP: 0010:pipe_buf_release (include/linux/pipe_fs_i.h:282)
    iter_file_splice_write (fs/splice.c:755)

Also put a warning check into splice to announce if ->write_iter() returned
that it had written more than it was asked to.</p>
                </div>
        
            </div>
        </div>

        <footer class="footer">
            <p>© 2025 dotne1 - Cybersecurity Portfolio</p>
        </footer>

        <script>
            function searchCVEs() {
                const input = document.getElementById('searchInput').value.toLowerCase();
                const cveEntries = document.getElementsByClassName('cve-entry');
                for (let i = 0; i < cveEntries.length; i++) {
                    const cveId = cveEntries[i].getAttribute('data-cve-id').toLowerCase();
                    const description = cveEntries[i].getAttribute('data-description');
                    if (cveId.includes(input) || description.includes(input)) {
                        cveEntries[i].style.display = '';
                    } else {
                        cveEntries[i].style.display = 'none';
                    }
                }
            }
        </script>
    </body>
    </html>
    