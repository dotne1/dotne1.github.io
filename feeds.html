
    <!DOCTYPE html>
    <html lang="en">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <meta name="description" content="Security alerts and cybersecurity news feeds">
        <meta name="keywords" content="cybersecurity news, security alerts, vulnerability feeds, threat intelligence">
        <meta name="author" content="dotne1">
        <meta property="og:title" content="Security Feeds - dotne1's Cybersecurity Portfolio">
        <meta property="og:description" content="Stay updated with the latest cybersecurity news and alerts">
        <meta property="og:type" content="website">
        <title>Security Feeds - dotne1's Cybersecurity Portfolio</title>
        <link rel="stylesheet" href="styles.css">
        <link rel="icon" type="image/x-icon" href="/favicon.ico">
    </head>
    <body>
        <nav class="navbar">
            <div class="nav-links">
                <a href="index.html" class="nav-link">Home</a>
                <a href="about-me.html" class="nav-link">About Me</a>
                <a href="projects.html" class="nav-link">Projects</a>
                <a href="resume.html" class="nav-link">Resume</a>
                <a href="feeds.html" class="nav-link">Feeds</a>
            </div>
        </nav>

        <div class="container" role="main">
            <h1 class="main-header">Security Feeds</h1>
            <div class="search-bar">
                <input type="text" id="searchInput" placeholder="Search CVEs..." onkeyup="searchCVEs()">
            </div>
            <div class="feed-preview" id="cveFeed">
                <div class="feed-header">Latest Vulnerabilities</div>
    
                <div class="cve-entry" data-cve-id="CVE-2025-68750" data-description="in the linux kernel, the following vulnerability has been resolved:

usb: potential integer overflow in usbg_make_tpg()

the variable tpgt in usbg_make_tpg() is defined as unsigned long and is
assigned to tpgt->tport_tpgt, which is defined as u16. this may cause an
integer overflow when tpgt is greater than ushrt_max (65535). i
haven't tried to trigger it myself, but it is possible to trigger it
by calling usbg_make_tpg() with a large value for tpgt.

i modified the type of tpgt to match tpgt->tport_tpgt and adjusted the
relevant code accordingly.

this patch is similar to commit 59c816c1f24d ("vhost/scsi: potential
memory corruption").">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-68750" target="_blank">CVE-2025-68750</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-12-24 10:15:48 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">N/A</span></p>
                    <p><span class="feed-label">CVSS Score:</span> N/A</p>
                    <p>In the Linux kernel, the following vulnerability has been resolved:

usb: potential integer overflow in usbg_make_tpg()

The variable tpgt in usbg_make_tpg() is defined as unsigned long and is
assigned to tpgt->tport_tpgt, which is defined as u16. This may cause an
integer overflow when tpgt is greater than USHRT_MAX (65535). I
haven't tried to trigger it myself, but it is possible to trigger it
by calling usbg_make_tpg() with a large value for tpgt.

I modified the type of tpgt to match tpgt->tport_tpgt and adjusted the
relevant code accordingly.

This patch is similar to commit 59c816c1f24d ("vhost/scsi: potential
memory corruption").</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-43876" data-description="under certain circumstances a successful exploitation could result in access to the device.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-43876" target="_blank">CVE-2025-43876</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-12-24 10:15:48 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">N/A</span></p>
                    <p><span class="feed-label">CVSS Score:</span> N/A</p>
                    <p>Under certain circumstances a successful exploitation could result in access to the device.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-43875" data-description="under certain circumstances a successful exploitation could result in access to the device.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-43875" target="_blank">CVE-2025-43875</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-12-24 10:15:48 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">N/A</span></p>
                    <p><span class="feed-label">CVSS Score:</span> N/A</p>
                    <p>Under certain circumstances a successful exploitation could result in access to the device.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2024-40317" data-description="a reflected cross-site scripting (xss) vulnerability in mynet up to v26.08 allows attackers to execute arbitrary code in the context of a user's browser via injecting a crafted payload into the parameter http.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2024-40317" target="_blank">CVE-2024-40317</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-12-24 10:15:47 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">N/A</span></p>
                    <p><span class="feed-label">CVSS Score:</span> N/A</p>
                    <p>A reflected cross-site scripting (XSS) vulnerability in MyNET up to v26.08 allows attackers to execute arbitrary code in the context of a user's browser via injecting a crafted payload into the parameter HTTP.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2024-39037" data-description="mynet up to v26.08.316 was discovered to contain an unauthenticated sql injection vulnerability via the intmenu parameter.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2024-39037" target="_blank">CVE-2024-39037</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-12-24 10:15:47 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">N/A</span></p>
                    <p><span class="feed-label">CVSS Score:</span> N/A</p>
                    <p>MyNET up to v26.08.316 was discovered to contain an Unauthenticated SQL Injection vulnerability via the intmenu parameter.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2024-35322" data-description="mynet up to v26.08 was discovered to contain a reflected cross-site scripting (xss) vulnerability via the ficheiro parameter.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2024-35322" target="_blank">CVE-2024-35322</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-12-24 10:15:46 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">N/A</span></p>
                    <p><span class="feed-label">CVSS Score:</span> N/A</p>
                    <p>MyNET up to v26.08 was discovered to contain a reflected cross-site scripting (XSS) vulnerability via the ficheiro parameter.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-60935" data-description="an open redirect vulnerability in the login endpoint of blitz panel v1.17.0 allows attackers to redirect users to malicious domains via a crafted url. this issue affects the next_url parameter in the login endpoint and could lead to phishing or token theft after successful authentication.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-60935" target="_blank">CVE-2025-60935</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-12-24 09:16:01 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">N/A</span></p>
                    <p><span class="feed-label">CVSS Score:</span> N/A</p>
                    <p>An open redirect vulnerability in the login endpoint of Blitz Panel v1.17.0 allows attackers to redirect users to malicious domains via a crafted URL. This issue affects the next_url parameter in the login endpoint and could lead to phishing or token theft after successful authentication.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-2155" data-description="unrestricted upload of file with dangerous type vulnerability in echo call center services trade and industry inc. specto cm allows remote code inclusion.this issue affects specto cm: before 17032025.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-2155" target="_blank">CVE-2025-2155</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-12-24 09:16:01 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-online">HIGH</span></p>
                    <p><span class="feed-label">CVSS Score:</span> 8.8</p>
                    <p>Unrestricted Upload of File with Dangerous Type vulnerability in Echo Call Center Services Trade and Industry Inc. Specto CM allows Remote Code Inclusion.This issue affects Specto CM: before 17032025.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-2154" data-description="improper neutralization of input during web page generation (xss or 'cross-site scripting') vulnerability in echo call center services trade and industry inc. specto cm allows stored xss.this issue affects specto cm: before 17032025.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-2154" target="_blank">CVE-2025-2154</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-12-24 09:16:00 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">MEDIUM</span></p>
                    <p><span class="feed-label">CVSS Score:</span> 5.4</p>
                    <p>Improper Neutralization of Input During Web Page Generation (XSS or 'Cross-site Scripting') vulnerability in Echo Call Center Services Trade and Industry Inc. Specto CM allows Stored XSS.This issue affects Specto CM: before 17032025.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-5448" data-description="rejected reason: this cve id was assigned but later discarded.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-5448" target="_blank">CVE-2025-5448</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-12-24 08:15:47 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">N/A</span></p>
                    <p><span class="feed-label">CVSS Score:</span> N/A</p>
                    <p>Rejected reason: This CVE id was assigned but later discarded.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-68749" data-description="in the linux kernel, the following vulnerability has been resolved:

accel/ivpu: fix race condition when unbinding bos

fix 'memory manager not clean during takedown' warning that occurs
when ivpu_gem_bo_free() removes the bo from the bos list before it
gets unmapped. then file_priv_unbind() triggers a warning in
drm_mm_takedown() during context teardown.

protect the unmapping sequence with bo_list_lock to ensure the bo is
always fully unmapped when removed from the list. this ensures the bo
is either fully unmapped at context teardown time or present on the
list and unmapped by file_priv_unbind().">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-68749" target="_blank">CVE-2025-68749</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-12-24 07:16:29 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">N/A</span></p>
                    <p><span class="feed-label">CVSS Score:</span> N/A</p>
                    <p>In the Linux kernel, the following vulnerability has been resolved:

accel/ivpu: Fix race condition when unbinding BOs

Fix 'Memory manager not clean during takedown' warning that occurs
when ivpu_gem_bo_free() removes the BO from the BOs list before it
gets unmapped. Then file_priv_unbind() triggers a warning in
drm_mm_takedown() during context teardown.

Protect the unmapping sequence with bo_list_lock to ensure the BO is
always fully unmapped when removed from the list. This ensures the BO
is either fully unmapped at context teardown time or present on the
list and unmapped by file_priv_unbind().</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-68748" data-description="in the linux kernel, the following vulnerability has been resolved:

drm/panthor: fix uaf race between device unplug and fw event processing

the function panthor_fw_unplug() will free the fw memory sections.
the problem is that there could still be pending fw events which are yet
not handled at this point. process_fw_events_work() can in this case try
to access said freed memory.

simply call disable_work_sync() to both drain and prevent future
invocation of process_fw_events_work().">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-68748" target="_blank">CVE-2025-68748</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-12-24 07:16:29 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">N/A</span></p>
                    <p><span class="feed-label">CVSS Score:</span> N/A</p>
                    <p>In the Linux kernel, the following vulnerability has been resolved:

drm/panthor: Fix UAF race between device unplug and FW event processing

The function panthor_fw_unplug() will free the FW memory sections.
The problem is that there could still be pending FW events which are yet
not handled at this point. process_fw_events_work() can in this case try
to access said freed memory.

Simply call disable_work_sync() to both drain and prevent future
invocation of process_fw_events_work().</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-68747" data-description="in the linux kernel, the following vulnerability has been resolved:

drm/panthor: fix uaf on kernel bo va nodes

if the mmu is down, panthor_vm_unmap_range() might return an error.
we expect the page table to be updated still, and if the mmu is blocked,
the rest of the gpu should be blocked too, so no risk of accessing
physical memory returned to the system (which the current code doesn't
cover for anyway).

proceed with the rest of the cleanup instead of bailing out and leaving
the va_node inserted in the drm_mm, which leads to uaf when other
adjacent nodes are removed from the drm_mm tree.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-68747" target="_blank">CVE-2025-68747</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-12-24 07:16:29 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">N/A</span></p>
                    <p><span class="feed-label">CVSS Score:</span> N/A</p>
                    <p>In the Linux kernel, the following vulnerability has been resolved:

drm/panthor: Fix UAF on kernel BO VA nodes

If the MMU is down, panthor_vm_unmap_range() might return an error.
We expect the page table to be updated still, and if the MMU is blocked,
the rest of the GPU should be blocked too, so no risk of accessing
physical memory returned to the system (which the current code doesn't
cover for anyway).

Proceed with the rest of the cleanup instead of bailing out and leaving
the va_node inserted in the drm_mm, which leads to UAF when other
adjacent nodes are removed from the drm_mm tree.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-68746" data-description="in the linux kernel, the following vulnerability has been resolved:

spi: tegra210-quad: fix timeout handling

when the cpu that the qspi interrupt handler runs on (typically cpu 0)
is excessively busy, it can lead to rare cases of the irq thread not
running before the transfer timeout is reached.

while handling the timeouts, any pending transfers are cleaned up and
the message that they correspond to is marked as failed, which leaves
the curr_xfer field pointing at stale memory.

to avoid this, clear curr_xfer to null upon timeout and check for this
condition when the irq thread is finally run.

while at it, also make sure to clear interrupts on failure so that new
interrupts can be run.

a better, more involved, fix would move the interrupt clearing into a
hard irq handler. ideally we would also want to signal that the irq
thread no longer needs to be run after the timeout is hit to avoid the
extra check for a valid transfer.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-68746" target="_blank">CVE-2025-68746</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-12-24 07:16:29 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">N/A</span></p>
                    <p><span class="feed-label">CVSS Score:</span> N/A</p>
                    <p>In the Linux kernel, the following vulnerability has been resolved:

spi: tegra210-quad: Fix timeout handling

When the CPU that the QSPI interrupt handler runs on (typically CPU 0)
is excessively busy, it can lead to rare cases of the IRQ thread not
running before the transfer timeout is reached.

While handling the timeouts, any pending transfers are cleaned up and
the message that they correspond to is marked as failed, which leaves
the curr_xfer field pointing at stale memory.

To avoid this, clear curr_xfer to NULL upon timeout and check for this
condition when the IRQ thread is finally run.

While at it, also make sure to clear interrupts on failure so that new
interrupts can be run.

A better, more involved, fix would move the interrupt clearing into a
hard IRQ handler. Ideally we would also want to signal that the IRQ
thread no longer needs to be run after the timeout is hit to avoid the
extra check for a valid transfer.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-68745" data-description="in the linux kernel, the following vulnerability has been resolved:

scsi: qla2xxx: clear cmds after chip reset

commit aefed3e5548f ("scsi: qla2xxx: target: fix offline port handling
and host reset handling") caused two problems:

1. commands sent to fw, after chip reset got stuck and never freed as fw
   is not going to respond to them anymore.

2. bug_on(cmd->sg_mapped) in qlt_free_cmd().  commit 26f9ce53817a
   ("scsi: qla2xxx: fix missed dma unmap for aborted commands")
   attempted to fix this, but introduced another bug under different
   circumstances when two different cpus were racing to call
   qlt_unmap_sg() at the same time: bug_on(!valid_dma_direction(dir)) in
   dma_unmap_sg_attrs().

so revert "scsi: qla2xxx: fix missed dma unmap for aborted commands" and
partially revert "scsi: qla2xxx: target: fix offline port handling and
host reset handling" at __qla2x00_abort_all_cmds.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-68745" target="_blank">CVE-2025-68745</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-12-24 07:16:29 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">N/A</span></p>
                    <p><span class="feed-label">CVSS Score:</span> N/A</p>
                    <p>In the Linux kernel, the following vulnerability has been resolved:

scsi: qla2xxx: Clear cmds after chip reset

Commit aefed3e5548f ("scsi: qla2xxx: target: Fix offline port handling
and host reset handling") caused two problems:

1. Commands sent to FW, after chip reset got stuck and never freed as FW
   is not going to respond to them anymore.

2. BUG_ON(cmd->sg_mapped) in qlt_free_cmd().  Commit 26f9ce53817a
   ("scsi: qla2xxx: Fix missed DMA unmap for aborted commands")
   attempted to fix this, but introduced another bug under different
   circumstances when two different CPUs were racing to call
   qlt_unmap_sg() at the same time: BUG_ON(!valid_dma_direction(dir)) in
   dma_unmap_sg_attrs().

So revert "scsi: qla2xxx: Fix missed DMA unmap for aborted commands" and
partially revert "scsi: qla2xxx: target: Fix offline port handling and
host reset handling" at __qla2x00_abort_all_cmds.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-68744" data-description="in the linux kernel, the following vulnerability has been resolved:

bpf: free special fields when update [lru_,]percpu_hash maps

as [lru_,]percpu_hash maps support bpf_kptr_{ref,percpu}, missing
calls to 'bpf_obj_free_fields()' in 'pcpu_copy_value()' could cause the
memory referenced by bpf_kptr_{ref,percpu} fields to be held until the
map gets freed.

fix this by calling 'bpf_obj_free_fields()' after
'copy_map_value[,_long]()' in 'pcpu_copy_value()'.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-68744" target="_blank">CVE-2025-68744</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-12-24 07:16:29 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">N/A</span></p>
                    <p><span class="feed-label">CVSS Score:</span> N/A</p>
                    <p>In the Linux kernel, the following vulnerability has been resolved:

bpf: Free special fields when update [lru_,]percpu_hash maps

As [lru_,]percpu_hash maps support BPF_KPTR_{REF,PERCPU}, missing
calls to 'bpf_obj_free_fields()' in 'pcpu_copy_value()' could cause the
memory referenced by BPF_KPTR_{REF,PERCPU} fields to be held until the
map gets freed.

Fix this by calling 'bpf_obj_free_fields()' after
'copy_map_value[,_long]()' in 'pcpu_copy_value()'.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-68743" data-description="in the linux kernel, the following vulnerability has been resolved:

mshv: fix create memory region overlap check

the current check is incorrect; it only checks if the beginning or end
of a region is within an existing region. this doesn't account for
userspace specifying a region that begins before and ends after an
existing region.

change the logic to a range intersection check against gfns and uaddrs
for each region.

remove mshv_partition_region_by_uaddr() as it is no longer used.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-68743" target="_blank">CVE-2025-68743</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-12-24 07:16:29 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">N/A</span></p>
                    <p><span class="feed-label">CVSS Score:</span> N/A</p>
                    <p>In the Linux kernel, the following vulnerability has been resolved:

mshv: Fix create memory region overlap check

The current check is incorrect; it only checks if the beginning or end
of a region is within an existing region. This doesn't account for
userspace specifying a region that begins before and ends after an
existing region.

Change the logic to a range intersection check against gfns and uaddrs
for each region.

Remove mshv_partition_region_by_uaddr() as it is no longer used.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-68742" data-description="in the linux kernel, the following vulnerability has been resolved:

bpf: fix invalid prog->stats access when update_effective_progs fails

syzkaller triggers an invalid memory access issue following fault
injection in update_effective_progs. the issue can be described as
follows:

__cgroup_bpf_detach
  update_effective_progs
    compute_effective_progs
      bpf_prog_array_alloc <-- fault inject
  purge_effective_progs
    /* change to dummy_bpf_prog */
    array->items[index] = &dummy_bpf_prog.prog

---softirq start---
__do_softirq
  ...
    __cgroup_bpf_run_filter_skb
      __bpf_prog_run_save_cb
        bpf_prog_run
          stats = this_cpu_ptr(prog->stats)
          /* invalid memory access */
          flags = u64_stats_update_begin_irqsave(&stats->syncp)
---softirq end---

  static_branch_dec(&cgroup_bpf_enabled_key[atype])

the reason is that fault injection caused update_effective_progs to fail
and then changed the original prog into dummy_bpf_prog.prog in
purge_effective_progs. then a softirq came, and accessing the members of
dummy_bpf_prog.prog in the softirq triggers invalid mem access.

to fix it, skip updating stats when stats is null.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-68742" target="_blank">CVE-2025-68742</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-12-24 07:16:29 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">N/A</span></p>
                    <p><span class="feed-label">CVSS Score:</span> N/A</p>
                    <p>In the Linux kernel, the following vulnerability has been resolved:

bpf: Fix invalid prog->stats access when update_effective_progs fails

Syzkaller triggers an invalid memory access issue following fault
injection in update_effective_progs. The issue can be described as
follows:

__cgroup_bpf_detach
  update_effective_progs
    compute_effective_progs
      bpf_prog_array_alloc <-- fault inject
  purge_effective_progs
    /* change to dummy_bpf_prog */
    array->items[index] = &dummy_bpf_prog.prog

---softirq start---
__do_softirq
  ...
    __cgroup_bpf_run_filter_skb
      __bpf_prog_run_save_cb
        bpf_prog_run
          stats = this_cpu_ptr(prog->stats)
          /* invalid memory access */
          flags = u64_stats_update_begin_irqsave(&stats->syncp)
---softirq end---

  static_branch_dec(&cgroup_bpf_enabled_key[atype])

The reason is that fault injection caused update_effective_progs to fail
and then changed the original prog into dummy_bpf_prog.prog in
purge_effective_progs. Then a softirq came, and accessing the members of
dummy_bpf_prog.prog in the softirq triggers invalid mem access.

To fix it, skip updating stats when stats is NULL.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-68741" data-description="in the linux kernel, the following vulnerability has been resolved:

scsi: qla2xxx: fix improper freeing of purex item

in qla2xxx_process_purls_iocb(), an item is allocated via
qla27xx_copy_multiple_pkt(), which internally calls
qla24xx_alloc_purex_item().

the qla24xx_alloc_purex_item() function may return a pre-allocated item
from a per-adapter pool for small allocations, instead of dynamically
allocating memory with kzalloc().

an error handling path in qla2xxx_process_purls_iocb() incorrectly uses
kfree() to release the item. if the item was from the pre-allocated
pool, calling kfree() on it is a bug that can lead to memory corruption.

fix this by using the correct deallocation function,
qla24xx_free_purex_item(), which properly handles both dynamically
allocated and pre-allocated items.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-68741" target="_blank">CVE-2025-68741</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-12-24 07:16:29 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">N/A</span></p>
                    <p><span class="feed-label">CVSS Score:</span> N/A</p>
                    <p>In the Linux kernel, the following vulnerability has been resolved:

scsi: qla2xxx: Fix improper freeing of purex item

In qla2xxx_process_purls_iocb(), an item is allocated via
qla27xx_copy_multiple_pkt(), which internally calls
qla24xx_alloc_purex_item().

The qla24xx_alloc_purex_item() function may return a pre-allocated item
from a per-adapter pool for small allocations, instead of dynamically
allocating memory with kzalloc().

An error handling path in qla2xxx_process_purls_iocb() incorrectly uses
kfree() to release the item. If the item was from the pre-allocated
pool, calling kfree() on it is a bug that can lead to memory corruption.

Fix this by using the correct deallocation function,
qla24xx_free_purex_item(), which properly handles both dynamically
allocated and pre-allocated items.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-68740" data-description="in the linux kernel, the following vulnerability has been resolved:

ima: handle error code returned by ima_filter_rule_match()

in ima_match_rules(), if ima_filter_rule_match() returns -enoent due to
the rule being null, the function incorrectly skips the 'if (!rc)' check
and sets 'result = true'. the lsm rule is considered a match, causing
extra files to be measured by ima.

this issue can be reproduced in the following scenario:
after unloading the selinux policy module via 'semodule -d', if an ima
measurement is triggered before ima_lsm_rules is updated,
in ima_match_rules(), the first call to ima_filter_rule_match() returns
-estale. this causes the code to enter the 'if (rc == -estale &&
!rule_reinitialized)' block, perform ima_lsm_copy_rule() and retry. in
ima_lsm_copy_rule(), since the selinux module has been removed, the rule
becomes null, and the second call to ima_filter_rule_match() returns
-enoent. this bypasses the 'if (!rc)' check and results in a false match.

call trace:
  selinux_audit_rule_match+0x310/0x3b8
  security_audit_rule_match+0x60/0xa0
  ima_match_rules+0x2e4/0x4a0
  ima_match_policy+0x9c/0x1e8
  ima_get_action+0x48/0x60
  process_measurement+0xf8/0xa98
  ima_bprm_check+0x98/0xd8
  security_bprm_check+0x5c/0x78
  search_binary_handler+0x6c/0x318
  exec_binprm+0x58/0x1b8
  bprm_execve+0xb8/0x130
  do_execveat_common.isra.0+0x1a8/0x258
  __arm64_sys_execve+0x48/0x68
  invoke_syscall+0x50/0x128
  el0_svc_common.constprop.0+0xc8/0xf0
  do_el0_svc+0x24/0x38
  el0_svc+0x44/0x200
  el0t_64_sync_handler+0x100/0x130
  el0t_64_sync+0x3c8/0x3d0

fix this by changing 'if (!rc)' to 'if (rc <= 0)' to ensure that error
codes like -enoent do not bypass the check and accidentally result in a
successful match.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-68740" target="_blank">CVE-2025-68740</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-12-24 07:16:28 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">N/A</span></p>
                    <p><span class="feed-label">CVSS Score:</span> N/A</p>
                    <p>In the Linux kernel, the following vulnerability has been resolved:

ima: Handle error code returned by ima_filter_rule_match()

In ima_match_rules(), if ima_filter_rule_match() returns -ENOENT due to
the rule being NULL, the function incorrectly skips the 'if (!rc)' check
and sets 'result = true'. The LSM rule is considered a match, causing
extra files to be measured by IMA.

This issue can be reproduced in the following scenario:
After unloading the SELinux policy module via 'semodule -d', if an IMA
measurement is triggered before ima_lsm_rules is updated,
in ima_match_rules(), the first call to ima_filter_rule_match() returns
-ESTALE. This causes the code to enter the 'if (rc == -ESTALE &&
!rule_reinitialized)' block, perform ima_lsm_copy_rule() and retry. In
ima_lsm_copy_rule(), since the SELinux module has been removed, the rule
becomes NULL, and the second call to ima_filter_rule_match() returns
-ENOENT. This bypasses the 'if (!rc)' check and results in a false match.

Call trace:
  selinux_audit_rule_match+0x310/0x3b8
  security_audit_rule_match+0x60/0xa0
  ima_match_rules+0x2e4/0x4a0
  ima_match_policy+0x9c/0x1e8
  ima_get_action+0x48/0x60
  process_measurement+0xf8/0xa98
  ima_bprm_check+0x98/0xd8
  security_bprm_check+0x5c/0x78
  search_binary_handler+0x6c/0x318
  exec_binprm+0x58/0x1b8
  bprm_execve+0xb8/0x130
  do_execveat_common.isra.0+0x1a8/0x258
  __arm64_sys_execve+0x48/0x68
  invoke_syscall+0x50/0x128
  el0_svc_common.constprop.0+0xc8/0xf0
  do_el0_svc+0x24/0x38
  el0_svc+0x44/0x200
  el0t_64_sync_handler+0x100/0x130
  el0t_64_sync+0x3c8/0x3d0

Fix this by changing 'if (!rc)' to 'if (rc <= 0)' to ensure that error
codes like -ENOENT do not bypass the check and accidentally result in a
successful match.</p>
                </div>
        
            </div>
        </div>

        <footer class="footer">
            <p>Â© 2025 dotne1 - Cybersecurity Portfolio</p>
        </footer>

        <script>
            function searchCVEs() {
                const input = document.getElementById('searchInput').value.toLowerCase();
                const cveEntries = document.getElementsByClassName('cve-entry');
                for (let i = 0; i < cveEntries.length; i++) {
                    const cveId = cveEntries[i].getAttribute('data-cve-id').toLowerCase();
                    const description = cveEntries[i].getAttribute('data-description');
                    if (cveId.includes(input) || description.includes(input)) {
                        cveEntries[i].style.display = '';
                    } else {
                        cveEntries[i].style.display = 'none';
                    }
                }
            }
        </script>
    </body>
    </html>
    