
    <!DOCTYPE html>
    <html lang="en">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <meta name="description" content="Security alerts and cybersecurity news feeds">
        <meta name="keywords" content="cybersecurity news, security alerts, vulnerability feeds, threat intelligence">
        <meta name="author" content="dotne1">
        <meta property="og:title" content="Security Feeds - dotne1's Cybersecurity Portfolio">
        <meta property="og:description" content="Stay updated with the latest cybersecurity news and alerts">
        <meta property="og:type" content="website">
        <title>Security Feeds - dotne1's Cybersecurity Portfolio</title>
        <link rel="stylesheet" href="styles.css">
        <link rel="icon" type="image/x-icon" href="/favicon.ico">
    </head>
    <body>
        <nav class="navbar">
            <div class="nav-links">
                <a href="index.html" class="nav-link">Home</a>
                <a href="about-me.html" class="nav-link">About Me</a>
                <a href="projects.html" class="nav-link">Projects</a>
                <a href="resume.html" class="nav-link">Resume</a>
                <a href="feeds.html" class="nav-link">Feeds</a>
            </div>
        </nav>

        <div class="container" role="main">
            <h1 class="main-header">Security Feeds</h1>
            <div class="search-bar">
                <input type="text" id="searchInput" placeholder="Search CVEs..." onkeyup="searchCVEs()">
            </div>
            <div class="feed-preview" id="cveFeed">
                <div class="feed-header">Latest Vulnerabilities</div>
    
                <div class="cve-entry" data-cve-id="CVE-2025-29722" data-description="a csrf vulnerability in commercify v1.0 allows remote attackers to perform unauthorized actions on behalf of authenticated users. the issue exists due to missing csrf protection on sensitive endpoints.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-29722" target="_blank">CVE-2025-29722</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-04-17 13:15:49 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">N/A</span></p>
                    <p><span class="feed-label">CVSS Score:</span> N/A</p>
                    <p>A CSRF vulnerability in Commercify v1.0 allows remote attackers to perform unauthorized actions on behalf of authenticated users. The issue exists due to missing CSRF protection on sensitive endpoints.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-28101" data-description="an arbitrary file deletion vulnerability in the /post/{posttitle} component of flaskblog v2.6.1 allows attackers to delete article titles created by other users via supplying a crafted post request.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-28101" target="_blank">CVE-2025-28101</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-04-17 13:15:49 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">MEDIUM</span></p>
                    <p><span class="feed-label">CVSS Score:</span> 6.5</p>
                    <p>An arbitrary file deletion vulnerability in the /post/{postTitle} component of flaskBlog v2.6.1 allows attackers to delete article titles created by other users via supplying a crafted POST request.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-28009" data-description="a sql injection vulnerability exists in the `u` parameter of the progress-body-weight.php endpoint of dietiqa app v1.0.20.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-28009" target="_blank">CVE-2025-28009</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-04-17 13:15:49 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">N/A</span></p>
                    <p><span class="feed-label">CVSS Score:</span> N/A</p>
                    <p>A SQL Injection vulnerability exists in the `u` parameter of the progress-body-weight.php endpoint of Dietiqa App v1.0.20.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-26269" data-description="dragonflydb dragonfly through 1.28.2 allows authenticated users to cause a denial of service (daemon crash) via a lua library command that references a large negative integer.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-26269" target="_blank">CVE-2025-26269</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-04-17 13:15:49 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">LOW</span></p>
                    <p><span class="feed-label">CVSS Score:</span> 3.3</p>
                    <p>DragonflyDB Dragonfly through 1.28.2 allows authenticated users to cause a denial of service (daemon crash) via a Lua library command that references a large negative integer.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-26268" data-description="dragonflydb dragonfly before 1.27.0 allows authenticated users to cause a denial of service (daemon crash) via a crafted redis command. the validity of the scan cursor was not checked.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-26268" target="_blank">CVE-2025-26268</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-04-17 13:15:48 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">LOW</span></p>
                    <p><span class="feed-label">CVSS Score:</span> 3.3</p>
                    <p>DragonflyDB Dragonfly before 1.27.0 allows authenticated users to cause a denial of service (daemon crash) via a crafted Redis command. The validity of the scan cursor was not checked.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-25455" data-description="tenda ac10 v4.0si_v16.03.10.20 is vulnerable to buffer overflow in advsetmacmtuwan via wanmtu2.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-25455" target="_blank">CVE-2025-25455</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-04-17 13:15:48 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">N/A</span></p>
                    <p><span class="feed-label">CVSS Score:</span> N/A</p>
                    <p>Tenda AC10 V4.0si_V16.03.10.20 is vulnerable to Buffer Overflow in AdvSetMacMtuWan via wanMTU2.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-25454" data-description="tenda ac10 v4.0si_v16.03.10.20 is vulnerable to buffer overflow in advsetmacmtuwan via wanspeed2.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-25454" target="_blank">CVE-2025-25454</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-04-17 13:15:48 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">N/A</span></p>
                    <p><span class="feed-label">CVSS Score:</span> N/A</p>
                    <p>Tenda AC10 V4.0si_V16.03.10.20 is vulnerable to Buffer Overflow in AdvSetMacMtuWan via wanSpeed2.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2024-55211" data-description="an issue in think router tk-rt-wr135g v3.0.2-x000 allows attackers to bypass authentication via a crafted cookie.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2024-55211" target="_blank">CVE-2024-55211</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-04-17 13:15:47 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">N/A</span></p>
                    <p><span class="feed-label">CVSS Score:</span> N/A</p>
                    <p>An issue in Think Router Tk-Rt-Wr135G V3.0.2-X000 allows attackers to bypass authentication via a crafted cookie.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2024-53924" data-description="pycel through 1.0b30, when operating on an untrusted spreadsheet, allows code execution via a crafted formula in a cell, such as one beginning with the =if(a1=200, eval("__import__('os').system( substring.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2024-53924" target="_blank">CVE-2024-53924</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-04-17 13:15:47 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">N/A</span></p>
                    <p><span class="feed-label">CVSS Score:</span> N/A</p>
                    <p>Pycel through 1.0b30, when operating on an untrusted spreadsheet, allows code execution via a crafted formula in a cell, such as one beginning with the =IF(A1=200, eval("__import__('os').system( substring.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2021-47671" data-description="in the linux kernel, the following vulnerability has been resolved:

can: etas_es58x: es58x_rx_err_msg(): fix memory leak in error path

in es58x_rx_err_msg(), if can->do_set_mode() fails, the function
directly returns without calling netif_rx(skb). this means that the
skb previously allocated by alloc_can_err_skb() is not freed. in other
terms, this is a memory leak.

this patch simply removes the return statement in the error branch and
let the function continue.

issue was found with gcc -fanalyzer, please follow the link below for
details.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2021-47671" target="_blank">CVE-2021-47671</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-04-17 13:15:43 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">N/A</span></p>
                    <p><span class="feed-label">CVSS Score:</span> N/A</p>
                    <p>In the Linux kernel, the following vulnerability has been resolved:

can: etas_es58x: es58x_rx_err_msg(): fix memory leak in error path

In es58x_rx_err_msg(), if can->do_set_mode() fails, the function
directly returns without calling netif_rx(skb). This means that the
skb previously allocated by alloc_can_err_skb() is not freed. In other
terms, this is a memory leak.

This patch simply removes the return statement in the error branch and
let the function continue.

Issue was found with GCC -fanalyzer, please follow the link below for
details.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2021-47670" data-description="in the linux kernel, the following vulnerability has been resolved:

can: peak_usb: fix use after free bugs

after calling peak_usb_netif_rx_ni(skb), dereferencing skb is unsafe.
especially, the can_frame cf which aliases skb memory is accessed
after the peak_usb_netif_rx_ni().

reordering the lines solves the issue.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2021-47670" target="_blank">CVE-2021-47670</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-04-17 13:15:43 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">N/A</span></p>
                    <p><span class="feed-label">CVSS Score:</span> N/A</p>
                    <p>In the Linux kernel, the following vulnerability has been resolved:

can: peak_usb: fix use after free bugs

After calling peak_usb_netif_rx_ni(skb), dereferencing skb is unsafe.
Especially, the can_frame cf which aliases skb memory is accessed
after the peak_usb_netif_rx_ni().

Reordering the lines solves the issue.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2021-47669" data-description="in the linux kernel, the following vulnerability has been resolved:

can: vxcan: vxcan_xmit: fix use after free bug

after calling netif_rx_ni(skb), dereferencing skb is unsafe.
especially, the canfd_frame cfd which aliases skb memory is accessed
after the netif_rx_ni().">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2021-47669" target="_blank">CVE-2021-47669</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-04-17 13:15:43 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">N/A</span></p>
                    <p><span class="feed-label">CVSS Score:</span> N/A</p>
                    <p>In the Linux kernel, the following vulnerability has been resolved:

can: vxcan: vxcan_xmit: fix use after free bug

After calling netif_rx_ni(skb), dereferencing skb is unsafe.
Especially, the canfd_frame cfd which aliases skb memory is accessed
after the netif_rx_ni().</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2021-47668" data-description="in the linux kernel, the following vulnerability has been resolved:

can: dev: can_restart: fix use after free bug

after calling netif_rx_ni(skb), dereferencing skb is unsafe.
especially, the can_frame cf which aliases skb memory is accessed
after the netif_rx_ni() in:
      stats->rx_bytes += cf->len;

reordering the lines solves the issue.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2021-47668" target="_blank">CVE-2021-47668</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-04-17 13:15:43 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">N/A</span></p>
                    <p><span class="feed-label">CVSS Score:</span> N/A</p>
                    <p>In the Linux kernel, the following vulnerability has been resolved:

can: dev: can_restart: fix use after free bug

After calling netif_rx_ni(skb), dereferencing skb is unsafe.
Especially, the can_frame cf which aliases skb memory is accessed
after the netif_rx_ni() in:
      stats->rx_bytes += cf->len;

Reordering the lines solves the issue.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2020-36789" data-description="in the linux kernel, the following vulnerability has been resolved:

can: dev: can_get_echo_skb(): prevent call to kfree_skb() in hard irq context

if a driver calls can_get_echo_skb() during a hardware irq (which is often, but
not always, the case), the 'warn_on(in_irq)' in
net/core/skbuff.c#skb_release_head_state() might be triggered, under network
congestion circumstances, together with the potential risk of a null pointer
dereference.

the root cause of this issue is the call to kfree_skb() instead of
dev_kfree_skb_irq() in net/core/dev.c#enqueue_to_backlog().

this patch prevents the skb to be freed within the call to netif_rx() by
incrementing its reference count with skb_get(). the skb is finally freed by
one of the in-irq-context safe functions: dev_consume_skb_any() or
dev_kfree_skb_any(). the "any" version is used because some drivers might call
can_get_echo_skb() in a normal context.

the reason for this issue to occur is that initially, in the core network
stack, loopback skb were not supposed to be received in hardware irq context.
the can stack is an exeption.

this bug was previously reported back in 2017 in [1] but the proposed patch
never got accepted.

while [1] directly modifies net/core/dev.c, we try to propose here a
smoother modification local to can network stack (the assumption
behind is that only can devices are affected by this issue).

[1] http://lore.kernel.org/r/57a3ffb6-3309-3ad5-5a34-e93c3fe3614d@cetitec.com">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2020-36789" target="_blank">CVE-2020-36789</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-04-17 13:15:42 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">N/A</span></p>
                    <p><span class="feed-label">CVSS Score:</span> N/A</p>
                    <p>In the Linux kernel, the following vulnerability has been resolved:

can: dev: can_get_echo_skb(): prevent call to kfree_skb() in hard IRQ context

If a driver calls can_get_echo_skb() during a hardware IRQ (which is often, but
not always, the case), the 'WARN_ON(in_irq)' in
net/core/skbuff.c#skb_release_head_state() might be triggered, under network
congestion circumstances, together with the potential risk of a NULL pointer
dereference.

The root cause of this issue is the call to kfree_skb() instead of
dev_kfree_skb_irq() in net/core/dev.c#enqueue_to_backlog().

This patch prevents the skb to be freed within the call to netif_rx() by
incrementing its reference count with skb_get(). The skb is finally freed by
one of the in-irq-context safe functions: dev_consume_skb_any() or
dev_kfree_skb_any(). The "any" version is used because some drivers might call
can_get_echo_skb() in a normal context.

The reason for this issue to occur is that initially, in the core network
stack, loopback skb were not supposed to be received in hardware IRQ context.
The CAN stack is an exeption.

This bug was previously reported back in 2017 in [1] but the proposed patch
never got accepted.

While [1] directly modifies net/core/dev.c, we try to propose here a
smoother modification local to CAN network stack (the assumption
behind is that only CAN devices are affected by this issue).

[1] http://lore.kernel.org/r/57a3ffb6-3309-3ad5-5a34-e93c3fe3614d@cetitec.com</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-32415" data-description="in libxml2 before 2.13.8 and 2.14.x before 2.14.2, xmlschemaidcfillnodetables in xmlschemas.c has a heap-based buffer under-read. to exploit this, a crafted xml document must be validated against an xml schema with certain identity constraints, or a crafted xml schema must be used.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-32415" target="_blank">CVE-2025-32415</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-04-17 12:15:33 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">LOW</span></p>
                    <p><span class="feed-label">CVSS Score:</span> 2.9</p>
                    <p>In libxml2 before 2.13.8 and 2.14.x before 2.14.2, xmlSchemaIDCFillNodeTables in xmlschemas.c has a heap-based buffer under-read. To exploit this, a crafted XML document must be validated against an XML schema with certain identity constraints, or a crafted XML schema must be used.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-2947" data-description="ibm i 7.6 

contains a privilege escalation vulnerability due to incorrect profile swapping in an os command.  a malicious actor can use the command to elevate privileges to gain root access to the host operating system.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-2947" target="_blank">CVE-2025-2947</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-04-17 12:15:33 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-online">HIGH</span></p>
                    <p><span class="feed-label">CVSS Score:</span> 7.2</p>
                    <p>IBM i 7.6 

contains a privilege escalation vulnerability due to incorrect profile swapping in an OS command.  A malicious actor can use the command to elevate privileges to gain root access to the host operating system.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-29662" data-description="a rce vulnerability in the core application in landchat 3.25.12.18 allows an unauthenticated attacker to execute system code via remote network access.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-29662" target="_blank">CVE-2025-29662</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-04-17 12:15:33 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">N/A</span></p>
                    <p><span class="feed-label">CVSS Score:</span> N/A</p>
                    <p>A RCE vulnerability in the core application in LandChat 3.25.12.18 allows an unauthenticated attacker to execute system code via remote network access.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-29661" data-description="litepubl cms <= 7.0.9 is vulnerable to rce in admin/service/run.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-29661" target="_blank">CVE-2025-29661</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-04-17 12:15:33 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">N/A</span></p>
                    <p><span class="feed-label">CVSS Score:</span> N/A</p>
                    <p>Litepubl CMS <= 7.0.9 is vulnerable to RCE in admin/service/run.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-29181" data-description="foxcms <= v1.25 is vulnerable to sql injection via $param['title'] in /admin/util/field.php.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-29181" target="_blank">CVE-2025-29181</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-04-17 12:15:33 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">N/A</span></p>
                    <p><span class="feed-label">CVSS Score:</span> N/A</p>
                    <p>FOXCMS <= V1.25 is vulnerable to SQL Injection via $param['title'] in /admin/util/Field.php.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-29180" data-description="in foxcms <=1.25, the installdb.php file has a time - based blind sql injection vulnerability. the url_prefix, domain, and my_website post parameters are directly concatenated into sql statements without filtering.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-29180" target="_blank">CVE-2025-29180</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-04-17 12:15:32 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">N/A</span></p>
                    <p><span class="feed-label">CVSS Score:</span> N/A</p>
                    <p>In FOXCMS <=1.25, the installdb.php file has a time - based blind SQL injection vulnerability. The url_prefix, domain, and my_website POST parameters are directly concatenated into SQL statements without filtering.</p>
                </div>
        
            </div>
        </div>

        <footer class="footer">
            <p>© 2025 dotne1 - Cybersecurity Portfolio</p>
        </footer>

        <script>
            function searchCVEs() {
                const input = document.getElementById('searchInput').value.toLowerCase();
                const cveEntries = document.getElementsByClassName('cve-entry');
                for (let i = 0; i < cveEntries.length; i++) {
                    const cveId = cveEntries[i].getAttribute('data-cve-id').toLowerCase();
                    const description = cveEntries[i].getAttribute('data-description');
                    if (cveId.includes(input) || description.includes(input)) {
                        cveEntries[i].style.display = '';
                    } else {
                        cveEntries[i].style.display = 'none';
                    }
                }
            }
        </script>
    </body>
    </html>
    