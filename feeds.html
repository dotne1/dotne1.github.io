
    <!DOCTYPE html>
    <html lang="en">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <meta name="description" content="Security alerts and cybersecurity news feeds">
        <meta name="keywords" content="cybersecurity news, security alerts, vulnerability feeds, threat intelligence">
        <meta name="author" content="dotne1">
        <meta property="og:title" content="Security Feeds - dotne1's Cybersecurity Portfolio">
        <meta property="og:description" content="Stay updated with the latest cybersecurity news and alerts">
        <meta property="og:type" content="website">
        <title>Security Feeds - dotne1's Cybersecurity Portfolio</title>
        <link rel="stylesheet" href="styles.css">
        <link rel="icon" type="image/x-icon" href="/favicon.ico">
    </head>
    <body>
        <nav class="navbar">
            <div class="nav-links">
                <a href="index.html" class="nav-link">Home</a>
                <a href="about-me.html" class="nav-link">About Me</a>
                <a href="projects.html" class="nav-link">Projects</a>
                <a href="resume.html" class="nav-link">Resume</a>
                <a href="feeds.html" class="nav-link">Feeds</a>
            </div>
        </nav>

        <div class="container" role="main">
            <h1 class="main-header">Security Feeds</h1>
            <div class="search-bar">
                <input type="text" id="searchInput" placeholder="Search CVEs..." onkeyup="searchCVEs()">
            </div>
            <div class="feed-preview" id="cveFeed">
                <div class="feed-header">Latest Vulnerabilities</div>
    
                <div class="cve-entry" data-cve-id="CVE-2026-2541" data-description="the micca ke700 system relies on a 6-bit portion of an identifier for authentication within rolling codes, providing only 64 possible combinations. this low entropy allows an attacker to perform a brute-force attack against one component of the rolling code. successful exploitation simplify an attacker to predict the next valid rolling code, granting unauthorized access to the vehicle.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2026-2541" target="_blank">CVE-2026-2541</a></h2>
                    <p><span class="feed-label">Published:</span> 2026-02-15 05:15:55 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">N/A</span></p>
                    <p><span class="feed-label">CVSS Score:</span> N/A</p>
                    <p>The Micca KE700 system relies on a 6-bit portion of an identifier for authentication within rolling codes, providing only 64 possible combinations. This low entropy allows an attacker to perform a brute-force attack against one component of the rolling code. Successful exploitation simplify an attacker to predict the next valid rolling code, granting unauthorized access to the vehicle.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2026-2540" data-description="the micca ke700 system contains flawed resynchronization logic and is vulnerable to replay attacks. this attack requires sending two previously captured codes in a specific sequence. as a result, the system can be forced to accept previously used (stale) rolling codes and execute a command. successful exploitation allows an attacker to clone the alarm key. this grants the attacker unauthorized access to the vehicle to unlock or lock the doors.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2026-2540" target="_blank">CVE-2026-2540</a></h2>
                    <p><span class="feed-label">Published:</span> 2026-02-15 05:15:55 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">N/A</span></p>
                    <p><span class="feed-label">CVSS Score:</span> N/A</p>
                    <p>The Micca KE700 system contains flawed resynchronization logic and is vulnerable to replay attacks. This attack requires sending two previously captured codes in a specific sequence. As a result, the system can be forced to accept previously used (stale) rolling codes and execute a command. Successful exploitation allows an attacker to clone the alarm key. This grants the attacker unauthorized access to the vehicle to unlock or lock the doors.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2026-2539" data-description="the rf communication protocol in the micca ke700 car alarm system does not encrypt its data frames. an attacker with a radio interception tool (e.g., sdr) can capture the random number and counters transmitted in cleartext, which is sensitive information required for authentication.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2026-2539" target="_blank">CVE-2026-2539</a></h2>
                    <p><span class="feed-label">Published:</span> 2026-02-15 05:15:54 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">N/A</span></p>
                    <p><span class="feed-label">CVSS Score:</span> N/A</p>
                    <p>The RF communication protocol in the Micca KE700 car alarm system does not encrypt its data frames. An attacker with a radio interception tool (e.g., SDR) can capture the random number and counters transmitted in cleartext, which is sensitive information required for authentication.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-32063" data-description="there is a misconfiguration vulnerability inside the infotainment ecu manufactured by bosch. the vulnerability happens during the startup phase of a specific systemd service, and as a result, the following developer features will be activated: the disabled firewall and the launched ssh server.



first identified on nissan leaf ze1 manufactured in 2020.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-32063" target="_blank">CVE-2025-32063</a></h2>
                    <p><span class="feed-label">Published:</span> 2026-02-15 05:15:54 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">MEDIUM</span></p>
                    <p><span class="feed-label">CVSS Score:</span> 6.8</p>
                    <p>There is a misconfiguration vulnerability inside the Infotainment ECU manufactured by BOSCH. The vulnerability happens during the startup phase of a specific systemd service, and as a result, the following developer features will be activated: the disabled firewall and the launched SSH server.



First identified on Nissan Leaf ZE1 manufactured in 2020.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-32062" data-description="the specific flaw exists within the bluetooth stack developed by alps alpine of the infotainment ecu manufactured by bosch. the issue results from the lack of proper boundary validation of user-supplied data, which can result in a stack-based buffer overflow when receiving a specific packet on the established upper layer l2cap channel. an attacker can leverage this vulnerability to obtain remote code execution on the infotainment ecu with root privileges.



first identified on nissan leaf ze1 manufactured in 2020.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-32062" target="_blank">CVE-2025-32062</a></h2>
                    <p><span class="feed-label">Published:</span> 2026-02-15 05:15:54 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-online">HIGH</span></p>
                    <p><span class="feed-label">CVSS Score:</span> 8.8</p>
                    <p>The specific flaw exists within the Bluetooth stack developed by Alps Alpine of the Infotainment ECU manufactured by Bosch. The issue results from the lack of proper boundary validation of user-supplied data, which can result in a stack-based buffer overflow when receiving a specific packet on the established upper layer L2CAP channel. An attacker can leverage this vulnerability to obtain remote code execution on the Infotainment ECU with root privileges.



First identified on Nissan Leaf ZE1 manufactured in 2020.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-32061" data-description="the specific flaw exists within the bluetooth stack developed by alps alpine of the infotainment ecu manufactured by bosch. the issue results from the lack of proper boundary validation of user-supplied data, which can result in a stack-based buffer overflow when receiving a specific packet on the established upper layer l2cap channel. an attacker can leverage this vulnerability to obtain remote code execution on the infotainment ecu with root privileges.



first identified on nissan leaf ze1 manufactured in 2020.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-32061" target="_blank">CVE-2025-32061</a></h2>
                    <p><span class="feed-label">Published:</span> 2026-02-15 05:15:54 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-online">HIGH</span></p>
                    <p><span class="feed-label">CVSS Score:</span> 8.8</p>
                    <p>The specific flaw exists within the Bluetooth stack developed by Alps Alpine of the Infotainment ECU manufactured by Bosch. The issue results from the lack of proper boundary validation of user-supplied data, which can result in a stack-based buffer overflow when receiving a specific packet on the established upper layer L2CAP channel. An attacker can leverage this vulnerability to obtain remote code execution on the Infotainment ECU with root privileges.



First identified on Nissan Leaf ZE1 manufactured in 2020.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-32060" data-description="the system suffers from the absence of a kernel module signature verification. if an attacker can execute commands on behalf of root user (due to additional vulnerabilities), then he/she is also able to load custom kernel modules to the kernel space and execute code in the kernel context. such a flaw can lead to taking control over the entire system.



first identified on nissan leaf ze1 manufactured in 2020.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-32060" target="_blank">CVE-2025-32060</a></h2>
                    <p><span class="feed-label">Published:</span> 2026-02-15 05:15:54 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">MEDIUM</span></p>
                    <p><span class="feed-label">CVSS Score:</span> 6.7</p>
                    <p>The system suffers from the absence of a kernel module signature verification. If an attacker can execute commands on behalf of root user (due to additional vulnerabilities), then he/she is also able to load custom kernel modules to the kernel space and execute code in the kernel context. Such a flaw can lead to taking control over the entire system.



First identified on Nissan Leaf ZE1 manufactured in 2020.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-32059" data-description="the specific flaw exists within the bluetooth stack developed by alps alpine of the infotainment ecu manufactured by bosch. the issue results from the lack of proper boundary validation of user-supplied data, which can result in a stack-based buffer overflow when receiving a specific packet on the established upper layer l2cap channel. an attacker can leverage this vulnerability to obtain remote code execution on the infotainment ecu with root privileges.



first identified on nissan leaf ze1 manufactured in 2020.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-32059" target="_blank">CVE-2025-32059</a></h2>
                    <p><span class="feed-label">Published:</span> 2026-02-15 05:15:53 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-online">HIGH</span></p>
                    <p><span class="feed-label">CVSS Score:</span> 8.8</p>
                    <p>The specific flaw exists within the Bluetooth stack developed by Alps Alpine of the Infotainment ECU manufactured by Bosch. The issue results from the lack of proper boundary validation of user-supplied data, which can result in a stack-based buffer overflow when receiving a specific packet on the established upper layer L2CAP channel. An attacker can leverage this vulnerability to obtain remote code execution on the Infotainment ECU with root privileges.



First identified on Nissan Leaf ZE1 manufactured in 2020.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-32058" data-description="the infotainment ecu manufactured by bosch uses a rh850 module for can communication. rh850 is connected to infotainment over the inc interface through a custom protocol. there is a vulnerability during processing requests of this protocol on the v850 side which allows an attacker with code execution on the infotainment main soc to perform code execution on the rh850 module and subsequently send arbitrary can messages over the connected can bus.



first identified on nissan leaf ze1 manufactured in 2020.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-32058" target="_blank">CVE-2025-32058</a></h2>
                    <p><span class="feed-label">Published:</span> 2026-02-15 05:15:52 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-online">CRITICAL</span></p>
                    <p><span class="feed-label">CVSS Score:</span> 9.3</p>
                    <p>The Infotainment ECU manufactured by Bosch uses a RH850 module for CAN communication. RH850 is connected to infotainment over the INC interface through a custom protocol. There is a vulnerability during processing requests of this protocol on the V850 side which allows an attacker with code execution on the infotainment main SoC to perform code execution on the RH850 module and subsequently send arbitrary CAN messages over the connected CAN bus.



First identified on Nissan Leaf ZE1 manufactured in 2020.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2026-1793" data-description="the element pack addons for elementor plugin for wordpress is vulnerable to arbitrary file reads in all versions up to, and including, 8.3.17 via the svg widget and a lack of sufficient file validation in the 'render_svg' function. this makes it possible for authenticated attackers, with contributor-level access and above, to read the contents of arbitrary files on the server, which can contain sensitive information.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2026-1793" target="_blank">CVE-2026-1793</a></h2>
                    <p><span class="feed-label">Published:</span> 2026-02-14 22:15:54 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">MEDIUM</span></p>
                    <p><span class="feed-label">CVSS Score:</span> 6.5</p>
                    <p>The Element Pack Addons for Elementor plugin for WordPress is vulnerable to arbitrary file reads in all versions up to, and including, 8.3.17 via the SVG widget and a lack of sufficient file validation in the 'render_svg' function. This makes it possible for authenticated attackers, with contributor-level access and above, to read the contents of arbitrary files on the server, which can contain sensitive information.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2026-1750" data-description="the ecwid by lightspeed ecommerce shopping cart plugin for wordpress is vulnerable to privilege escalation in all versions up to, and including, 7.0.7. this is due to a missing capability check in the 'save_custom_user_profile_fields' function. this makes it possible for authenticated attackers, with minimal permissions such as a subscriber, to supply the 'ec_store_admin_access' parameter during a profile update and gain store manager access to the site.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2026-1750" target="_blank">CVE-2026-1750</a></h2>
                    <p><span class="feed-label">Published:</span> 2026-02-14 22:15:54 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-online">HIGH</span></p>
                    <p><span class="feed-label">CVSS Score:</span> 8.8</p>
                    <p>The Ecwid by Lightspeed Ecommerce Shopping Cart plugin for WordPress is vulnerable to Privilege Escalation in all versions up to, and including, 7.0.7. This is due to a missing capability check in the 'save_custom_user_profile_fields' function. This makes it possible for authenticated attackers, with minimal permissions such as a subscriber, to supply the 'ec_store_admin_access' parameter during a profile update and gain store manager access to the site.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2026-1490" data-description="the spam protection, anti-spam, firewall by cleantalk plugin for wordpress is vulnerable to unauthorized arbitrary plugin installation due to an authorization bypass via reverse dns (ptr record) spoofing on the 'checkwithouttoken' function in all versions up to, and including, 6.71. this makes it possible for unauthenticated attackers to install and activate arbitrary plugins which can be leveraged to achieve remote code execution if another vulnerable plugin is installed and activated. note: this is only exploitable on sites with an invalid api key.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2026-1490" target="_blank">CVE-2026-1490</a></h2>
                    <p><span class="feed-label">Published:</span> 2026-02-14 22:15:53 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-online">CRITICAL</span></p>
                    <p><span class="feed-label">CVSS Score:</span> 9.8</p>
                    <p>The Spam protection, Anti-Spam, FireWall by CleanTalk plugin for WordPress is vulnerable to unauthorized Arbitrary Plugin Installation due to an authorization bypass via reverse DNS (PTR record) spoofing on the 'checkWithoutToken' function in all versions up to, and including, 6.71. This makes it possible for unauthenticated attackers to install and activate arbitrary plugins which can be leveraged to achieve remote code execution if another vulnerable plugin is installed and activated. Note: This is only exploitable on sites with an invalid API key.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2026-23210" data-description="in the linux kernel, the following vulnerability has been resolved:

ice: fix ptp null pointer dereference during vsi rebuild

fix race condition where ptp periodic work runs while vsi is being
rebuilt, accessing null vsi->rx_rings.

the sequence was:
1. ice_ptp_prepare_for_reset() cancels ptp work
2. ice_ptp_rebuild() immediately queues ptp work
3. vsi rebuild happens after ice_ptp_rebuild()
4. ptp work runs and accesses null vsi->rx_rings

fix: keep ptp work cancelled during rebuild, only queue it after
vsi rebuild completes in ice_rebuild().

added ice_ptp_queue_work() helper function to encapsulate the logic
for queuing ptp work, ensuring it's only queued when ptp is supported
and the state is ice_ptp_ready.

error log:
[  121.392544] ice 0000:60:00.1: ptp reset successful
[  121.392692] bug: kernel null pointer dereference, address: 0000000000000000
[  121.392712] #pf: supervisor read access in kernel mode
[  121.392720] #pf: error_code(0x0000) - not-present page
[  121.392727] pgd 0
[  121.392734] oops: oops: 0000 [#1] smp nopti
[  121.392746] cpu: 8 uid: 0 pid: 1005 comm: ice-ptp-0000:60 tainted: g s                  6.19.0-rc6+ #4 preempt(voluntary)
[  121.392761] tainted: [s]=cpu_out_of_spec
[  121.392773] rip: 0010:ice_ptp_update_cached_phctime+0xbf/0x150 [ice]
[  121.393042] call trace:
[  121.393047]  <task>
[  121.393055]  ice_ptp_periodic_work+0x69/0x180 [ice]
[  121.393202]  kthread_worker_fn+0xa2/0x260
[  121.393216]  ? __pfx_ice_ptp_periodic_work+0x10/0x10 [ice]
[  121.393359]  ? __pfx_kthread_worker_fn+0x10/0x10
[  121.393371]  kthread+0x10d/0x230
[  121.393382]  ? __pfx_kthread+0x10/0x10
[  121.393393]  ret_from_fork+0x273/0x2b0
[  121.393407]  ? __pfx_kthread+0x10/0x10
[  121.393417]  ret_from_fork_asm+0x1a/0x30
[  121.393432]  </task>">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2026-23210" target="_blank">CVE-2026-23210</a></h2>
                    <p><span class="feed-label">Published:</span> 2026-02-14 11:15:58 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">N/A</span></p>
                    <p><span class="feed-label">CVSS Score:</span> N/A</p>
                    <p>In the Linux kernel, the following vulnerability has been resolved:

ice: Fix PTP NULL pointer dereference during VSI rebuild

Fix race condition where PTP periodic work runs while VSI is being
rebuilt, accessing NULL vsi->rx_rings.

The sequence was:
1. ice_ptp_prepare_for_reset() cancels PTP work
2. ice_ptp_rebuild() immediately queues PTP work
3. VSI rebuild happens AFTER ice_ptp_rebuild()
4. PTP work runs and accesses NULL vsi->rx_rings

Fix: Keep PTP work cancelled during rebuild, only queue it after
VSI rebuild completes in ice_rebuild().

Added ice_ptp_queue_work() helper function to encapsulate the logic
for queuing PTP work, ensuring it's only queued when PTP is supported
and the state is ICE_PTP_READY.

Error log:
[  121.392544] ice 0000:60:00.1: PTP reset successful
[  121.392692] BUG: kernel NULL pointer dereference, address: 0000000000000000
[  121.392712] #PF: supervisor read access in kernel mode
[  121.392720] #PF: error_code(0x0000) - not-present page
[  121.392727] PGD 0
[  121.392734] Oops: Oops: 0000 [#1] SMP NOPTI
[  121.392746] CPU: 8 UID: 0 PID: 1005 Comm: ice-ptp-0000:60 Tainted: G S                  6.19.0-rc6+ #4 PREEMPT(voluntary)
[  121.392761] Tainted: [S]=CPU_OUT_OF_SPEC
[  121.392773] RIP: 0010:ice_ptp_update_cached_phctime+0xbf/0x150 [ice]
[  121.393042] Call Trace:
[  121.393047]  <TASK>
[  121.393055]  ice_ptp_periodic_work+0x69/0x180 [ice]
[  121.393202]  kthread_worker_fn+0xa2/0x260
[  121.393216]  ? __pfx_ice_ptp_periodic_work+0x10/0x10 [ice]
[  121.393359]  ? __pfx_kthread_worker_fn+0x10/0x10
[  121.393371]  kthread+0x10d/0x230
[  121.393382]  ? __pfx_kthread+0x10/0x10
[  121.393393]  ret_from_fork+0x273/0x2b0
[  121.393407]  ? __pfx_kthread+0x10/0x10
[  121.393417]  ret_from_fork_asm+0x1a/0x30
[  121.393432]  </TASK></p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2026-23209" data-description="in the linux kernel, the following vulnerability has been resolved:

macvlan: fix error recovery in macvlan_common_newlink()

valis provided a nice repro to crash the kernel:

ip link add p1 type veth peer p2
ip link set address 00:00:00:00:00:20 dev p1
ip link set up dev p1
ip link set up dev p2

ip link add mv0 link p2 type macvlan mode source
ip link add invalid% link p2 type macvlan mode source macaddr add 00:00:00:00:00:20

ping -c1 -i p1 1.2.3.4

he also gave a very detailed analysis:

<quote valis>

the issue is triggered when a new macvlan link is created  with
macvlan_mode_source mode and macvlan_macaddr_add (or
macvlan_macaddr_set) parameter, lower device already has a macvlan
port and register_netdevice() called from macvlan_common_newlink()
fails (e.g. because of the invalid link name).

in this case macvlan_hash_add_source is called from
macvlan_change_sources() / macvlan_common_newlink():

this adds a reference to vlan to the port's vlan_source_hash using
macvlan_source_entry.

vlan is a pointer to the priv data of the link that is being created.

when register_netdevice() fails, the error is returned from
macvlan_newlink() to rtnl_newlink_create():

        if (ops->newlink)
                err = ops->newlink(dev, &params, extack);
        else
                err = register_netdevice(dev);
        if (err < 0) {
                free_netdev(dev);
                goto out;
        }

and free_netdev() is called, causing a kvfree() on the struct
net_device that is still referenced in the source entry attached to
the lower device's macvlan port.

now all packets sent on the macvlan port with a matching source mac
address will trigger a use-after-free in macvlan_forward_source().

</quote valis>

with all that, my fix is to make sure we call macvlan_flush_sources()
regardless of @create value whenever "goto destroy_macvlan_port;"
path is taken.

many thanks to valis for following up on this issue.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2026-23209" target="_blank">CVE-2026-23209</a></h2>
                    <p><span class="feed-label">Published:</span> 2026-02-14 11:15:58 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">N/A</span></p>
                    <p><span class="feed-label">CVSS Score:</span> N/A</p>
                    <p>In the Linux kernel, the following vulnerability has been resolved:

macvlan: fix error recovery in macvlan_common_newlink()

valis provided a nice repro to crash the kernel:

ip link add p1 type veth peer p2
ip link set address 00:00:00:00:00:20 dev p1
ip link set up dev p1
ip link set up dev p2

ip link add mv0 link p2 type macvlan mode source
ip link add invalid% link p2 type macvlan mode source macaddr add 00:00:00:00:00:20

ping -c1 -I p1 1.2.3.4

He also gave a very detailed analysis:

<quote valis>

The issue is triggered when a new macvlan link is created  with
MACVLAN_MODE_SOURCE mode and MACVLAN_MACADDR_ADD (or
MACVLAN_MACADDR_SET) parameter, lower device already has a macvlan
port and register_netdevice() called from macvlan_common_newlink()
fails (e.g. because of the invalid link name).

In this case macvlan_hash_add_source is called from
macvlan_change_sources() / macvlan_common_newlink():

This adds a reference to vlan to the port's vlan_source_hash using
macvlan_source_entry.

vlan is a pointer to the priv data of the link that is being created.

When register_netdevice() fails, the error is returned from
macvlan_newlink() to rtnl_newlink_create():

        if (ops->newlink)
                err = ops->newlink(dev, &params, extack);
        else
                err = register_netdevice(dev);
        if (err < 0) {
                free_netdev(dev);
                goto out;
        }

and free_netdev() is called, causing a kvfree() on the struct
net_device that is still referenced in the source entry attached to
the lower device's macvlan port.

Now all packets sent on the macvlan port with a matching source mac
address will trigger a use-after-free in macvlan_forward_source().

</quote valis>

With all that, my fix is to make sure we call macvlan_flush_sources()
regardless of @create value whenever "goto destroy_macvlan_port;"
path is taken.

Many thanks to valis for following up on this issue.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2026-23208" data-description="in the linux kernel, the following vulnerability has been resolved:

alsa: usb-audio: prevent excessive number of frames

in this case, the user constructed the parameters with maxpacksize 40
for rate 22050 / pps 1000, and packsize[0] 22 packsize[1] 23. the buffer
size for each data urb is maxpacksize * packets, which in this example
is 40 * 6 = 240; when the user performs a write operation to send audio
data into the alsa pcm playback stream, the calculated number of frames
is packsize[0] * packets = 264, which exceeds the allocated urb buffer
size, triggering the out-of-bounds (oob) issue reported by syzbot [1].

added a check for the number of single data urb frames when calculating
the number of frames to prevent [1].

[1]
bug: kasan: slab-out-of-bounds in copy_to_urb+0x261/0x460 sound/usb/pcm.c:1487
write of size 264 at addr ffff88804337e800 by task syz.0.17/5506
call trace:
 copy_to_urb+0x261/0x460 sound/usb/pcm.c:1487
 prepare_playback_urb+0x953/0x13d0 sound/usb/pcm.c:1611
 prepare_outbound_urb+0x377/0xc50 sound/usb/endpoint.c:333">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2026-23208" target="_blank">CVE-2026-23208</a></h2>
                    <p><span class="feed-label">Published:</span> 2026-02-14 11:15:58 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">N/A</span></p>
                    <p><span class="feed-label">CVSS Score:</span> N/A</p>
                    <p>In the Linux kernel, the following vulnerability has been resolved:

ALSA: usb-audio: Prevent excessive number of frames

In this case, the user constructed the parameters with maxpacksize 40
for rate 22050 / pps 1000, and packsize[0] 22 packsize[1] 23. The buffer
size for each data URB is maxpacksize * packets, which in this example
is 40 * 6 = 240; When the user performs a write operation to send audio
data into the ALSA PCM playback stream, the calculated number of frames
is packsize[0] * packets = 264, which exceeds the allocated URB buffer
size, triggering the out-of-bounds (OOB) issue reported by syzbot [1].

Added a check for the number of single data URB frames when calculating
the number of frames to prevent [1].

[1]
BUG: KASAN: slab-out-of-bounds in copy_to_urb+0x261/0x460 sound/usb/pcm.c:1487
Write of size 264 at addr ffff88804337e800 by task syz.0.17/5506
Call Trace:
 copy_to_urb+0x261/0x460 sound/usb/pcm.c:1487
 prepare_playback_urb+0x953/0x13d0 sound/usb/pcm.c:1611
 prepare_outbound_urb+0x377/0xc50 sound/usb/endpoint.c:333</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2026-23207" data-description="in the linux kernel, the following vulnerability has been resolved:

spi: tegra210-quad: protect curr_xfer check in irq handler

now that all other accesses to curr_xfer are done under the lock,
protect the curr_xfer null check in tegra_qspi_isr_thread() with the
spinlock. without this protection, the following race can occur:

  cpu0 (isr thread)              cpu1 (timeout path)
  ----------------               -------------------
  if (!tqspi->curr_xfer)
    // sees non-null
                                 spin_lock()
                                 tqspi->curr_xfer = null
                                 spin_unlock()
  handle_*_xfer()
    spin_lock()
    t = tqspi->curr_xfer  // null!
    ... t->len ...        // null dereference!

with this patch, all curr_xfer accesses are now properly synchronized.

although all accesses to curr_xfer are done under the lock, in
tegra_qspi_isr_thread() it checks for null, releases the lock and
reacquires it later in handle_cpu_based_xfer()/handle_dma_based_xfer().
there is a potential for an update in between, which could cause a null
pointer dereference.

to handle this, add a null check inside the handlers after acquiring
the lock. this ensures that if the timeout path has already cleared
curr_xfer, the handler will safely return without dereferencing the
null pointer.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2026-23207" target="_blank">CVE-2026-23207</a></h2>
                    <p><span class="feed-label">Published:</span> 2026-02-14 11:15:58 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">N/A</span></p>
                    <p><span class="feed-label">CVSS Score:</span> N/A</p>
                    <p>In the Linux kernel, the following vulnerability has been resolved:

spi: tegra210-quad: Protect curr_xfer check in IRQ handler

Now that all other accesses to curr_xfer are done under the lock,
protect the curr_xfer NULL check in tegra_qspi_isr_thread() with the
spinlock. Without this protection, the following race can occur:

  CPU0 (ISR thread)              CPU1 (timeout path)
  ----------------               -------------------
  if (!tqspi->curr_xfer)
    // sees non-NULL
                                 spin_lock()
                                 tqspi->curr_xfer = NULL
                                 spin_unlock()
  handle_*_xfer()
    spin_lock()
    t = tqspi->curr_xfer  // NULL!
    ... t->len ...        // NULL dereference!

With this patch, all curr_xfer accesses are now properly synchronized.

Although all accesses to curr_xfer are done under the lock, in
tegra_qspi_isr_thread() it checks for NULL, releases the lock and
reacquires it later in handle_cpu_based_xfer()/handle_dma_based_xfer().
There is a potential for an update in between, which could cause a NULL
pointer dereference.

To handle this, add a NULL check inside the handlers after acquiring
the lock. This ensures that if the timeout path has already cleared
curr_xfer, the handler will safely return without dereferencing the
NULL pointer.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2026-23206" data-description="in the linux kernel, the following vulnerability has been resolved:

dpaa2-switch: prevent zero_size_ptr dereference when num_ifs is zero

the driver allocates arrays for ports, fdbs, and filter blocks using
kcalloc() with ethsw->sw_attr.num_ifs as the element count. when the
device reports zero interfaces (either due to hardware configuration
or firmware issues), kcalloc(0, ...) returns zero_size_ptr (0x10)
instead of null.

later in dpaa2_switch_probe(), the napi initialization unconditionally
accesses ethsw->ports[0]->netdev, which attempts to dereference
zero_size_ptr (address 0x10), resulting in a kernel panic.

add a check to ensure num_ifs is greater than zero after retrieving
device attributes. this prevents the zero-sized allocations and
subsequent invalid pointer dereference.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2026-23206" target="_blank">CVE-2026-23206</a></h2>
                    <p><span class="feed-label">Published:</span> 2026-02-14 11:15:58 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">N/A</span></p>
                    <p><span class="feed-label">CVSS Score:</span> N/A</p>
                    <p>In the Linux kernel, the following vulnerability has been resolved:

dpaa2-switch: prevent ZERO_SIZE_PTR dereference when num_ifs is zero

The driver allocates arrays for ports, FDBs, and filter blocks using
kcalloc() with ethsw->sw_attr.num_ifs as the element count. When the
device reports zero interfaces (either due to hardware configuration
or firmware issues), kcalloc(0, ...) returns ZERO_SIZE_PTR (0x10)
instead of NULL.

Later in dpaa2_switch_probe(), the NAPI initialization unconditionally
accesses ethsw->ports[0]->netdev, which attempts to dereference
ZERO_SIZE_PTR (address 0x10), resulting in a kernel panic.

Add a check to ensure num_ifs is greater than zero after retrieving
device attributes. This prevents the zero-sized allocations and
subsequent invalid pointer dereference.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2026-23205" data-description="in the linux kernel, the following vulnerability has been resolved:

smb/client: fix memory leak in smb2_open_file()

reproducer:

  1. server: directories are exported read-only
  2. client: mount -t cifs //${server_ip}/export /mnt
  3. client: dd if=/dev/zero of=/mnt/file bs=512 count=1000 oflag=direct
  4. client: umount /mnt
  5. client: sleep 1
  6. client: modprobe -r cifs

the error message is as follows:

  =============================================================================
  bug cifs_small_rq (not tainted): objects remaining on __kmem_cache_shutdown()
  -----------------------------------------------------------------------------

  object 0x00000000d47521be @offset=14336
  ...
  warning: mm/slub.c:1251 at __kmem_cache_shutdown+0x34e/0x440, cpu#0: modprobe/1577
  ...
  call trace:
   <task>
   kmem_cache_destroy+0x94/0x190
   cifs_destroy_request_bufs+0x3e/0x50 [cifs]
   cleanup_module+0x4e/0x540 [cifs]
   __se_sys_delete_module+0x278/0x400
   __x64_sys_delete_module+0x5f/0x70
   x64_sys_call+0x2299/0x2ff0
   do_syscall_64+0x89/0x350
   entry_syscall_64_after_hwframe+0x76/0x7e
  ...
  kmem_cache_destroy cifs_small_rq: slab cache still has objects when called from cifs_destroy_request_bufs+0x3e/0x50 [cifs]
  warning: mm/slab_common.c:532 at kmem_cache_destroy+0x16b/0x190, cpu#0: modprobe/1577">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2026-23205" target="_blank">CVE-2026-23205</a></h2>
                    <p><span class="feed-label">Published:</span> 2026-02-14 11:15:58 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">N/A</span></p>
                    <p><span class="feed-label">CVSS Score:</span> N/A</p>
                    <p>In the Linux kernel, the following vulnerability has been resolved:

smb/client: fix memory leak in smb2_open_file()

Reproducer:

  1. server: directories are exported read-only
  2. client: mount -t cifs //${server_ip}/export /mnt
  3. client: dd if=/dev/zero of=/mnt/file bs=512 count=1000 oflag=direct
  4. client: umount /mnt
  5. client: sleep 1
  6. client: modprobe -r cifs

The error message is as follows:

  =============================================================================
  BUG cifs_small_rq (Not tainted): Objects remaining on __kmem_cache_shutdown()
  -----------------------------------------------------------------------------

  Object 0x00000000d47521be @offset=14336
  ...
  WARNING: mm/slub.c:1251 at __kmem_cache_shutdown+0x34e/0x440, CPU#0: modprobe/1577
  ...
  Call Trace:
   <TASK>
   kmem_cache_destroy+0x94/0x190
   cifs_destroy_request_bufs+0x3e/0x50 [cifs]
   cleanup_module+0x4e/0x540 [cifs]
   __se_sys_delete_module+0x278/0x400
   __x64_sys_delete_module+0x5f/0x70
   x64_sys_call+0x2299/0x2ff0
   do_syscall_64+0x89/0x350
   entry_SYSCALL_64_after_hwframe+0x76/0x7e
  ...
  kmem_cache_destroy cifs_small_rq: Slab cache still has objects when called from cifs_destroy_request_bufs+0x3e/0x50 [cifs]
  WARNING: mm/slab_common.c:532 at kmem_cache_destroy+0x16b/0x190, CPU#0: modprobe/1577</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2026-23204" data-description="in the linux kernel, the following vulnerability has been resolved:

net/sched: cls_u32: use skb_header_pointer_careful()

skb_header_pointer() does not fully validate negative @offset values.

use skb_header_pointer_careful() instead.

gangmin kim provided a report and a repro fooling u32_classify():

bug: kasan: slab-out-of-bounds in u32_classify+0x1180/0x11b0
net/sched/cls_u32.c:221">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2026-23204" target="_blank">CVE-2026-23204</a></h2>
                    <p><span class="feed-label">Published:</span> 2026-02-14 11:15:58 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">N/A</span></p>
                    <p><span class="feed-label">CVSS Score:</span> N/A</p>
                    <p>In the Linux kernel, the following vulnerability has been resolved:

net/sched: cls_u32: use skb_header_pointer_careful()

skb_header_pointer() does not fully validate negative @offset values.

Use skb_header_pointer_careful() instead.

GangMin Kim provided a report and a repro fooling u32_classify():

BUG: KASAN: slab-out-of-bounds in u32_classify+0x1180/0x11b0
net/sched/cls_u32.c:221</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2026-23203" data-description="in the linux kernel, the following vulnerability has been resolved:

net: cpsw_new: execute ndo_set_rx_mode callback in a work queue

commit 1767bb2d47b7 ("ipv6: mcast: don't hold rtnl for
ipv6_add_membership and mcast_join_group.") removed the rtnl lock for
ipv6_add_membership and mcast_join_group operations. however, this
change triggered the following call trace on my beaglebone black board:
  warning: net/8021q/vlan_core.c:236 at vlan_for_each+0x120/0x124, cpu#0: rpcbind/496
  rtnl: assertion failed at net/8021q/vlan_core.c (236)
  modules linked in:
  cpu: 0 uid: 997 pid: 496 comm: rpcbind not tainted 6.19.0-rc6-next-20260122-yocto-standard+ #8 preempt
  hardware name: generic am33xx (flattened device tree)
  call trace:
   unwind_backtrace from show_stack+0x28/0x2c
   show_stack from dump_stack_lvl+0x30/0x38
   dump_stack_lvl from __warn+0xb8/0x11c
   __warn from warn_slowpath_fmt+0x130/0x194
   warn_slowpath_fmt from vlan_for_each+0x120/0x124
   vlan_for_each from cpsw_add_mc_addr+0x54/0xd8
   cpsw_add_mc_addr from __hw_addr_ref_sync_dev+0xc4/0xec
   __hw_addr_ref_sync_dev from __dev_mc_add+0x78/0x88
   __dev_mc_add from igmp6_group_added+0x84/0xec
   igmp6_group_added from __ipv6_dev_mc_inc+0x1fc/0x2f0
   __ipv6_dev_mc_inc from __ipv6_sock_mc_join+0x124/0x1b4
   __ipv6_sock_mc_join from do_ipv6_setsockopt+0x84c/0x1168
   do_ipv6_setsockopt from ipv6_setsockopt+0x88/0xc8
   ipv6_setsockopt from do_sock_setsockopt+0xe8/0x19c
   do_sock_setsockopt from __sys_setsockopt+0x84/0xac
   __sys_setsockopt from ret_fast_syscall+0x0/0x5

this trace occurs because vlan_for_each() is called within
cpsw_ndo_set_rx_mode(), which expects the rtnl lock to be held.
since modifying vlan_for_each() to operate without the rtnl lock is not
straightforward, and because ndo_set_rx_mode() is invoked both with and
without the rtnl lock across different code paths, simply adding
rtnl_lock() in cpsw_ndo_set_rx_mode() is not a viable solution.

to resolve this issue, we opt to execute the actual processing within
a work queue, following the approach used by the icssg-prueth driver.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2026-23203" target="_blank">CVE-2026-23203</a></h2>
                    <p><span class="feed-label">Published:</span> 2026-02-14 11:15:58 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">N/A</span></p>
                    <p><span class="feed-label">CVSS Score:</span> N/A</p>
                    <p>In the Linux kernel, the following vulnerability has been resolved:

net: cpsw_new: Execute ndo_set_rx_mode callback in a work queue

Commit 1767bb2d47b7 ("ipv6: mcast: Don't hold RTNL for
IPV6_ADD_MEMBERSHIP and MCAST_JOIN_GROUP.") removed the RTNL lock for
IPV6_ADD_MEMBERSHIP and MCAST_JOIN_GROUP operations. However, this
change triggered the following call trace on my BeagleBone Black board:
  WARNING: net/8021q/vlan_core.c:236 at vlan_for_each+0x120/0x124, CPU#0: rpcbind/496
  RTNL: assertion failed at net/8021q/vlan_core.c (236)
  Modules linked in:
  CPU: 0 UID: 997 PID: 496 Comm: rpcbind Not tainted 6.19.0-rc6-next-20260122-yocto-standard+ #8 PREEMPT
  Hardware name: Generic AM33XX (Flattened Device Tree)
  Call trace:
   unwind_backtrace from show_stack+0x28/0x2c
   show_stack from dump_stack_lvl+0x30/0x38
   dump_stack_lvl from __warn+0xb8/0x11c
   __warn from warn_slowpath_fmt+0x130/0x194
   warn_slowpath_fmt from vlan_for_each+0x120/0x124
   vlan_for_each from cpsw_add_mc_addr+0x54/0xd8
   cpsw_add_mc_addr from __hw_addr_ref_sync_dev+0xc4/0xec
   __hw_addr_ref_sync_dev from __dev_mc_add+0x78/0x88
   __dev_mc_add from igmp6_group_added+0x84/0xec
   igmp6_group_added from __ipv6_dev_mc_inc+0x1fc/0x2f0
   __ipv6_dev_mc_inc from __ipv6_sock_mc_join+0x124/0x1b4
   __ipv6_sock_mc_join from do_ipv6_setsockopt+0x84c/0x1168
   do_ipv6_setsockopt from ipv6_setsockopt+0x88/0xc8
   ipv6_setsockopt from do_sock_setsockopt+0xe8/0x19c
   do_sock_setsockopt from __sys_setsockopt+0x84/0xac
   __sys_setsockopt from ret_fast_syscall+0x0/0x5

This trace occurs because vlan_for_each() is called within
cpsw_ndo_set_rx_mode(), which expects the RTNL lock to be held.
Since modifying vlan_for_each() to operate without the RTNL lock is not
straightforward, and because ndo_set_rx_mode() is invoked both with and
without the RTNL lock across different code paths, simply adding
rtnl_lock() in cpsw_ndo_set_rx_mode() is not a viable solution.

To resolve this issue, we opt to execute the actual processing within
a work queue, following the approach used by the icssg-prueth driver.</p>
                </div>
        
            </div>
        </div>

        <footer class="footer">
            <p>© 2025 dotne1 - Cybersecurity Portfolio</p>
        </footer>

        <script>
            function searchCVEs() {
                const input = document.getElementById('searchInput').value.toLowerCase();
                const cveEntries = document.getElementsByClassName('cve-entry');
                for (let i = 0; i < cveEntries.length; i++) {
                    const cveId = cveEntries[i].getAttribute('data-cve-id').toLowerCase();
                    const description = cveEntries[i].getAttribute('data-description');
                    if (cveId.includes(input) || description.includes(input)) {
                        cveEntries[i].style.display = '';
                    } else {
                        cveEntries[i].style.display = 'none';
                    }
                }
            }
        </script>
    </body>
    </html>
    