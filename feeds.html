
    <!DOCTYPE html>
    <html lang="en">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <meta name="description" content="Security alerts and cybersecurity news feeds">
        <meta name="keywords" content="cybersecurity news, security alerts, vulnerability feeds, threat intelligence">
        <meta name="author" content="dotne1">
        <meta property="og:title" content="Security Feeds - dotne1's Cybersecurity Portfolio">
        <meta property="og:description" content="Stay updated with the latest cybersecurity news and alerts">
        <meta property="og:type" content="website">
        <title>Security Feeds - dotne1's Cybersecurity Portfolio</title>
        <link rel="stylesheet" href="styles.css">
        <link rel="icon" type="image/x-icon" href="/favicon.ico">
    </head>
    <body>
        <nav class="navbar">
            <div class="nav-links">
                <a href="index.html" class="nav-link">Home</a>
                <a href="about-me.html" class="nav-link">About Me</a>
                <a href="projects.html" class="nav-link">Projects</a>
                <a href="resume.html" class="nav-link">Resume</a>
                <a href="feeds.html" class="nav-link">Feeds</a>
            </div>
        </nav>

        <div class="container" role="main">
            <h1 class="main-header">Security Feeds</h1>
            <div class="search-bar">
                <input type="text" id="searchInput" placeholder="Search CVEs..." onkeyup="searchCVEs()">
            </div>
            <div class="feed-preview" id="cveFeed">
                <div class="feed-header">Latest Vulnerabilities</div>
    
                <div class="cve-entry" data-cve-id="CVE-2025-13878" data-description="malformed brid/hhit records can cause `named` to terminate unexpectedly.
this issue affects bind 9 versions 9.18.40 through 9.18.43, 9.20.13 through 9.20.17, 9.21.12 through 9.21.16, 9.18.40-s1 through 9.18.43-s1, and 9.20.13-s1 through 9.20.17-s1.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-13878" target="_blank">CVE-2025-13878</a></h2>
                    <p><span class="feed-label">Published:</span> 2026-01-21 09:16:05 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-online">HIGH</span></p>
                    <p><span class="feed-label">CVSS Score:</span> 7.5</p>
                    <p>Malformed BRID/HHIT records can cause `named` to terminate unexpectedly.
This issue affects BIND 9 versions 9.18.40 through 9.18.43, 9.20.13 through 9.20.17, 9.21.12 through 9.21.16, 9.18.40-S1 through 9.18.43-S1, and 9.20.13-S1 through 9.20.17-S1.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2026-22977" data-description="in the linux kernel, the following vulnerability has been resolved:

net: sock: fix hardened usercopy panic in sock_recv_errqueue

skbuff_fclone_cache was created without defining a usercopy region,
[1] unlike skbuff_head_cache which properly whitelists the cb[] field.
[2] this causes a usercopy bug() when config_hardened_usercopy is
enabled and the kernel attempts to copy sk_buff.cb data to userspace
via sock_recv_errqueue() -> put_cmsg().

the crash occurs when: 1. tcp allocates an skb using alloc_skb_fclone()
   (from skbuff_fclone_cache) [1]
2. the skb is cloned via skb_clone() using the pre-allocated fclone
[3] 3. the cloned skb is queued to sk_error_queue for timestamp
reporting 4. userspace reads the error queue via recvmsg(msg_errqueue)
5. sock_recv_errqueue() calls put_cmsg() to copy serr->ee from skb->cb
[4] 6. __check_heap_object() fails because skbuff_fclone_cache has no
   usercopy whitelist [5]

when cloned skbs allocated from skbuff_fclone_cache are used in the
socket error queue, accessing the sock_exterr_skb structure in skb->cb
via put_cmsg() triggers a usercopy hardening violation:

[    5.379589] usercopy: kernel memory exposure attempt detected from slub object 'skbuff_fclone_cache' (offset 296, size 16)!
[    5.382796] kernel bug at mm/usercopy.c:102!
[    5.383923] oops: invalid opcode: 0000 [#1] smp kasan nopti
[    5.384903] cpu: 1 uid: 0 pid: 138 comm: poc_put_cmsg not tainted 6.12.57 #7
[    5.384903] hardware name: qemu standard pc (i440fx + piix, 1996), bios rel-1.16.3-0-ga6ed6b701f0a-prebuilt.qemu.org 04/01/2014
[    5.384903] rip: 0010:usercopy_abort+0x6c/0x80
[    5.384903] code: 1a 86 51 48 c7 c2 40 15 1a 86 41 52 48 c7 c7 c0 15 1a 86 48 0f 45 d6 48 c7 c6 80 15 1a 86 48 89 c1 49 0f 45 f3 e8 84 27 88 ff <0f> 0b 490
[    5.384903] rsp: 0018:ffffc900006f77a8 eflags: 00010246
[    5.384903] rax: 000000000000006f rbx: ffff88800f0ad2a8 rcx: 1ffffffff0f72e74
[    5.384903] rdx: 0000000000000000 rsi: 0000000000000004 rdi: ffffffff87b973a0
[    5.384903] rbp: 0000000000000010 r08: 0000000000000000 r09: fffffbfff0f72e74
[    5.384903] r10: 0000000000000003 r11: 79706f6372657375 r12: 0000000000000001
[    5.384903] r13: ffff88800f0ad2b8 r14: ffffea00003c2b40 r15: ffffea00003c2b00
[    5.384903] fs:  0000000011bc4380(0000) gs:ffff8880bf100000(0000) knlgs:0000000000000000
[    5.384903] cs:  0010 ds: 0000 es: 0000 cr0: 0000000080050033
[    5.384903] cr2: 000056aa3b8e5fe4 cr3: 000000000ea26004 cr4: 0000000000770ef0
[    5.384903] pkru: 55555554
[    5.384903] call trace:
[    5.384903]  <task>
[    5.384903]  __check_heap_object+0x9a/0xd0
[    5.384903]  __check_object_size+0x46c/0x690
[    5.384903]  put_cmsg+0x129/0x5e0
[    5.384903]  sock_recv_errqueue+0x22f/0x380
[    5.384903]  tls_sw_recvmsg+0x7ed/0x1960
[    5.384903]  ? srso_alias_return_thunk+0x5/0xfbef5
[    5.384903]  ? schedule+0x6d/0x270
[    5.384903]  ? srso_alias_return_thunk+0x5/0xfbef5
[    5.384903]  ? mutex_unlock+0x81/0xd0
[    5.384903]  ? __pfx_mutex_unlock+0x10/0x10
[    5.384903]  ? __pfx_tls_sw_recvmsg+0x10/0x10
[    5.384903]  ? _raw_spin_lock_irqsave+0x8f/0xf0
[    5.384903]  ? _raw_read_unlock_irqrestore+0x20/0x40
[    5.384903]  ? srso_alias_return_thunk+0x5/0xfbef5

the crash offset 296 corresponds to skb2->cb within skbuff_fclones:
  - sizeof(struct sk_buff) = 232 - offsetof(struct sk_buff, cb) = 40 -
  offset of skb2.cb in fclones = 232 + 40 = 272 - crash offset 296 =
  272 + 24 (inside sock_exterr_skb.ee)

this patch uses a local stack variable as a bounce buffer to avoid the hardened usercopy check failure.

[1] https://elixir.bootlin.com/linux/v6.12.62/source/net/ipv4/tcp.c#l885
[2] https://elixir.bootlin.com/linux/v6.12.62/source/net/core/skbuff.c#l5104
[3] https://elixir.bootlin.com/linux/v6.12.62/source/net/core/skbuff.c#l5566
[4] https://elixir.bootlin.com/linux/v6.12.62/source/net/core/skbuff.c#l5491
[5] https://elixir.bootlin.com/linux/v6.12.62/source/mm/slub.c#l5719">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2026-22977" target="_blank">CVE-2026-22977</a></h2>
                    <p><span class="feed-label">Published:</span> 2026-01-21 08:16:06 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">N/A</span></p>
                    <p><span class="feed-label">CVSS Score:</span> N/A</p>
                    <p>In the Linux kernel, the following vulnerability has been resolved:

net: sock: fix hardened usercopy panic in sock_recv_errqueue

skbuff_fclone_cache was created without defining a usercopy region,
[1] unlike skbuff_head_cache which properly whitelists the cb[] field.
[2] This causes a usercopy BUG() when CONFIG_HARDENED_USERCOPY is
enabled and the kernel attempts to copy sk_buff.cb data to userspace
via sock_recv_errqueue() -> put_cmsg().

The crash occurs when: 1. TCP allocates an skb using alloc_skb_fclone()
   (from skbuff_fclone_cache) [1]
2. The skb is cloned via skb_clone() using the pre-allocated fclone
[3] 3. The cloned skb is queued to sk_error_queue for timestamp
reporting 4. Userspace reads the error queue via recvmsg(MSG_ERRQUEUE)
5. sock_recv_errqueue() calls put_cmsg() to copy serr->ee from skb->cb
[4] 6. __check_heap_object() fails because skbuff_fclone_cache has no
   usercopy whitelist [5]

When cloned skbs allocated from skbuff_fclone_cache are used in the
socket error queue, accessing the sock_exterr_skb structure in skb->cb
via put_cmsg() triggers a usercopy hardening violation:

[    5.379589] usercopy: Kernel memory exposure attempt detected from SLUB object 'skbuff_fclone_cache' (offset 296, size 16)!
[    5.382796] kernel BUG at mm/usercopy.c:102!
[    5.383923] Oops: invalid opcode: 0000 [#1] SMP KASAN NOPTI
[    5.384903] CPU: 1 UID: 0 PID: 138 Comm: poc_put_cmsg Not tainted 6.12.57 #7
[    5.384903] Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS rel-1.16.3-0-ga6ed6b701f0a-prebuilt.qemu.org 04/01/2014
[    5.384903] RIP: 0010:usercopy_abort+0x6c/0x80
[    5.384903] Code: 1a 86 51 48 c7 c2 40 15 1a 86 41 52 48 c7 c7 c0 15 1a 86 48 0f 45 d6 48 c7 c6 80 15 1a 86 48 89 c1 49 0f 45 f3 e8 84 27 88 ff <0f> 0b 490
[    5.384903] RSP: 0018:ffffc900006f77a8 EFLAGS: 00010246
[    5.384903] RAX: 000000000000006f RBX: ffff88800f0ad2a8 RCX: 1ffffffff0f72e74
[    5.384903] RDX: 0000000000000000 RSI: 0000000000000004 RDI: ffffffff87b973a0
[    5.384903] RBP: 0000000000000010 R08: 0000000000000000 R09: fffffbfff0f72e74
[    5.384903] R10: 0000000000000003 R11: 79706f6372657375 R12: 0000000000000001
[    5.384903] R13: ffff88800f0ad2b8 R14: ffffea00003c2b40 R15: ffffea00003c2b00
[    5.384903] FS:  0000000011bc4380(0000) GS:ffff8880bf100000(0000) knlGS:0000000000000000
[    5.384903] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
[    5.384903] CR2: 000056aa3b8e5fe4 CR3: 000000000ea26004 CR4: 0000000000770ef0
[    5.384903] PKRU: 55555554
[    5.384903] Call Trace:
[    5.384903]  <TASK>
[    5.384903]  __check_heap_object+0x9a/0xd0
[    5.384903]  __check_object_size+0x46c/0x690
[    5.384903]  put_cmsg+0x129/0x5e0
[    5.384903]  sock_recv_errqueue+0x22f/0x380
[    5.384903]  tls_sw_recvmsg+0x7ed/0x1960
[    5.384903]  ? srso_alias_return_thunk+0x5/0xfbef5
[    5.384903]  ? schedule+0x6d/0x270
[    5.384903]  ? srso_alias_return_thunk+0x5/0xfbef5
[    5.384903]  ? mutex_unlock+0x81/0xd0
[    5.384903]  ? __pfx_mutex_unlock+0x10/0x10
[    5.384903]  ? __pfx_tls_sw_recvmsg+0x10/0x10
[    5.384903]  ? _raw_spin_lock_irqsave+0x8f/0xf0
[    5.384903]  ? _raw_read_unlock_irqrestore+0x20/0x40
[    5.384903]  ? srso_alias_return_thunk+0x5/0xfbef5

The crash offset 296 corresponds to skb2->cb within skbuff_fclones:
  - sizeof(struct sk_buff) = 232 - offsetof(struct sk_buff, cb) = 40 -
  offset of skb2.cb in fclones = 232 + 40 = 272 - crash offset 296 =
  272 + 24 (inside sock_exterr_skb.ee)

This patch uses a local stack variable as a bounce buffer to avoid the hardened usercopy check failure.

[1] https://elixir.bootlin.com/linux/v6.12.62/source/net/ipv4/tcp.c#L885
[2] https://elixir.bootlin.com/linux/v6.12.62/source/net/core/skbuff.c#L5104
[3] https://elixir.bootlin.com/linux/v6.12.62/source/net/core/skbuff.c#L5566
[4] https://elixir.bootlin.com/linux/v6.12.62/source/net/core/skbuff.c#L5491
[5] https://elixir.bootlin.com/linux/v6.12.62/source/mm/slub.c#L5719</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2026-22444" data-description="the "create core" api of apache solr 8.6 through 9.10.0 lacks sufficient input validation on some api parameters, which can cause solr to check the existence of and attempt to read file-system paths that should be disallowed by solr's  "allowpaths" security setting https://https://solr.apache.org/guide/solr/latest/configuration-guide/configuring-solr-xml.html#the-solr-element .  these read-only accesses can allow users to create cores using unexpected configsets if any are accessible via the filesystem.  on windows systems configured to allow unc paths this can additionally cause disclosure of ntlm "user" hashes. 

solr deployments are subject to this vulnerability if they meet the following criteria:
  *  solr is running in its "standalone" mode.
  *  solr's "allowpath" setting is being used to restrict file access to certain directories.
  *  solr's "create core" api is exposed and accessible to untrusted users.  this can happen if solr's  rulebasedauthorizationplugin https://solr.apache.org/guide/solr/latest/deployment-guide/rule-based-authorization-plugin.html  is disabled, or if it is enabled but the "core-admin-edit" predefined permission (or an equivalent custom permission) is given to low-trust (i.e. non-admin) user roles.

users can mitigate this by enabling solr's rulebasedauthorizationplugin (if disabled) and configuring a permission-list that prevents untrusted users from creating new solr cores.  users should also upgrade to apache solr 9.10.1 or greater, which contain fixes for this issue.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2026-22444" target="_blank">CVE-2026-22444</a></h2>
                    <p><span class="feed-label">Published:</span> 2026-01-21 08:16:06 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">N/A</span></p>
                    <p><span class="feed-label">CVSS Score:</span> N/A</p>
                    <p>The "create core" API of Apache Solr 8.6 through 9.10.0 lacks sufficient input validation on some API parameters, which can cause Solr to check the existence of and attempt to read file-system paths that should be disallowed by Solr's  "allowPaths" security setting https://https://solr.apache.org/guide/solr/latest/configuration-guide/configuring-solr-xml.html#the-solr-element .  These read-only accesses can allow users to create cores using unexpected configsets if any are accessible via the filesystem.  On Windows systems configured to allow UNC paths this can additionally cause disclosure of NTLM "user" hashes. 

Solr deployments are subject to this vulnerability if they meet the following criteria:
  *  Solr is running in its "standalone" mode.
  *  Solr's "allowPath" setting is being used to restrict file access to certain directories.
  *  Solr's "create core" API is exposed and accessible to untrusted users.  This can happen if Solr's  RuleBasedAuthorizationPlugin https://solr.apache.org/guide/solr/latest/deployment-guide/rule-based-authorization-plugin.html  is disabled, or if it is enabled but the "core-admin-edit" predefined permission (or an equivalent custom permission) is given to low-trust (i.e. non-admin) user roles.

Users can mitigate this by enabling Solr's RuleBasedAuthorizationPlugin (if disabled) and configuring a permission-list that prevents untrusted users from creating new Solr cores.  Users should also upgrade to Apache Solr 9.10.1 or greater, which contain fixes for this issue.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2026-22022" data-description="deployments of apache solr 5.3.0 through 9.10.0 that rely on solr's "rule based authorization plugin" are vulnerable to allowing unauthorized access to certain solr apis, due to insufficiently strict input validation in those components.  only deployments that meet all of the following criteria are impacted by this vulnerability:

  *  use of solr's "rulebasedauthorizationplugin"
  *  a rulebasedauthorizationplugin config (see security.json) that specifies multiple "roles"
  *  a rulebasedauthorizationplugin permission list (see security.json) that uses one or more of the following pre-defined permission rules: "config-read", "config-edit", "schema-read", "metrics-read", or "security-read".
  *  a rulebasedauthorizationplugin permission list that doesn't define the "all" pre-defined permission
  *  a networking setup that allows clients to make unfiltered network requests to solr. (i.e. user-submitted http/https requests reach solr as-is, unmodified or restricted by any intervening proxy or gateway)

users can mitigate this vulnerability by ensuring that their rulebasedauthorizationplugin configuration specifies the "all" pre-defined permission and associates the permission with an "admin" or other privileged role.  users can also upgrade to a solr version outside of the impacted range, such as the recently released solr 9.10.1.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2026-22022" target="_blank">CVE-2026-22022</a></h2>
                    <p><span class="feed-label">Published:</span> 2026-01-21 08:16:06 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">N/A</span></p>
                    <p><span class="feed-label">CVSS Score:</span> N/A</p>
                    <p>Deployments of Apache Solr 5.3.0 through 9.10.0 that rely on Solr's "Rule Based Authorization Plugin" are vulnerable to allowing unauthorized access to certain Solr APIs, due to insufficiently strict input validation in those components.  Only deployments that meet all of the following criteria are impacted by this vulnerability:

  *  Use of Solr's "RuleBasedAuthorizationPlugin"
  *  A RuleBasedAuthorizationPlugin config (see security.json) that specifies multiple "roles"
  *  A RuleBasedAuthorizationPlugin permission list (see security.json) that uses one or more of the following pre-defined permission rules: "config-read", "config-edit", "schema-read", "metrics-read", or "security-read".
  *  A RuleBasedAuthorizationPlugin permission list that doesn't define the "all" pre-defined permission
  *  A networking setup that allows clients to make unfiltered network requests to Solr. (i.e. user-submitted HTTP/HTTPS requests reach Solr as-is, unmodified or restricted by any intervening proxy or gateway)

Users can mitigate this vulnerability by ensuring that their RuleBasedAuthorizationPlugin configuration specifies the "all" pre-defined permission and associates the permission with an "admin" or other privileged role.  Users can also upgrade to a Solr version outside of the impacted range, such as the recently released Solr 9.10.1.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-14083" data-description="a flaw was found in the keycloak admin rest api. this vulnerability allows the exposure of backend schema and rules, potentially leading to targeted attacks or privilege escalation via improper access control.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-14083" target="_blank">CVE-2025-14083</a></h2>
                    <p><span class="feed-label">Published:</span> 2026-01-21 07:16:02 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">LOW</span></p>
                    <p><span class="feed-label">CVSS Score:</span> 2.7</p>
                    <p>A flaw was found in the Keycloak Admin REST API. This vulnerability allows the exposure of backend schema and rules, potentially leading to targeted attacks or privilege escalation via improper access control.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2026-0988" data-description="a flaw was found in glib. missing validation of offset and count parameters in the g_buffered_input_stream_peek() function can lead to an integer overflow during length calculation. when specially crafted values are provided, this overflow results in an incorrect size being passed to memcpy(), triggering a buffer overflow. this can cause application crashes, leading to a denial of service (dos).">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2026-0988" target="_blank">CVE-2026-0988</a></h2>
                    <p><span class="feed-label">Published:</span> 2026-01-21 06:15:55 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">LOW</span></p>
                    <p><span class="feed-label">CVSS Score:</span> 3.7</p>
                    <p>A flaw was found in glib. Missing validation of offset and count parameters in the g_buffered_input_stream_peek() function can lead to an integer overflow during length calculation. When specially crafted values are provided, this overflow results in an incorrect size being passed to memcpy(), triggering a buffer overflow. This can cause application crashes, leading to a Denial of Service (DoS).</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2026-0663" data-description="denial-of-service vulnerability in m-files server versions before 26.1.15632.3 allows an authenticated attacker with vault administrator privileges to crash the m-files server process by calling a vulnerable api endpoint.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2026-0663" target="_blank">CVE-2026-0663</a></h2>
                    <p><span class="feed-label">Published:</span> 2026-01-21 05:15:50 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">N/A</span></p>
                    <p><span class="feed-label">CVSS Score:</span> N/A</p>
                    <p>Denial-of-service vulnerability in M-Files Server versions before 26.1.15632.3 allows an authenticated attacker with vault administrator privileges to crash the M-Files Server process by calling a vulnerable API endpoint.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2026-24016" data-description="the installer of serverview agents for windows provided by fsas technologies inc. may insecurely load dynamic link libraries. arbitrary code may be executed with the administrator privilege when the installer is executed.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2026-24016" target="_blank">CVE-2026-24016</a></h2>
                    <p><span class="feed-label">Published:</span> 2026-01-21 02:15:59 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-online">HIGH</span></p>
                    <p><span class="feed-label">CVSS Score:</span> 7.8</p>
                    <p>The installer of ServerView Agents for Windows provided by Fsas Technologies Inc. may insecurely load Dynamic Link Libraries. Arbitrary code may be executed with the administrator privilege when the installer is executed.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2026-24061" data-description="telnetd in gnu inetutils through 2.7 allows remote authentication bypass via a "-f root" value for the user environment variable.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2026-24061" target="_blank">CVE-2026-24061</a></h2>
                    <p><span class="feed-label">Published:</span> 2026-01-21 01:16:01 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-online">CRITICAL</span></p>
                    <p><span class="feed-label">CVSS Score:</span> 9.8</p>
                    <p>telnetd in GNU Inetutils through 2.7 allows remote authentication bypass via a "-f root" value for the USER environment variable.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2026-22976" data-description="in the linux kernel, the following vulnerability has been resolved:

net/sched: sch_qfq: fix null deref when deactivating inactive aggregate in qfq_reset

`qfq_class->leaf_qdisc->q.qlen > 0` does not imply that the class
itself is active.

two qfq_class objects may point to the same leaf_qdisc. this happens
when:

1. one qfq qdisc is attached to the dev as the root qdisc, and

2. another qfq qdisc is temporarily referenced (e.g., via qdisc_get()
/ qdisc_put()) and is pending to be destroyed, as in function
tc_new_tfilter.

when packets are enqueued through the root qfq qdisc, the shared
leaf_qdisc->q.qlen increases. at the same time, the second qfq
qdisc triggers qdisc_put and qdisc_destroy: the qdisc enters
qfq_reset() with its own q->q.qlen == 0, but its class's leaf
qdisc->q.qlen > 0. therefore, the qfq_reset would wrongly deactivate
an inactive aggregate and trigger a null-deref in qfq_deactivate_agg:

[    0.903172] bug: kernel null pointer dereference, address: 0000000000000000
[    0.903571] #pf: supervisor write access in kernel mode
[    0.903860] #pf: error_code(0x0002) - not-present page
[    0.904177] pgd 10299b067 p4d 10299b067 pud 10299c067 pmd 0
[    0.904502] oops: oops: 0002 [#1] smp nopti
[    0.904737] cpu: 0 uid: 0 pid: 135 comm: exploit not tainted 6.19.0-rc3+ #2 none
[    0.905157] hardware name: qemu standard pc (i440fx + piix, 1996), bios rel-1.17.0-0-gb52ca86e094d-prebuilt.qemu.org 04/01/2014
[    0.905754] rip: 0010:qfq_deactivate_agg (include/linux/list.h:992 (discriminator 2) include/linux/list.h:1006 (discriminator 2) net/sched/sch_qfq.c:1367 (discriminator 2) net/sched/sch_qfq.c:1393 (discriminator 2))
[    0.906046] code: 0f 84 4d 01 00 00 48 89 70 18 8b 4b 10 48 c7 c2 ff ff ff ff 48 8b 78 08 48 d3 e2 48 21 f2 48 2b 13 48 8b 30 48 d3 ea 8b 4b 18 0

code starting with the faulting instruction
===========================================
   0:	0f 84 4d 01 00 00    	je     0x153
   6:	48 89 70 18          	mov    %rsi,0x18(%rax)
   a:	8b 4b 10             	mov    0x10(%rbx),%ecx
   d:	48 c7 c2 ff ff ff ff 	mov    $0xffffffffffffffff,%rdx
  14:	48 8b 78 08          	mov    0x8(%rax),%rdi
  18:	48 d3 e2             	shl    %cl,%rdx
  1b:	48 21 f2             	and    %rsi,%rdx
  1e:	48 2b 13             	sub    (%rbx),%rdx
  21:	48 8b 30             	mov    (%rax),%rsi
  24:	48 d3 ea             	shr    %cl,%rdx
  27:	8b 4b 18             	mov    0x18(%rbx),%ecx
	...
[    0.907095] rsp: 0018:ffffc900004a39a0 eflags: 00010246
[    0.907368] rax: ffff8881043a0880 rbx: ffff888102953340 rcx: 0000000000000000
[    0.907723] rdx: 0000000000000000 rsi: 0000000000000000 rdi: 0000000000000000
[    0.908100] rbp: ffff888102952180 r08: 0000000000000000 r09: 0000000000000000
[    0.908451] r10: ffff8881043a0000 r11: 0000000000000000 r12: ffff888102952000
[    0.908804] r13: ffff888102952180 r14: ffff8881043a0ad8 r15: ffff8881043a0880
[    0.909179] fs:  000000002a1a0380(0000) gs:ffff888196d8d000(0000) knlgs:0000000000000000
[    0.909572] cs:  0010 ds: 0000 es: 0000 cr0: 0000000080050033
[    0.909857] cr2: 0000000000000000 cr3: 0000000102993002 cr4: 0000000000772ef0
[    0.910247] pkru: 55555554
[    0.910391] call trace:
[    0.910527]  <task>
[    0.910638]  qfq_reset_qdisc (net/sched/sch_qfq.c:357 net/sched/sch_qfq.c:1485)
[    0.910826]  qdisc_reset (include/linux/skbuff.h:2195 include/linux/skbuff.h:2501 include/linux/skbuff.h:3424 include/linux/skbuff.h:3430 net/sched/sch_generic.c:1036)
[    0.911040]  __qdisc_destroy (net/sched/sch_generic.c:1076)
[    0.911236]  tc_new_tfilter (net/sched/cls_api.c:2447)
[    0.911447]  rtnetlink_rcv_msg (net/core/rtnetlink.c:6958)
[    0.911663]  ? __pfx_rtnetlink_rcv_msg (net/core/rtnetlink.c:6861)
[    0.911894]  netlink_rcv_skb (net/netlink/af_netlink.c:2550)
[    0.912100]  netlink_unicast (net/netlink/af_netlink.c:1319 net/netlink/af_netlink.c:1344)
[    0.912296]  ? __alloc_skb (net/core/skbuff.c:706)
[    0.912484]  netlink_sendmsg (net/netlink/af
---truncated---">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2026-22976" target="_blank">CVE-2026-22976</a></h2>
                    <p><span class="feed-label">Published:</span> 2026-01-21 01:16:01 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">N/A</span></p>
                    <p><span class="feed-label">CVSS Score:</span> N/A</p>
                    <p>In the Linux kernel, the following vulnerability has been resolved:

net/sched: sch_qfq: Fix NULL deref when deactivating inactive aggregate in qfq_reset

`qfq_class->leaf_qdisc->q.qlen > 0` does not imply that the class
itself is active.

Two qfq_class objects may point to the same leaf_qdisc. This happens
when:

1. one QFQ qdisc is attached to the dev as the root qdisc, and

2. another QFQ qdisc is temporarily referenced (e.g., via qdisc_get()
/ qdisc_put()) and is pending to be destroyed, as in function
tc_new_tfilter.

When packets are enqueued through the root QFQ qdisc, the shared
leaf_qdisc->q.qlen increases. At the same time, the second QFQ
qdisc triggers qdisc_put and qdisc_destroy: the qdisc enters
qfq_reset() with its own q->q.qlen == 0, but its class's leaf
qdisc->q.qlen > 0. Therefore, the qfq_reset would wrongly deactivate
an inactive aggregate and trigger a null-deref in qfq_deactivate_agg:

[    0.903172] BUG: kernel NULL pointer dereference, address: 0000000000000000
[    0.903571] #PF: supervisor write access in kernel mode
[    0.903860] #PF: error_code(0x0002) - not-present page
[    0.904177] PGD 10299b067 P4D 10299b067 PUD 10299c067 PMD 0
[    0.904502] Oops: Oops: 0002 [#1] SMP NOPTI
[    0.904737] CPU: 0 UID: 0 PID: 135 Comm: exploit Not tainted 6.19.0-rc3+ #2 NONE
[    0.905157] Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS rel-1.17.0-0-gb52ca86e094d-prebuilt.qemu.org 04/01/2014
[    0.905754] RIP: 0010:qfq_deactivate_agg (include/linux/list.h:992 (discriminator 2) include/linux/list.h:1006 (discriminator 2) net/sched/sch_qfq.c:1367 (discriminator 2) net/sched/sch_qfq.c:1393 (discriminator 2))
[    0.906046] Code: 0f 84 4d 01 00 00 48 89 70 18 8b 4b 10 48 c7 c2 ff ff ff ff 48 8b 78 08 48 d3 e2 48 21 f2 48 2b 13 48 8b 30 48 d3 ea 8b 4b 18 0

Code starting with the faulting instruction
===========================================
   0:	0f 84 4d 01 00 00    	je     0x153
   6:	48 89 70 18          	mov    %rsi,0x18(%rax)
   a:	8b 4b 10             	mov    0x10(%rbx),%ecx
   d:	48 c7 c2 ff ff ff ff 	mov    $0xffffffffffffffff,%rdx
  14:	48 8b 78 08          	mov    0x8(%rax),%rdi
  18:	48 d3 e2             	shl    %cl,%rdx
  1b:	48 21 f2             	and    %rsi,%rdx
  1e:	48 2b 13             	sub    (%rbx),%rdx
  21:	48 8b 30             	mov    (%rax),%rsi
  24:	48 d3 ea             	shr    %cl,%rdx
  27:	8b 4b 18             	mov    0x18(%rbx),%ecx
	...
[    0.907095] RSP: 0018:ffffc900004a39a0 EFLAGS: 00010246
[    0.907368] RAX: ffff8881043a0880 RBX: ffff888102953340 RCX: 0000000000000000
[    0.907723] RDX: 0000000000000000 RSI: 0000000000000000 RDI: 0000000000000000
[    0.908100] RBP: ffff888102952180 R08: 0000000000000000 R09: 0000000000000000
[    0.908451] R10: ffff8881043a0000 R11: 0000000000000000 R12: ffff888102952000
[    0.908804] R13: ffff888102952180 R14: ffff8881043a0ad8 R15: ffff8881043a0880
[    0.909179] FS:  000000002a1a0380(0000) GS:ffff888196d8d000(0000) knlGS:0000000000000000
[    0.909572] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
[    0.909857] CR2: 0000000000000000 CR3: 0000000102993002 CR4: 0000000000772ef0
[    0.910247] PKRU: 55555554
[    0.910391] Call Trace:
[    0.910527]  <TASK>
[    0.910638]  qfq_reset_qdisc (net/sched/sch_qfq.c:357 net/sched/sch_qfq.c:1485)
[    0.910826]  qdisc_reset (include/linux/skbuff.h:2195 include/linux/skbuff.h:2501 include/linux/skbuff.h:3424 include/linux/skbuff.h:3430 net/sched/sch_generic.c:1036)
[    0.911040]  __qdisc_destroy (net/sched/sch_generic.c:1076)
[    0.911236]  tc_new_tfilter (net/sched/cls_api.c:2447)
[    0.911447]  rtnetlink_rcv_msg (net/core/rtnetlink.c:6958)
[    0.911663]  ? __pfx_rtnetlink_rcv_msg (net/core/rtnetlink.c:6861)
[    0.911894]  netlink_rcv_skb (net/netlink/af_netlink.c:2550)
[    0.912100]  netlink_unicast (net/netlink/af_netlink.c:1319 net/netlink/af_netlink.c:1344)
[    0.912296]  ? __alloc_skb (net/core/skbuff.c:706)
[    0.912484]  netlink_sendmsg (net/netlink/af
---truncated---</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-14559" data-description="a flaw was found in the keycloak-services component of keycloak. this vulnerability allows the issuance of access and refresh tokens for disabled users, leading to unauthorized use of previously revoked privileges, via a business logic vulnerability in the token exchange implementation when a privileged client invokes the token exchange flow.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-14559" target="_blank">CVE-2025-14559</a></h2>
                    <p><span class="feed-label">Published:</span> 2026-01-21 01:16:00 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">MEDIUM</span></p>
                    <p><span class="feed-label">CVSS Score:</span> 6.5</p>
                    <p>A flaw was found in the keycloak-services component of Keycloak. This vulnerability allows the issuance of access and refresh tokens for disabled users, leading to unauthorized use of previously revoked privileges, via a business logic vulnerability in the Token Exchange implementation when a privileged client invokes the token exchange flow.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2026-1035" data-description="a flaw was found in the keycloak server during refresh token processing, specifically in the tokenmanager class responsible for enforcing refresh token reuse policies. when strict refresh token rotation is enabled, the validation and update of refresh token usage are not performed atomically. this allows concurrent refresh requests to bypass single-use enforcement and issue multiple access tokens from the same refresh token. as a result, keycloak’s refresh token rotation hardening can be undermined.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2026-1035" target="_blank">CVE-2026-1035</a></h2>
                    <p><span class="feed-label">Published:</span> 2026-01-21 00:15:46 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">LOW</span></p>
                    <p><span class="feed-label">CVSS Score:</span> 3.1</p>
                    <p>A flaw was found in the Keycloak server during refresh token processing, specifically in the TokenManager class responsible for enforcing refresh token reuse policies. When strict refresh token rotation is enabled, the validation and update of refresh token usage are not performed atomically. This allows concurrent refresh requests to bypass single-use enforcement and issue multiple access tokens from the same refresh token. As a result, Keycloak’s refresh token rotation hardening can be undermined.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2026-24026" data-description="rejected reason: not used">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2026-24026" target="_blank">CVE-2026-24026</a></h2>
                    <p><span class="feed-label">Published:</span> 2026-01-20 23:16:11 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">N/A</span></p>
                    <p><span class="feed-label">CVSS Score:</span> N/A</p>
                    <p>Rejected reason: Not used</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2026-24025" data-description="rejected reason: not used">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2026-24025" target="_blank">CVE-2026-24025</a></h2>
                    <p><span class="feed-label">Published:</span> 2026-01-20 23:16:11 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">N/A</span></p>
                    <p><span class="feed-label">CVSS Score:</span> N/A</p>
                    <p>Rejected reason: Not used</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2026-24024" data-description="rejected reason: not used">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2026-24024" target="_blank">CVE-2026-24024</a></h2>
                    <p><span class="feed-label">Published:</span> 2026-01-20 23:16:11 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">N/A</span></p>
                    <p><span class="feed-label">CVSS Score:</span> N/A</p>
                    <p>Rejected reason: Not used</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2026-24023" data-description="rejected reason: not used">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2026-24023" target="_blank">CVE-2026-24023</a></h2>
                    <p><span class="feed-label">Published:</span> 2026-01-20 23:16:11 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">N/A</span></p>
                    <p><span class="feed-label">CVSS Score:</span> N/A</p>
                    <p>Rejected reason: Not used</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2026-24022" data-description="rejected reason: not used">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2026-24022" target="_blank">CVE-2026-24022</a></h2>
                    <p><span class="feed-label">Published:</span> 2026-01-20 23:16:11 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">N/A</span></p>
                    <p><span class="feed-label">CVSS Score:</span> N/A</p>
                    <p>Rejected reason: Not used</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2026-24021" data-description="rejected reason: not used">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2026-24021" target="_blank">CVE-2026-24021</a></h2>
                    <p><span class="feed-label">Published:</span> 2026-01-20 23:16:10 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">N/A</span></p>
                    <p><span class="feed-label">CVSS Score:</span> N/A</p>
                    <p>Rejected reason: Not used</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2026-24020" data-description="rejected reason: not used">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2026-24020" target="_blank">CVE-2026-24020</a></h2>
                    <p><span class="feed-label">Published:</span> 2026-01-20 23:16:10 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">N/A</span></p>
                    <p><span class="feed-label">CVSS Score:</span> N/A</p>
                    <p>Rejected reason: Not used</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-68133" data-description="everest is an ev charging software stack. in versions 2025.9.0 and below, an attacker can exhaust the operating system's memory and cause the module to terminate by initiating an unlimited number of tcp connections that never proceed to iso 15118-2 communication. this is possible because a new thread is started for each incoming plain tcp or tls socket connection before any verification occurs, and the verification performed is too permissive. the everest processes and all its modules shut down, affecting all evse functionality. this issue is fixed in version 2025.10.0.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-68133" target="_blank">CVE-2025-68133</a></h2>
                    <p><span class="feed-label">Published:</span> 2026-01-20 21:15:45 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-online">HIGH</span></p>
                    <p><span class="feed-label">CVSS Score:</span> 7.4</p>
                    <p>EVerest is an EV charging software stack. In versions 2025.9.0 and below, an attacker can exhaust the operating system's memory and cause the module to terminate by initiating an unlimited number of TCP connections that never proceed to ISO 15118-2 communication. This is possible because a new thread is started for each incoming plain TCP or TLS socket connection before any verification occurs, and the verification performed is too permissive. The EVerest processes and all its modules shut down, affecting all EVSE functionality. This issue is fixed in version 2025.10.0.</p>
                </div>
        
            </div>
        </div>

        <footer class="footer">
            <p>© 2025 dotne1 - Cybersecurity Portfolio</p>
        </footer>

        <script>
            function searchCVEs() {
                const input = document.getElementById('searchInput').value.toLowerCase();
                const cveEntries = document.getElementsByClassName('cve-entry');
                for (let i = 0; i < cveEntries.length; i++) {
                    const cveId = cveEntries[i].getAttribute('data-cve-id').toLowerCase();
                    const description = cveEntries[i].getAttribute('data-description');
                    if (cveId.includes(input) || description.includes(input)) {
                        cveEntries[i].style.display = '';
                    } else {
                        cveEntries[i].style.display = 'none';
                    }
                }
            }
        </script>
    </body>
    </html>
    