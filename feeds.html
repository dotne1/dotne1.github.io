
    <!DOCTYPE html>
    <html lang="en">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <meta name="description" content="Security alerts and cybersecurity news feeds">
        <meta name="keywords" content="cybersecurity news, security alerts, vulnerability feeds, threat intelligence">
        <meta name="author" content="dotne1">
        <meta property="og:title" content="Security Feeds - dotne1's Cybersecurity Portfolio">
        <meta property="og:description" content="Stay updated with the latest cybersecurity news and alerts">
        <meta property="og:type" content="website">
        <title>Security Feeds - dotne1's Cybersecurity Portfolio</title>
        <link rel="stylesheet" href="styles.css">
        <link rel="icon" type="image/x-icon" href="/favicon.ico">
    </head>
    <body>
        <nav class="navbar">
            <div class="nav-links">
                <a href="index.html" class="nav-link">Home</a>
                <a href="about-me.html" class="nav-link">About Me</a>
                <a href="projects.html" class="nav-link">Projects</a>
                <a href="resume.html" class="nav-link">Resume</a>
                <a href="feeds.html" class="nav-link">Feeds</a>
            </div>
        </nav>

        <div class="container" role="main">
            <h1 class="main-header">Security Feeds</h1>
            <div class="search-bar">
                <input type="text" id="searchInput" placeholder="Search CVEs..." onkeyup="searchCVEs()">
            </div>
            <div class="feed-preview" id="cveFeed">
                <div class="feed-header">Latest Vulnerabilities</div>
    
                <div class="cve-entry" data-cve-id="CVE-2025-10599" data-description="a security flaw has been discovered in itsourcecode web-based internet laboratory management system 1.0. impacted is the function user::authenticateuser of the file login.php. performing manipulation of the argument user_email results in sql injection. remote exploitation of the attack is possible. the exploit has been released to the public and may be exploited.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-10599" target="_blank">CVE-2025-10599</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-09-17 11:15:34 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-online">HIGH</span></p>
                    <p><span class="feed-label">CVSS Score:</span> 7.3</p>
                    <p>A security flaw has been discovered in itsourcecode Web-Based Internet Laboratory Management System 1.0. Impacted is the function User::AuthenticateUser of the file login.php. Performing manipulation of the argument user_email results in sql injection. Remote exploitation of the attack is possible. The exploit has been released to the public and may be exploited.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-10598" data-description="a vulnerability was identified in sourcecodester pet grooming management software 1.0. this issue affects some unknown processing of the file /admin/search_product.php. such manipulation of the argument group_id leads to sql injection. the attack may be launched remotely. the exploit is publicly available and might be used.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-10598" target="_blank">CVE-2025-10598</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-09-17 11:15:34 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-online">HIGH</span></p>
                    <p><span class="feed-label">CVSS Score:</span> 7.3</p>
                    <p>A vulnerability was identified in SourceCodester Pet Grooming Management Software 1.0. This issue affects some unknown processing of the file /admin/search_product.php. Such manipulation of the argument group_id leads to sql injection. The attack may be launched remotely. The exploit is publicly available and might be used.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-10597" data-description="a vulnerability was determined in kidaze courseselectionsystem up to 42cd892b40a18d50bd4ed1905fa89f939173a464. this vulnerability affects unknown code of the file /profilers/priprofile/count2.php. this manipulation of the argument cname causes sql injection. the attack may be initiated remotely. this product uses a rolling release model to deliver continuous updates. as a result, specific version information for affected or updated releases is not available.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-10597" target="_blank">CVE-2025-10597</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-09-17 11:15:34 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-online">HIGH</span></p>
                    <p><span class="feed-label">CVSS Score:</span> 7.3</p>
                    <p>A vulnerability was determined in kidaze CourseSelectionSystem up to 42cd892b40a18d50bd4ed1905fa89f939173a464. This vulnerability affects unknown code of the file /Profilers/PriProfile/COUNT2.php. This manipulation of the argument cname causes sql injection. The attack may be initiated remotely. This product uses a rolling release model to deliver continuous updates. As a result, specific version information for affected or updated releases is not available.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-9862" data-description="server-side request forgery (ssrf) vulnerability in ghost allows an attacker to access internal resources.this issue affects ghost: from 6.0.0 through 6.0.8, from 5.99.0 through 5.130.3.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-9862" target="_blank">CVE-2025-9862</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-09-17 10:15:43 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">N/A</span></p>
                    <p><span class="feed-label">CVSS Score:</span> N/A</p>
                    <p>Server-Side Request Forgery (SSRF) vulnerability in Ghost allows an attacker to access internal resources.This issue affects Ghost: from 6.0.0 through 6.0.8, from 5.99.0 through 5.130.3.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-57055" data-description="wondercms 3.5.0 is vulnerable to server-side request forgery (ssrf) in the custom module installation functionality. an authenticated administrator can supply a malicious url via the pluginthemeurl post parameter. the server fetches the provided url using curl_exec() without sufficient validation, allowing the attacker to force internal or external http requests.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-57055" target="_blank">CVE-2025-57055</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-09-17 10:15:43 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">N/A</span></p>
                    <p><span class="feed-label">CVSS Score:</span> N/A</p>
                    <p>WonderCMS 3.5.0 is vulnerable to Server-Side Request Forgery (SSRF) in the custom module installation functionality. An authenticated administrator can supply a malicious URL via the pluginThemeUrl POST parameter. The server fetches the provided URL using curl_exec() without sufficient validation, allowing the attacker to force internal or external HTTP requests.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-54390" data-description="a cross-site request forgery (csrf) vulnerability exists in the resetpasswordrequest operation of zimbra collaboration (zcs) when the zimbrafeatureresetpasswordstatus attribute is enabled. an attacker can exploit this by tricking an authenticated user into visiting a malicious webpage that silently sends a crafted soap request to reset the user's password. the vulnerability stems from a lack of csrf token validation on the endpoint, allowing password resets without the user's consent.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-54390" target="_blank">CVE-2025-54390</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-09-17 10:15:43 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">MEDIUM</span></p>
                    <p><span class="feed-label">CVSS Score:</span> 6.3</p>
                    <p>A Cross-Site Request Forgery (CSRF) vulnerability exists in the ResetPasswordRequest operation of Zimbra Collaboration (ZCS) when the zimbraFeatureResetPasswordStatus attribute is enabled. An attacker can exploit this by tricking an authenticated user into visiting a malicious webpage that silently sends a crafted SOAP request to reset the user's password. The vulnerability stems from a lack of CSRF token validation on the endpoint, allowing password resets without the user's consent.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-40933" data-description="apache::authany::cookie v0.201 or earlier for perl generates session ids insecurely.

session ids are generated using an md5 hash of the epoch time and a call to the built-in rand function. the epoch time may be guessed, if it is not leaked from the http date header. the built-in rand function is unsuitable for cryptographic usage.

predicable session ids could allow an attacker to gain access to systems.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-40933" target="_blank">CVE-2025-40933</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-09-17 10:15:42 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">N/A</span></p>
                    <p><span class="feed-label">CVSS Score:</span> N/A</p>
                    <p>Apache::AuthAny::Cookie v0.201 or earlier for Perl generates session ids insecurely.

Session ids are generated using an MD5 hash of the epoch time and a call to the built-in rand function. The epoch time may be guessed, if it is not leaked from the HTTP Date header. The built-in rand function is unsuitable for cryptographic usage.

Predicable session ids could allow an attacker to gain access to systems.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-10596" data-description="a vulnerability was found in sourcecodester online exam form submission 1.0. this affects an unknown part of the file /index.php. the manipulation of the argument usn results in sql injection. the attack can be launched remotely. the exploit has been made public and could be used.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-10596" target="_blank">CVE-2025-10596</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-09-17 10:15:42 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-online">HIGH</span></p>
                    <p><span class="feed-label">CVSS Score:</span> 7.3</p>
                    <p>A vulnerability was found in SourceCodester Online Exam Form Submission 1.0. This affects an unknown part of the file /index.php. The manipulation of the argument usn results in sql injection. The attack can be launched remotely. The exploit has been made public and could be used.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-10595" data-description="a vulnerability has been found in sourcecodester online student file management system 1.0. affected by this issue is some unknown functionality of the file /admin/delete_user.php. the manipulation of the argument user_id leads to sql injection. the attack can be initiated remotely. the exploit has been disclosed to the public and may be used.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-10595" target="_blank">CVE-2025-10595</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-09-17 10:15:42 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">MEDIUM</span></p>
                    <p><span class="feed-label">CVSS Score:</span> 6.3</p>
                    <p>A vulnerability has been found in SourceCodester Online Student File Management System 1.0. Affected by this issue is some unknown functionality of the file /admin/delete_user.php. The manipulation of the argument user_id leads to sql injection. The attack can be initiated remotely. The exploit has been disclosed to the public and may be used.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-10205" data-description="use of a one-way hash with a predictable salt vulnerability in abb flxeon.this issue affects flxeon: through 9.3.5. and newer versions">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-10205" target="_blank">CVE-2025-10205</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-09-17 10:15:41 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-online">HIGH</span></p>
                    <p><span class="feed-label">CVSS Score:</span> 8.8</p>
                    <p>Use of a One-Way Hash with a Predictable Salt vulnerability in ABB FLXEON.This issue affects FLXEON: through 9.3.5. and newer versions</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2024-48842" data-description="use of hard-coded credentials vulnerability in abb flxeon.this issue affects flxeon: through 9.3.5 and newer versions">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2024-48842" target="_blank">CVE-2024-48842</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-09-17 10:15:41 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-online">HIGH</span></p>
                    <p><span class="feed-label">CVSS Score:</span> 7.0</p>
                    <p>Use of Hard-coded Credentials vulnerability in ABB FLXEON.This issue affects FLXEON: through 9.3.5 and newer versions</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2023-53368" data-description="in the linux kernel, the following vulnerability has been resolved:

tracing: fix race issue between cpu buffer write and swap

warning happened in rb_end_commit() at code:
	if (rb_warn_on(cpu_buffer, !local_read(&cpu_buffer->committing)))

  warning: cpu: 0 pid: 139 at kernel/trace/ring_buffer.c:3142
	rb_commit+0x402/0x4a0
  call trace:
   ring_buffer_unlock_commit+0x42/0x250
   trace_buffer_unlock_commit_regs+0x3b/0x250
   trace_event_buffer_commit+0xe5/0x440
   trace_event_buffer_reserve+0x11c/0x150
   trace_event_raw_event_sched_switch+0x23c/0x2c0
   __traceiter_sched_switch+0x59/0x80
   __schedule+0x72b/0x1580
   schedule+0x92/0x120
   worker_thread+0xa0/0x6f0

it is because the race between writing event into cpu buffer and swapping
cpu buffer through file per_cpu/cpu0/snapshot:

  write on cpu 0             swap buffer by per_cpu/cpu0/snapshot on cpu 1
  --------                   --------
                             tracing_snapshot_write()
                               [...]

  ring_buffer_lock_reserve()
    cpu_buffer = buffer->buffers[cpu]; // 1. suppose find 'cpu_buffer_a';
    [...]
    rb_reserve_next_event()
      [...]

                               ring_buffer_swap_cpu()
                                 if (local_read(&cpu_buffer_a->committing))
                                     goto out_dec;
                                 if (local_read(&cpu_buffer_b->committing))
                                     goto out_dec;
                                 buffer_a->buffers[cpu] = cpu_buffer_b;
                                 buffer_b->buffers[cpu] = cpu_buffer_a;
                                 // 2. cpu_buffer has swapped here.

      rb_start_commit(cpu_buffer);
      if (unlikely(read_once(cpu_buffer->buffer)
          != buffer)) { // 3. this check passed due to 'cpu_buffer->buffer'
        [...]           //    has not changed here.
        return null;
      }
                                 cpu_buffer_b->buffer = buffer_a;
                                 cpu_buffer_a->buffer = buffer_b;
                                 [...]

      // 4. reserve event from 'cpu_buffer_a'.

  ring_buffer_unlock_commit()
    [...]
    cpu_buffer = buffer->buffers[cpu]; // 5. now find 'cpu_buffer_b' !!!
    rb_commit(cpu_buffer)
      rb_end_commit()  // 6. warn for the wrong 'committing' state !!!

based on above analysis, we can easily reproduce by following testcase:
  ``` bash
  #!/bin/bash

  dmesg -n 7
  sysctl -w kernel.panic_on_warn=1
  tr=/sys/kernel/tracing
  echo 7 > ${tr}/buffer_size_kb
  echo "sched:sched_switch" > ${tr}/set_event
  while [ true ]; do
          echo 1 > ${tr}/per_cpu/cpu0/snapshot
  done &
  while [ true ]; do
          echo 1 > ${tr}/per_cpu/cpu0/snapshot
  done &
  while [ true ]; do
          echo 1 > ${tr}/per_cpu/cpu0/snapshot
  done &
  ```

to fix it, iiuc, we can use smp_call_function_single() to do the swap on
the target cpu where the buffer is located, so that above race would be
avoided.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2023-53368" target="_blank">CVE-2023-53368</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-09-17 10:15:41 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">N/A</span></p>
                    <p><span class="feed-label">CVSS Score:</span> N/A</p>
                    <p>In the Linux kernel, the following vulnerability has been resolved:

tracing: Fix race issue between cpu buffer write and swap

Warning happened in rb_end_commit() at code:
	if (RB_WARN_ON(cpu_buffer, !local_read(&cpu_buffer->committing)))

  WARNING: CPU: 0 PID: 139 at kernel/trace/ring_buffer.c:3142
	rb_commit+0x402/0x4a0
  Call Trace:
   ring_buffer_unlock_commit+0x42/0x250
   trace_buffer_unlock_commit_regs+0x3b/0x250
   trace_event_buffer_commit+0xe5/0x440
   trace_event_buffer_reserve+0x11c/0x150
   trace_event_raw_event_sched_switch+0x23c/0x2c0
   __traceiter_sched_switch+0x59/0x80
   __schedule+0x72b/0x1580
   schedule+0x92/0x120
   worker_thread+0xa0/0x6f0

It is because the race between writing event into cpu buffer and swapping
cpu buffer through file per_cpu/cpu0/snapshot:

  Write on CPU 0             Swap buffer by per_cpu/cpu0/snapshot on CPU 1
  --------                   --------
                             tracing_snapshot_write()
                               [...]

  ring_buffer_lock_reserve()
    cpu_buffer = buffer->buffers[cpu]; // 1. Suppose find 'cpu_buffer_a';
    [...]
    rb_reserve_next_event()
      [...]

                               ring_buffer_swap_cpu()
                                 if (local_read(&cpu_buffer_a->committing))
                                     goto out_dec;
                                 if (local_read(&cpu_buffer_b->committing))
                                     goto out_dec;
                                 buffer_a->buffers[cpu] = cpu_buffer_b;
                                 buffer_b->buffers[cpu] = cpu_buffer_a;
                                 // 2. cpu_buffer has swapped here.

      rb_start_commit(cpu_buffer);
      if (unlikely(READ_ONCE(cpu_buffer->buffer)
          != buffer)) { // 3. This check passed due to 'cpu_buffer->buffer'
        [...]           //    has not changed here.
        return NULL;
      }
                                 cpu_buffer_b->buffer = buffer_a;
                                 cpu_buffer_a->buffer = buffer_b;
                                 [...]

      // 4. Reserve event from 'cpu_buffer_a'.

  ring_buffer_unlock_commit()
    [...]
    cpu_buffer = buffer->buffers[cpu]; // 5. Now find 'cpu_buffer_b' !!!
    rb_commit(cpu_buffer)
      rb_end_commit()  // 6. WARN for the wrong 'committing' state !!!

Based on above analysis, we can easily reproduce by following testcase:
  ``` bash
  #!/bin/bash

  dmesg -n 7
  sysctl -w kernel.panic_on_warn=1
  TR=/sys/kernel/tracing
  echo 7 > ${TR}/buffer_size_kb
  echo "sched:sched_switch" > ${TR}/set_event
  while [ true ]; do
          echo 1 > ${TR}/per_cpu/cpu0/snapshot
  done &
  while [ true ]; do
          echo 1 > ${TR}/per_cpu/cpu0/snapshot
  done &
  while [ true ]; do
          echo 1 > ${TR}/per_cpu/cpu0/snapshot
  done &
  ```

To fix it, IIUC, we can use smp_call_function_single() to do the swap on
the target cpu where the buffer is located, so that above race would be
avoided.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2023-53367" data-description="in the linux kernel, the following vulnerability has been resolved:

accel/habanalabs: fix mem leak in capture user mappings

this commit fixes a memory leak caused when clearing the user_mappings
info when a new context is opened immediately after user_mapping is
captured and a hard reset is performed.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2023-53367" target="_blank">CVE-2023-53367</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-09-17 10:15:41 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">N/A</span></p>
                    <p><span class="feed-label">CVSS Score:</span> N/A</p>
                    <p>In the Linux kernel, the following vulnerability has been resolved:

accel/habanalabs: fix mem leak in capture user mappings

This commit fixes a memory leak caused when clearing the user_mappings
info when a new context is opened immediately after user_mapping is
captured and a hard reset is performed.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2023-53366" data-description="in the linux kernel, the following vulnerability has been resolved:

block: be a bit more careful in checking for null bdev while polling

wei reports a crash with an application using polled io:

pgd 14265e067 p4d 14265e067 pud 47ec50067 pmd 0
oops: 0000 [#1] smp
cpu: 0 pid: 21915 comm: iocore_0 kdump: loaded tainted: g s                5.12.0-0_fbk12_clang_7346_g1bb6f2e7058f #1
hardware name: wiwynn delta lake mp t8/delta lake-class2, bios y3dlm08 04/10/2022
rip: 0010:bio_poll+0x25/0x200
code: 0f 1f 44 00 00 0f 1f 44 00 00 55 41 57 41 56 41 55 41 54 53 48 83 ec 28 65 48 8b 04 25 28 00 00 00 48 89 44 24 20 48 8b 47 08 <48> 8b 80 70 02 00 00 4c 8b 70 50 8b 6f 34 31 db 83 fd ff 75 25 65
rsp: 0018:ffffc90005fafdf8 eflags: 00010292
rax: 0000000000000000 rbx: 0000000000000000 rcx: 74b43cd65dd66600
rdx: 0000000000000003 rsi: ffffc90005fafe78 rdi: ffff8884b614e140
rbp: ffff88849964df78 r08: 0000000000000000 r09: 0000000000000008
r10: 0000000000000000 r11: 0000000000000000 r12: ffff88849964df00
r13: ffffc90005fafe78 r14: ffff888137d3c378 r15: 0000000000000001
fs:  00007fd195000640(0000) gs:ffff88903f400000(0000) knlgs:0000000000000000
cs:  0010 ds: 0000 es: 0000 cr0: 0000000080050033
cr2: 0000000000000270 cr3: 0000000466121001 cr4: 00000000007706f0
dr0: 0000000000000000 dr1: 0000000000000000 dr2: 0000000000000000
dr3: 0000000000000000 dr6: 00000000fffe0ff0 dr7: 0000000000000400
pkru: 55555554
call trace:
 iocb_bio_iopoll+0x1d/0x30
 io_do_iopoll+0xac/0x250
 __se_sys_io_uring_enter+0x3c5/0x5a0
 ? __x64_sys_write+0x89/0xd0
 do_syscall_64+0x2d/0x40
 entry_syscall_64_after_hwframe+0x44/0xae
rip: 0033:0x94f225d
code: 24 cc 00 00 00 41 8b 84 24 d0 00 00 00 c1 e0 04 83 e0 10 41 09 c2 8b 33 8b 53 04 4c 8b 43 18 4c 63 4b 0c b8 aa 01 00 00 0f 05 <85> c0 0f 88 85 00 00 00 29 03 45 84 f6 0f 84 88 00 00 00 41 f6 c7
rsp: 002b:00007fd194ffcd88 eflags: 00000202 orig_rax: 00000000000001aa
rax: ffffffffffffffda rbx: 00007fd194ffcdc0 rcx: 00000000094f225d
rdx: 0000000000000000 rsi: 0000000000000000 rdi: 0000000000000007
rbp: 00007fd194ffcdb0 r08: 0000000000000000 r09: 0000000000000008
r10: 0000000000000001 r11: 0000000000000202 r12: 00007fd269d68030
r13: 0000000000000000 r14: 0000000000000001 r15: 0000000000000000

which is due to bio->bi_bdev being null. this can happen if we have two
tasks doing polled io, and task b ends up completing io from task a if
they are sharing a poll queue. if task b completes the io and puts the
bio into our cache, then it can allocate that bio again before task a
is done polling for it. as that would necessitate a preempt between the
two tasks, it's enough to just be a bit more careful in checking for
whether or not bio->bi_bdev is null.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2023-53366" target="_blank">CVE-2023-53366</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-09-17 10:15:40 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">N/A</span></p>
                    <p><span class="feed-label">CVSS Score:</span> N/A</p>
                    <p>In the Linux kernel, the following vulnerability has been resolved:

block: be a bit more careful in checking for NULL bdev while polling

Wei reports a crash with an application using polled IO:

PGD 14265e067 P4D 14265e067 PUD 47ec50067 PMD 0
Oops: 0000 [#1] SMP
CPU: 0 PID: 21915 Comm: iocore_0 Kdump: loaded Tainted: G S                5.12.0-0_fbk12_clang_7346_g1bb6f2e7058f #1
Hardware name: Wiwynn Delta Lake MP T8/Delta Lake-Class2, BIOS Y3DLM08 04/10/2022
RIP: 0010:bio_poll+0x25/0x200
Code: 0f 1f 44 00 00 0f 1f 44 00 00 55 41 57 41 56 41 55 41 54 53 48 83 ec 28 65 48 8b 04 25 28 00 00 00 48 89 44 24 20 48 8b 47 08 <48> 8b 80 70 02 00 00 4c 8b 70 50 8b 6f 34 31 db 83 fd ff 75 25 65
RSP: 0018:ffffc90005fafdf8 EFLAGS: 00010292
RAX: 0000000000000000 RBX: 0000000000000000 RCX: 74b43cd65dd66600
RDX: 0000000000000003 RSI: ffffc90005fafe78 RDI: ffff8884b614e140
RBP: ffff88849964df78 R08: 0000000000000000 R09: 0000000000000008
R10: 0000000000000000 R11: 0000000000000000 R12: ffff88849964df00
R13: ffffc90005fafe78 R14: ffff888137d3c378 R15: 0000000000000001
FS:  00007fd195000640(0000) GS:ffff88903f400000(0000) knlGS:0000000000000000
CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
CR2: 0000000000000270 CR3: 0000000466121001 CR4: 00000000007706f0
DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000
DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400
PKRU: 55555554
Call Trace:
 iocb_bio_iopoll+0x1d/0x30
 io_do_iopoll+0xac/0x250
 __se_sys_io_uring_enter+0x3c5/0x5a0
 ? __x64_sys_write+0x89/0xd0
 do_syscall_64+0x2d/0x40
 entry_SYSCALL_64_after_hwframe+0x44/0xae
RIP: 0033:0x94f225d
Code: 24 cc 00 00 00 41 8b 84 24 d0 00 00 00 c1 e0 04 83 e0 10 41 09 c2 8b 33 8b 53 04 4c 8b 43 18 4c 63 4b 0c b8 aa 01 00 00 0f 05 <85> c0 0f 88 85 00 00 00 29 03 45 84 f6 0f 84 88 00 00 00 41 f6 c7
RSP: 002b:00007fd194ffcd88 EFLAGS: 00000202 ORIG_RAX: 00000000000001aa
RAX: ffffffffffffffda RBX: 00007fd194ffcdc0 RCX: 00000000094f225d
RDX: 0000000000000000 RSI: 0000000000000000 RDI: 0000000000000007
RBP: 00007fd194ffcdb0 R08: 0000000000000000 R09: 0000000000000008
R10: 0000000000000001 R11: 0000000000000202 R12: 00007fd269d68030
R13: 0000000000000000 R14: 0000000000000001 R15: 0000000000000000

which is due to bio->bi_bdev being NULL. This can happen if we have two
tasks doing polled IO, and task B ends up completing IO from task A if
they are sharing a poll queue. If task B completes the IO and puts the
bio into our cache, then it can allocate that bio again before task A
is done polling for it. As that would necessitate a preempt between the
two tasks, it's enough to just be a bit more careful in checking for
whether or not bio->bi_bdev is NULL.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2023-53365" data-description="in the linux kernel, the following vulnerability has been resolved:

ip6mr: fix skb_under_panic in ip6mr_cache_report()

skbuff: skb_under_panic: text:ffffffff88771f69 len:56 put:-4
 head:ffff88805f86a800 data:ffff887f5f86a850 tail:0x88 end:0x2c0 dev:pim6reg
 ------------[ cut here ]------------
 kernel bug at net/core/skbuff.c:192!
 invalid opcode: 0000 [#1] preempt smp kasan
 cpu: 2 pid: 22968 comm: kworker/2:11 not tainted 6.5.0-rc3-00044-g0a8db05b571a #236
 hardware name: qemu standard pc (i440fx + piix, 1996), bios 1.15.0-1 04/01/2014
 workqueue: ipv6_addrconf addrconf_dad_work
 rip: 0010:skb_panic+0x152/0x1d0
 call trace:
  <task>
  skb_push+0xc4/0xe0
  ip6mr_cache_report+0xd69/0x19b0
  reg_vif_xmit+0x406/0x690
  dev_hard_start_xmit+0x17e/0x6e0
  __dev_queue_xmit+0x2d6a/0x3d20
  vlan_dev_hard_start_xmit+0x3ab/0x5c0
  dev_hard_start_xmit+0x17e/0x6e0
  __dev_queue_xmit+0x2d6a/0x3d20
  neigh_connected_output+0x3ed/0x570
  ip6_finish_output2+0x5b5/0x1950
  ip6_finish_output+0x693/0x11c0
  ip6_output+0x24b/0x880
  nf_hook.constprop.0+0xfd/0x530
  ndisc_send_skb+0x9db/0x1400
  ndisc_send_rs+0x12a/0x6c0
  addrconf_dad_completed+0x3c9/0xea0
  addrconf_dad_work+0x849/0x1420
  process_one_work+0xa22/0x16e0
  worker_thread+0x679/0x10c0
  ret_from_fork+0x28/0x60
  ret_from_fork_asm+0x11/0x20

when setup a vlan device on dev pim6reg, dad ns packet may sent on reg_vif_xmit().
reg_vif_xmit()
    ip6mr_cache_report()
        skb_push(skb, -skb_network_offset(pkt));//skb_network_offset(pkt) is 4
and skb_push declared as:
	void *skb_push(struct sk_buff *skb, unsigned int len);
		skb->data -= len;
		//0xffff88805f86a84c - 0xfffffffc = 0xffff887f5f86a850
skb->data is set to 0xffff887f5f86a850, which is invalid mem addr, lead to skb_push() fails.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2023-53365" target="_blank">CVE-2023-53365</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-09-17 10:15:40 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">N/A</span></p>
                    <p><span class="feed-label">CVSS Score:</span> N/A</p>
                    <p>In the Linux kernel, the following vulnerability has been resolved:

ip6mr: Fix skb_under_panic in ip6mr_cache_report()

skbuff: skb_under_panic: text:ffffffff88771f69 len:56 put:-4
 head:ffff88805f86a800 data:ffff887f5f86a850 tail:0x88 end:0x2c0 dev:pim6reg
 ------------[ cut here ]------------
 kernel BUG at net/core/skbuff.c:192!
 invalid opcode: 0000 [#1] PREEMPT SMP KASAN
 CPU: 2 PID: 22968 Comm: kworker/2:11 Not tainted 6.5.0-rc3-00044-g0a8db05b571a #236
 Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.15.0-1 04/01/2014
 Workqueue: ipv6_addrconf addrconf_dad_work
 RIP: 0010:skb_panic+0x152/0x1d0
 Call Trace:
  <TASK>
  skb_push+0xc4/0xe0
  ip6mr_cache_report+0xd69/0x19b0
  reg_vif_xmit+0x406/0x690
  dev_hard_start_xmit+0x17e/0x6e0
  __dev_queue_xmit+0x2d6a/0x3d20
  vlan_dev_hard_start_xmit+0x3ab/0x5c0
  dev_hard_start_xmit+0x17e/0x6e0
  __dev_queue_xmit+0x2d6a/0x3d20
  neigh_connected_output+0x3ed/0x570
  ip6_finish_output2+0x5b5/0x1950
  ip6_finish_output+0x693/0x11c0
  ip6_output+0x24b/0x880
  NF_HOOK.constprop.0+0xfd/0x530
  ndisc_send_skb+0x9db/0x1400
  ndisc_send_rs+0x12a/0x6c0
  addrconf_dad_completed+0x3c9/0xea0
  addrconf_dad_work+0x849/0x1420
  process_one_work+0xa22/0x16e0
  worker_thread+0x679/0x10c0
  ret_from_fork+0x28/0x60
  ret_from_fork_asm+0x11/0x20

When setup a vlan device on dev pim6reg, DAD ns packet may sent on reg_vif_xmit().
reg_vif_xmit()
    ip6mr_cache_report()
        skb_push(skb, -skb_network_offset(pkt));//skb_network_offset(pkt) is 4
And skb_push declared as:
	void *skb_push(struct sk_buff *skb, unsigned int len);
		skb->data -= len;
		//0xffff88805f86a84c - 0xfffffffc = 0xffff887f5f86a850
skb->data is set to 0xffff887f5f86a850, which is invalid mem addr, lead to skb_push() fails.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2023-53364" data-description="in the linux kernel, the following vulnerability has been resolved:

regulator: da9063: better fix null deref with partial dt

two versions of the original patch were sent but v1 was merged instead
of v2 due to a mistake.

so update to v2.

the advantage of v2 is that it completely avoids dereferencing the pointer,
even just to take the address, which may fix problems with some compilers.
both versions work on my gcc 9.4 but use the safer one.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2023-53364" target="_blank">CVE-2023-53364</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-09-17 10:15:40 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">N/A</span></p>
                    <p><span class="feed-label">CVSS Score:</span> N/A</p>
                    <p>In the Linux kernel, the following vulnerability has been resolved:

regulator: da9063: better fix null deref with partial DT

Two versions of the original patch were sent but V1 was merged instead
of V2 due to a mistake.

So update to V2.

The advantage of V2 is that it completely avoids dereferencing the pointer,
even just to take the address, which may fix problems with some compilers.
Both versions work on my gcc 9.4 but use the safer one.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2023-53363" data-description="in the linux kernel, the following vulnerability has been resolved:

pci: fix use-after-free in pci_bus_release_domain_nr()

commit c14f7ccc9f5d ("pci: assign pci domain ids by ida_alloc()")
introduced a use-after-free bug in the bus removal cleanup. the issue was
found with kfence:

  [   19.293351] bug: kfence: use-after-free read in pci_bus_release_domain_nr+0x10/0x70

  [   19.302817] use-after-free read at 0x000000007f3b80eb (in kfence-#115):
  [   19.309677]  pci_bus_release_domain_nr+0x10/0x70
  [   19.309691]  dw_pcie_host_deinit+0x28/0x78
  [   19.309702]  tegra_pcie_deinit_controller+0x1c/0x38 [pcie_tegra194]
  [   19.309734]  tegra_pcie_dw_probe+0x648/0xb28 [pcie_tegra194]
  [   19.309752]  platform_probe+0x90/0xd8
  ...

  [   19.311457] kfence-#115: 0x00000000063a155a-0x00000000ba698da8, size=1072, cache=kmalloc-2k

  [   19.311469] allocated by task 96 on cpu 10 at 19.279323s:
  [   19.311562]  __kmem_cache_alloc_node+0x260/0x278
  [   19.311571]  kmalloc_trace+0x24/0x30
  [   19.311580]  pci_alloc_bus+0x24/0xa0
  [   19.311590]  pci_register_host_bridge+0x48/0x4b8
  [   19.311601]  pci_scan_root_bus_bridge+0xc0/0xe8
  [   19.311613]  pci_host_probe+0x18/0xc0
  [   19.311623]  dw_pcie_host_init+0x2c0/0x568
  [   19.311630]  tegra_pcie_dw_probe+0x610/0xb28 [pcie_tegra194]
  [   19.311647]  platform_probe+0x90/0xd8
  ...

  [   19.311782] freed by task 96 on cpu 10 at 19.285833s:
  [   19.311799]  release_pcibus_dev+0x30/0x40
  [   19.311808]  device_release+0x30/0x90
  [   19.311814]  kobject_put+0xa8/0x120
  [   19.311832]  device_unregister+0x20/0x30
  [   19.311839]  pci_remove_bus+0x78/0x88
  [   19.311850]  pci_remove_root_bus+0x5c/0x98
  [   19.311860]  dw_pcie_host_deinit+0x28/0x78
  [   19.311866]  tegra_pcie_deinit_controller+0x1c/0x38 [pcie_tegra194]
  [   19.311883]  tegra_pcie_dw_probe+0x648/0xb28 [pcie_tegra194]
  [   19.311900]  platform_probe+0x90/0xd8
  ...

  [   19.313579] cpu: 10 pid: 96 comm: kworker/u24:2 not tainted 6.2.0 #4
  [   19.320171] hardware name:  /, bios 1.0-d7fb19b 08/10/2022
  [   19.325852] workqueue: events_unbound deferred_probe_work_func

the stack trace is a bit misleading as dw_pcie_host_deinit() doesn't
directly call pci_bus_release_domain_nr(). the issue turns out to be in
pci_remove_root_bus() which first calls pci_remove_bus() which frees the
struct pci_bus when its struct device is released. then
pci_bus_release_domain_nr() is called and accesses the freed struct
pci_bus. reordering these fixes the issue.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2023-53363" target="_blank">CVE-2023-53363</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-09-17 10:15:40 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">N/A</span></p>
                    <p><span class="feed-label">CVSS Score:</span> N/A</p>
                    <p>In the Linux kernel, the following vulnerability has been resolved:

PCI: Fix use-after-free in pci_bus_release_domain_nr()

Commit c14f7ccc9f5d ("PCI: Assign PCI domain IDs by ida_alloc()")
introduced a use-after-free bug in the bus removal cleanup. The issue was
found with kfence:

  [   19.293351] BUG: KFENCE: use-after-free read in pci_bus_release_domain_nr+0x10/0x70

  [   19.302817] Use-after-free read at 0x000000007f3b80eb (in kfence-#115):
  [   19.309677]  pci_bus_release_domain_nr+0x10/0x70
  [   19.309691]  dw_pcie_host_deinit+0x28/0x78
  [   19.309702]  tegra_pcie_deinit_controller+0x1c/0x38 [pcie_tegra194]
  [   19.309734]  tegra_pcie_dw_probe+0x648/0xb28 [pcie_tegra194]
  [   19.309752]  platform_probe+0x90/0xd8
  ...

  [   19.311457] kfence-#115: 0x00000000063a155a-0x00000000ba698da8, size=1072, cache=kmalloc-2k

  [   19.311469] allocated by task 96 on cpu 10 at 19.279323s:
  [   19.311562]  __kmem_cache_alloc_node+0x260/0x278
  [   19.311571]  kmalloc_trace+0x24/0x30
  [   19.311580]  pci_alloc_bus+0x24/0xa0
  [   19.311590]  pci_register_host_bridge+0x48/0x4b8
  [   19.311601]  pci_scan_root_bus_bridge+0xc0/0xe8
  [   19.311613]  pci_host_probe+0x18/0xc0
  [   19.311623]  dw_pcie_host_init+0x2c0/0x568
  [   19.311630]  tegra_pcie_dw_probe+0x610/0xb28 [pcie_tegra194]
  [   19.311647]  platform_probe+0x90/0xd8
  ...

  [   19.311782] freed by task 96 on cpu 10 at 19.285833s:
  [   19.311799]  release_pcibus_dev+0x30/0x40
  [   19.311808]  device_release+0x30/0x90
  [   19.311814]  kobject_put+0xa8/0x120
  [   19.311832]  device_unregister+0x20/0x30
  [   19.311839]  pci_remove_bus+0x78/0x88
  [   19.311850]  pci_remove_root_bus+0x5c/0x98
  [   19.311860]  dw_pcie_host_deinit+0x28/0x78
  [   19.311866]  tegra_pcie_deinit_controller+0x1c/0x38 [pcie_tegra194]
  [   19.311883]  tegra_pcie_dw_probe+0x648/0xb28 [pcie_tegra194]
  [   19.311900]  platform_probe+0x90/0xd8
  ...

  [   19.313579] CPU: 10 PID: 96 Comm: kworker/u24:2 Not tainted 6.2.0 #4
  [   19.320171] Hardware name:  /, BIOS 1.0-d7fb19b 08/10/2022
  [   19.325852] Workqueue: events_unbound deferred_probe_work_func

The stack trace is a bit misleading as dw_pcie_host_deinit() doesn't
directly call pci_bus_release_domain_nr(). The issue turns out to be in
pci_remove_root_bus() which first calls pci_remove_bus() which frees the
struct pci_bus when its struct device is released. Then
pci_bus_release_domain_nr() is called and accesses the freed struct
pci_bus. Reordering these fixes the issue.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2023-53362" data-description="in the linux kernel, the following vulnerability has been resolved:

bus: fsl-mc: don't assume child devices are all fsl-mc devices

changes in vfio caused a pseudo-device to be created as child of
fsl-mc devices causing a crash [1] when trying to bind a fsl-mc
device to vfio. fix this by checking the device type when enumerating
fsl-mc child devices.

[1]
modules linked in:
internal error: oops: 0000000096000004 [#1] preempt smp
cpu: 6 pid: 1289 comm: sh not tainted 6.2.0-rc5-00047-g7c46948a6e9c #2
hardware name: nxp layerscape lx2160ardb (dt)
pstate: 60000005 (nzcv daif -pan -uao -tco -dit -ssbs btype=--)
pc : mc_send_command+0x24/0x1f0
lr : dprc_get_obj_region+0xfc/0x1c0
sp : ffff80000a88b900
x29: ffff80000a88b900 x28: ffff48a9429e1400 x27: 00000000000002b2
x26: ffff48a9429e1718 x25: 0000000000000000 x24: 0000000000000000
x23: ffffd59331ba3918 x22: ffffd59331ba3000 x21: 0000000000000000
x20: ffff80000a88b9b8 x19: 0000000000000000 x18: 0000000000000001
x17: 7270642f636d2d6c x16: 73662e3030303030 x15: ffffffffffffffff
x14: ffffd59330f1d668 x13: ffff48a8727dc389 x12: ffff48a8727dc386
x11: 0000000000000002 x10: 00008ceaf02f35d4 x9 : 0000000000000012
x8 : 0000000000000000 x7 : 0000000000000006 x6 : ffff80000a88bab0
x5 : 0000000000000000 x4 : 0000000000000000 x3 : ffff80000a88b9e8
x2 : ffff80000a88b9e8 x1 : 0000000000000000 x0 : ffff48a945142b80
call trace:
 mc_send_command+0x24/0x1f0
 dprc_get_obj_region+0xfc/0x1c0
 fsl_mc_device_add+0x340/0x590
 fsl_mc_obj_device_add+0xd0/0xf8
 dprc_scan_objects+0x1c4/0x340
 dprc_scan_container+0x38/0x60
 vfio_fsl_mc_probe+0x9c/0xf8
 fsl_mc_driver_probe+0x24/0x70
 really_probe+0xbc/0x2a8
 __driver_probe_device+0x78/0xe0
 device_driver_attach+0x30/0x68
 bind_store+0xa8/0x130
 drv_attr_store+0x24/0x38
 sysfs_kf_write+0x44/0x60
 kernfs_fop_write_iter+0x128/0x1b8
 vfs_write+0x334/0x448
 ksys_write+0x68/0xf0
 __arm64_sys_write+0x1c/0x28
 invoke_syscall+0x44/0x108
 el0_svc_common.constprop.1+0x94/0xf8
 do_el0_svc+0x38/0xb0
 el0_svc+0x20/0x50
 el0t_64_sync_handler+0x98/0xc0
 el0t_64_sync+0x174/0x178
code: aa0103f4 a9025bf5 d5384100 b9400801 (79401260)
---[ end trace 0000000000000000 ]---">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2023-53362" target="_blank">CVE-2023-53362</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-09-17 10:15:40 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">N/A</span></p>
                    <p><span class="feed-label">CVSS Score:</span> N/A</p>
                    <p>In the Linux kernel, the following vulnerability has been resolved:

bus: fsl-mc: don't assume child devices are all fsl-mc devices

Changes in VFIO caused a pseudo-device to be created as child of
fsl-mc devices causing a crash [1] when trying to bind a fsl-mc
device to VFIO. Fix this by checking the device type when enumerating
fsl-mc child devices.

[1]
Modules linked in:
Internal error: Oops: 0000000096000004 [#1] PREEMPT SMP
CPU: 6 PID: 1289 Comm: sh Not tainted 6.2.0-rc5-00047-g7c46948a6e9c #2
Hardware name: NXP Layerscape LX2160ARDB (DT)
pstate: 60000005 (nZCv daif -PAN -UAO -TCO -DIT -SSBS BTYPE=--)
pc : mc_send_command+0x24/0x1f0
lr : dprc_get_obj_region+0xfc/0x1c0
sp : ffff80000a88b900
x29: ffff80000a88b900 x28: ffff48a9429e1400 x27: 00000000000002b2
x26: ffff48a9429e1718 x25: 0000000000000000 x24: 0000000000000000
x23: ffffd59331ba3918 x22: ffffd59331ba3000 x21: 0000000000000000
x20: ffff80000a88b9b8 x19: 0000000000000000 x18: 0000000000000001
x17: 7270642f636d2d6c x16: 73662e3030303030 x15: ffffffffffffffff
x14: ffffd59330f1d668 x13: ffff48a8727dc389 x12: ffff48a8727dc386
x11: 0000000000000002 x10: 00008ceaf02f35d4 x9 : 0000000000000012
x8 : 0000000000000000 x7 : 0000000000000006 x6 : ffff80000a88bab0
x5 : 0000000000000000 x4 : 0000000000000000 x3 : ffff80000a88b9e8
x2 : ffff80000a88b9e8 x1 : 0000000000000000 x0 : ffff48a945142b80
Call trace:
 mc_send_command+0x24/0x1f0
 dprc_get_obj_region+0xfc/0x1c0
 fsl_mc_device_add+0x340/0x590
 fsl_mc_obj_device_add+0xd0/0xf8
 dprc_scan_objects+0x1c4/0x340
 dprc_scan_container+0x38/0x60
 vfio_fsl_mc_probe+0x9c/0xf8
 fsl_mc_driver_probe+0x24/0x70
 really_probe+0xbc/0x2a8
 __driver_probe_device+0x78/0xe0
 device_driver_attach+0x30/0x68
 bind_store+0xa8/0x130
 drv_attr_store+0x24/0x38
 sysfs_kf_write+0x44/0x60
 kernfs_fop_write_iter+0x128/0x1b8
 vfs_write+0x334/0x448
 ksys_write+0x68/0xf0
 __arm64_sys_write+0x1c/0x28
 invoke_syscall+0x44/0x108
 el0_svc_common.constprop.1+0x94/0xf8
 do_el0_svc+0x38/0xb0
 el0_svc+0x20/0x50
 el0t_64_sync_handler+0x98/0xc0
 el0t_64_sync+0x174/0x178
Code: aa0103f4 a9025bf5 d5384100 b9400801 (79401260)
---[ end trace 0000000000000000 ]---</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2023-53361" data-description="in the linux kernel, the following vulnerability has been resolved:

loongarch: mm: add p?d_leaf() definitions

when i do ltp test, ltp test case ksm06 caused panic at
	break_ksm_pmd_entry
	  -> pmd_leaf (huge page table but false)
	  -> pte_present (panic)

the reason is pmd_leaf() is not defined, so like commit 501b81046701
("mips: mm: add p?d_leaf() definitions") add p?d_leaf() definition for
loongarch.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2023-53361" target="_blank">CVE-2023-53361</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-09-17 10:15:40 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">N/A</span></p>
                    <p><span class="feed-label">CVSS Score:</span> N/A</p>
                    <p>In the Linux kernel, the following vulnerability has been resolved:

LoongArch: mm: Add p?d_leaf() definitions

When I do LTP test, LTP test case ksm06 caused panic at
	break_ksm_pmd_entry
	  -> pmd_leaf (Huge page table but False)
	  -> pte_present (panic)

The reason is pmd_leaf() is not defined, So like commit 501b81046701
("mips: mm: add p?d_leaf() definitions") add p?d_leaf() definition for
LoongArch.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2023-53360" data-description="in the linux kernel, the following vulnerability has been resolved:

nfsv4.2: rework scratch handling for read_plus (again)

i found that the read code might send multiple requests using the same
nfs_pgio_header, but nfs4_proc_read_setup() is only called once. this is
how we ended up occasionally double-freeing the scratch buffer, but also
means we set a null pointer but non-zero length to the xdr scratch
buffer. this results in an oops the first time decoding needs to copy
something to scratch, which frequently happens when decoding read_plus
hole segments.

i fix this by moving scratch handling into the pageio read code. i
provide a function to allocate scratch space for decoding read replies,
and free the scratch buffer when the nfs_pgio_header is freed.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2023-53360" target="_blank">CVE-2023-53360</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-09-17 10:15:40 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">N/A</span></p>
                    <p><span class="feed-label">CVSS Score:</span> N/A</p>
                    <p>In the Linux kernel, the following vulnerability has been resolved:

NFSv4.2: Rework scratch handling for READ_PLUS (again)

I found that the read code might send multiple requests using the same
nfs_pgio_header, but nfs4_proc_read_setup() is only called once. This is
how we ended up occasionally double-freeing the scratch buffer, but also
means we set a NULL pointer but non-zero length to the xdr scratch
buffer. This results in an oops the first time decoding needs to copy
something to scratch, which frequently happens when decoding READ_PLUS
hole segments.

I fix this by moving scratch handling into the pageio read code. I
provide a function to allocate scratch space for decoding read replies,
and free the scratch buffer when the nfs_pgio_header is freed.</p>
                </div>
        
            </div>
        </div>

        <footer class="footer">
            <p>© 2025 dotne1 - Cybersecurity Portfolio</p>
        </footer>

        <script>
            function searchCVEs() {
                const input = document.getElementById('searchInput').value.toLowerCase();
                const cveEntries = document.getElementsByClassName('cve-entry');
                for (let i = 0; i < cveEntries.length; i++) {
                    const cveId = cveEntries[i].getAttribute('data-cve-id').toLowerCase();
                    const description = cveEntries[i].getAttribute('data-description');
                    if (cveId.includes(input) || description.includes(input)) {
                        cveEntries[i].style.display = '';
                    } else {
                        cveEntries[i].style.display = 'none';
                    }
                }
            }
        </script>
    </body>
    </html>
    