
    <!DOCTYPE html>
    <html lang="en">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <meta name="description" content="Security alerts and cybersecurity news feeds">
        <meta name="keywords" content="cybersecurity news, security alerts, vulnerability feeds, threat intelligence">
        <meta name="author" content="dotne1">
        <meta property="og:title" content="Security Feeds - dotne1's Cybersecurity Portfolio">
        <meta property="og:description" content="Stay updated with the latest cybersecurity news and alerts">
        <meta property="og:type" content="website">
        <title>Security Feeds - dotne1's Cybersecurity Portfolio</title>
        <link rel="stylesheet" href="styles.css">
        <link rel="icon" type="image/x-icon" href="/favicon.ico">
    </head>
    <body>
        <nav class="navbar">
            <div class="nav-links">
                <a href="index.html" class="nav-link">Home</a>
                <a href="about-me.html" class="nav-link">About Me</a>
                <a href="projects.html" class="nav-link">Projects</a>
                <a href="resume.html" class="nav-link">Resume</a>
                <a href="feeds.html" class="nav-link">Feeds</a>
            </div>
        </nav>

        <div class="container" role="main">
            <h1 class="main-header">Security Feeds</h1>
            <div class="search-bar">
                <input type="text" id="searchInput" placeholder="Search CVEs..." onkeyup="searchCVEs()">
            </div>
            <div class="feed-preview" id="cveFeed">
                <div class="feed-header">Latest Vulnerabilities</div>
    
                <div class="cve-entry" data-cve-id="CVE-2025-9088" data-description="a vulnerability was found in tenda ac20 16.03.08.12. this vulnerability affects the function save_virtualser_data of the file /goform/formsetvirtualser. the manipulation of the argument list leads to stack-based buffer overflow. the attack can be initiated remotely. the exploit has been disclosed to the public and may be used.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-9088" target="_blank">CVE-2025-9088</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-08-16 18:15:26 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-online">HIGH</span></p>
                    <p><span class="feed-label">CVSS Score:</span> 8.8</p>
                    <p>A vulnerability was found in Tenda AC20 16.03.08.12. This vulnerability affects the function save_virtualser_data of the file /goform/formSetVirtualSer. The manipulation of the argument list leads to stack-based buffer overflow. The attack can be initiated remotely. The exploit has been disclosed to the public and may be used.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-9087" data-description="a vulnerability has been found in tenda ac20 16.03.08.12. this affects the function set_qosmib_list of the file /goform/setnetcontrollist of the component setnetcontrollist endpoint. the manipulation of the argument list leads to stack-based buffer overflow. it is possible to initiate the attack remotely. the exploit has been disclosed to the public and may be used.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-9087" target="_blank">CVE-2025-9087</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-08-16 18:15:26 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-online">HIGH</span></p>
                    <p><span class="feed-label">CVSS Score:</span> 8.8</p>
                    <p>A vulnerability has been found in Tenda AC20 16.03.08.12. This affects the function set_qosMib_list of the file /goform/SetNetControlList of the component SetNetControlList Endpoint. The manipulation of the argument list leads to stack-based buffer overflow. It is possible to initiate the attack remotely. The exploit has been disclosed to the public and may be used.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2023-4515" data-description="in the linux kernel, the following vulnerability has been resolved:

ksmbd: validate command request size

in commit 2b9b8f3b68ed ("ksmbd: validate command payload size"), except
for smb2_oplock_break_he command, the request size of other commands
is not checked, it's not expected. fix it by add check for request
size of other commands.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2023-4515" target="_blank">CVE-2023-4515</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-08-16 09:15:27 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">N/A</span></p>
                    <p><span class="feed-label">CVSS Score:</span> N/A</p>
                    <p>In the Linux kernel, the following vulnerability has been resolved:

ksmbd: validate command request size

In commit 2b9b8f3b68ed ("ksmbd: validate command payload size"), except
for SMB2_OPLOCK_BREAK_HE command, the request size of other commands
is not checked, it's not expected. Fix it by add check for request
size of other commands.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2023-4130" data-description="in the linux kernel, the following vulnerability has been resolved:

ksmbd: fix wrong next length validation of ea buffer in smb2_set_ea()

there are multiple smb2_ea_info buffers in file_full_ea_information request
from client. ksmbd find next smb2_ea_info using ->nextentryoffset of
current smb2_ea_info. ksmbd need to validate buffer length before
accessing the next ea. ksmbd should check buffer length using buf_len,
not next variable. next is the start offset of current ea that got from
previous ea.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2023-4130" target="_blank">CVE-2023-4130</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-08-16 09:15:27 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">N/A</span></p>
                    <p><span class="feed-label">CVSS Score:</span> N/A</p>
                    <p>In the Linux kernel, the following vulnerability has been resolved:

ksmbd: fix wrong next length validation of ea buffer in smb2_set_ea()

There are multiple smb2_ea_info buffers in FILE_FULL_EA_INFORMATION request
from client. ksmbd find next smb2_ea_info using ->NextEntryOffset of
current smb2_ea_info. ksmbd need to validate buffer length Before
accessing the next ea. ksmbd should check buffer length using buf_len,
not next variable. next is the start offset of current ea that got from
previous ea.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2023-3867" data-description="in the linux kernel, the following vulnerability has been resolved:

ksmbd: fix out of bounds read in smb2_sess_setup

ksmbd does not consider the case of that smb2 session setup is
in compound request. if this is the second payload of the compound,
oob read issue occurs while processing the first payload in
the smb2_sess_setup().">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2023-3867" target="_blank">CVE-2023-3867</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-08-16 09:15:27 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">N/A</span></p>
                    <p><span class="feed-label">CVSS Score:</span> N/A</p>
                    <p>In the Linux kernel, the following vulnerability has been resolved:

ksmbd: fix out of bounds read in smb2_sess_setup

ksmbd does not consider the case of that smb2 session setup is
in compound request. If this is the second payload of the compound,
OOB read issue occurs while processing the first payload in
the smb2_sess_setup().</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2023-3866" data-description="in the linux kernel, the following vulnerability has been resolved:

ksmbd: validate session id and tree id in the compound request

this patch validate session id and tree id in compound request.
if first operation in the compound is smb2 echo request, ksmbd bypass
session and tree validation. so work->sess and work->tcon could be null.
if secound request in the compound access work->sess or tcon, it cause
null pointer dereferecing error.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2023-3866" target="_blank">CVE-2023-3866</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-08-16 09:15:27 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">N/A</span></p>
                    <p><span class="feed-label">CVSS Score:</span> N/A</p>
                    <p>In the Linux kernel, the following vulnerability has been resolved:

ksmbd: validate session id and tree id in the compound request

This patch validate session id and tree id in compound request.
If first operation in the compound is SMB2 ECHO request, ksmbd bypass
session and tree validation. So work->sess and work->tcon could be NULL.
If secound request in the compound access work->sess or tcon, It cause
NULL pointer dereferecing error.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2023-3865" data-description="in the linux kernel, the following vulnerability has been resolved:

ksmbd: fix out-of-bound read in smb2_write

ksmbd_smb2_check_message doesn't validate hdr->nextcommand. if
->nextcommand is bigger than offset + length of smb2 write, it will
allow oversized smb2 write length. it will cause oob read in smb2_write.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2023-3865" target="_blank">CVE-2023-3865</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-08-16 09:15:27 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">N/A</span></p>
                    <p><span class="feed-label">CVSS Score:</span> N/A</p>
                    <p>In the Linux kernel, the following vulnerability has been resolved:

ksmbd: fix out-of-bound read in smb2_write

ksmbd_smb2_check_message doesn't validate hdr->NextCommand. If
->NextCommand is bigger than Offset + Length of smb2 write, It will
allow oversized smb2 write length. It will cause OOB read in smb2_write.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2023-32249" data-description="in the linux kernel, the following vulnerability has been resolved:

ksmbd: not allow guest user on multichannel

this patch return status_not_supported if binding session is guest.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2023-32249" target="_blank">CVE-2023-32249</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-08-16 09:15:27 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">N/A</span></p>
                    <p><span class="feed-label">CVSS Score:</span> N/A</p>
                    <p>In the Linux kernel, the following vulnerability has been resolved:

ksmbd: not allow guest user on multichannel

This patch return STATUS_NOT_SUPPORTED if binding session is guest.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2023-32246" data-description="in the linux kernel, the following vulnerability has been resolved:

ksmbd: call rcu_barrier() in ksmbd_server_exit()

racy issue is triggered the bug by racing between closing a connection
and rmmod. in ksmbd, rcu_barrier() is not called at module unload time,
so nothing prevents ksmbd from getting unloaded while it still has rcu
callbacks pending. it leads to trigger unintended execution of kernel
code locally and use to defeat protections such as kernel lockdown">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2023-32246" target="_blank">CVE-2023-32246</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-08-16 09:15:26 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">N/A</span></p>
                    <p><span class="feed-label">CVSS Score:</span> N/A</p>
                    <p>In the Linux kernel, the following vulnerability has been resolved:

ksmbd: call rcu_barrier() in ksmbd_server_exit()

racy issue is triggered the bug by racing between closing a connection
and rmmod. In ksmbd, rcu_barrier() is not called at module unload time,
so nothing prevents ksmbd from getting unloaded while it still has RCU
callbacks pending. It leads to trigger unintended execution of kernel
code locally and use to defeat protections such as Kernel Lockdown</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-8878" data-description="the the paid membership plugin, ecommerce, user registration form, login form, user profile & restrict content – profilepress plugin for wordpress is vulnerable to arbitrary shortcode execution in all versions up to, and including, 4.16.4. this is due to the software allowing users to execute an action that does not properly validate a value before running do_shortcode. this makes it possible for unauthenticated attackers to execute arbitrary shortcodes.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-8878" target="_blank">CVE-2025-8878</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-08-16 07:15:32 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">MEDIUM</span></p>
                    <p><span class="feed-label">CVSS Score:</span> 6.5</p>
                    <p>The The Paid Membership Plugin, Ecommerce, User Registration Form, Login Form, User Profile & Restrict Content – ProfilePress plugin for WordPress is vulnerable to arbitrary shortcode execution in all versions up to, and including, 4.16.4. This is due to the software allowing users to execute an action that does not properly validate a value before running do_shortcode. This makes it possible for unauthenticated attackers to execute arbitrary shortcodes.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-8143" data-description="the soledad theme for wordpress is vulnerable to stored cross-site scripting via the ‘pcsml_smartlists_h’ parameter in all versions up to, and including, 8.6.7 due to insufficient input sanitization and output escaping. this makes it possible for authenticated attackers, with contributor-level access and above, to inject arbitrary web scripts in pages that will execute whenever a user accesses an injected page.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-8143" target="_blank">CVE-2025-8143</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-08-16 07:15:31 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">MEDIUM</span></p>
                    <p><span class="feed-label">CVSS Score:</span> 6.4</p>
                    <p>The Soledad theme for WordPress is vulnerable to Stored Cross-Site Scripting via the ‘pcsml_smartlists_h’ parameter in all versions up to, and including, 8.6.7 due to insufficient input sanitization and output escaping. This makes it possible for authenticated attackers, with Contributor-level access and above, to inject arbitrary web scripts in pages that will execute whenever a user accesses an injected page.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-8142" data-description="the soledad theme for wordpress is vulnerable to local file inclusion in all versions up to, and including, 8.6.7 via the 'header_layout' parameter. this makes it possible for authenticated attackers, with contributor-level access and above, to include and execute arbitrary .php files on the server, allowing the execution of any php code in those files. this can be used to bypass access controls, obtain sensitive data, or achieve code execution in cases where .php file types can be uploaded and included.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-8142" target="_blank">CVE-2025-8142</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-08-16 07:15:31 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-online">HIGH</span></p>
                    <p><span class="feed-label">CVSS Score:</span> 8.8</p>
                    <p>The Soledad theme for WordPress is vulnerable to Local File Inclusion in all versions up to, and including, 8.6.7 via the 'header_layout' parameter. This makes it possible for authenticated attackers, with Contributor-level access and above, to include and execute arbitrary .php files on the server, allowing the execution of any PHP code in those files. This can be used to bypass access controls, obtain sensitive data, or achieve code execution in cases where .php file types can be uploaded and included.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-8105" data-description="the the soledad theme for wordpress is vulnerable to arbitrary shortcode execution in all versions up to, and including, 8.6.7. this is due to the software allowing users to execute an action that does not properly validate a value before running do_shortcode. this makes it possible for unauthenticated attackers to execute arbitrary shortcodes.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-8105" target="_blank">CVE-2025-8105</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-08-16 07:15:31 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-online">HIGH</span></p>
                    <p><span class="feed-label">CVSS Score:</span> 7.3</p>
                    <p>The The Soledad theme for WordPress is vulnerable to arbitrary shortcode execution in all versions up to, and including, 8.6.7. This is due to the software allowing users to execute an action that does not properly validate a value before running do_shortcode. This makes it possible for unauthenticated attackers to execute arbitrary shortcodes.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-38552" data-description="in the linux kernel, the following vulnerability has been resolved:

mptcp: plug races between subflow fail and subflow creation

we have races similar to the one addressed by the previous patch between
subflow failing and additional subflow creation. they are just harder to
trigger.

the solution is similar. use a separate flag to track the condition
'socket state prevent any additional subflow creation' protected by the
fallback lock.

the socket fallback makes such flag true, and also receiving or sending
an mp_fail option.

the field 'allow_infinite_fallback' is now always touched under the
relevant lock, we can drop the once annotation on write.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-38552" target="_blank">CVE-2025-38552</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-08-16 07:15:31 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">N/A</span></p>
                    <p><span class="feed-label">CVSS Score:</span> N/A</p>
                    <p>In the Linux kernel, the following vulnerability has been resolved:

mptcp: plug races between subflow fail and subflow creation

We have races similar to the one addressed by the previous patch between
subflow failing and additional subflow creation. They are just harder to
trigger.

The solution is similar. Use a separate flag to track the condition
'socket state prevent any additional subflow creation' protected by the
fallback lock.

The socket fallback makes such flag true, and also receiving or sending
an MP_FAIL option.

The field 'allow_infinite_fallback' is now always touched under the
relevant lock, we can drop the ONCE annotation on write.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-38551" data-description="in the linux kernel, the following vulnerability has been resolved:

virtio-net: fix recursived rtnl_lock() during probe()

the deadlock appears in a stack trace like:

  virtnet_probe()
    rtnl_lock()
    virtio_config_changed_work()
      netdev_notify_peers()
        rtnl_lock()

it happens if the vmm sends a virtio_net_s_announce request while the
virtio-net driver is still probing.

the config_work in probe() will get scheduled until virtnet_open() enables
the config change notification via virtio_config_driver_enable().">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-38551" target="_blank">CVE-2025-38551</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-08-16 07:15:31 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">N/A</span></p>
                    <p><span class="feed-label">CVSS Score:</span> N/A</p>
                    <p>In the Linux kernel, the following vulnerability has been resolved:

virtio-net: fix recursived rtnl_lock() during probe()

The deadlock appears in a stack trace like:

  virtnet_probe()
    rtnl_lock()
    virtio_config_changed_work()
      netdev_notify_peers()
        rtnl_lock()

It happens if the VMM sends a VIRTIO_NET_S_ANNOUNCE request while the
virtio-net driver is still probing.

The config_work in probe() will get scheduled until virtnet_open() enables
the config change notification via virtio_config_driver_enable().</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-38550" data-description="in the linux kernel, the following vulnerability has been resolved:

ipv6: mcast: delay put pmc->idev in mld_del_delrec()

pmc->idev is still used in ip6_mc_clear_src(), so as mld_clear_delrec()
does, the reference should be put after ip6_mc_clear_src() return.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-38550" target="_blank">CVE-2025-38550</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-08-16 07:15:31 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">N/A</span></p>
                    <p><span class="feed-label">CVSS Score:</span> N/A</p>
                    <p>In the Linux kernel, the following vulnerability has been resolved:

ipv6: mcast: Delay put pmc->idev in mld_del_delrec()

pmc->idev is still used in ip6_mc_clear_src(), so as mld_clear_delrec()
does, the reference should be put after ip6_mc_clear_src() return.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-38549" data-description="in the linux kernel, the following vulnerability has been resolved:

efivarfs: fix memory leak of efivarfs_fs_info in fs_context error paths

when processing mount options, efivarfs allocates efivarfs_fs_info (sfi)
early in fs_context initialization. however, sfi is associated with the
superblock and typically freed when the superblock is destroyed. if the
fs_context is released (final put) before fill_super is called—such as
on error paths or during reconfiguration—the sfi structure would leak,
as ownership never transfers to the superblock.

implement the .free callback in efivarfs_context_ops to ensure any
allocated sfi is properly freed if the fs_context is torn down before
fill_super, preventing this memory leak.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-38549" target="_blank">CVE-2025-38549</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-08-16 07:15:31 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">N/A</span></p>
                    <p><span class="feed-label">CVSS Score:</span> N/A</p>
                    <p>In the Linux kernel, the following vulnerability has been resolved:

efivarfs: Fix memory leak of efivarfs_fs_info in fs_context error paths

When processing mount options, efivarfs allocates efivarfs_fs_info (sfi)
early in fs_context initialization. However, sfi is associated with the
superblock and typically freed when the superblock is destroyed. If the
fs_context is released (final put) before fill_super is called—such as
on error paths or during reconfiguration—the sfi structure would leak,
as ownership never transfers to the superblock.

Implement the .free callback in efivarfs_context_ops to ensure any
allocated sfi is properly freed if the fs_context is torn down before
fill_super, preventing this memory leak.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-38548" data-description="in the linux kernel, the following vulnerability has been resolved:

hwmon: (corsair-cpro) validate the size of the received input buffer

add buffer_recv_size to store the size of the received bytes.
validate buffer_recv_size in send_usb_cmd().">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-38548" target="_blank">CVE-2025-38548</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-08-16 07:15:30 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">N/A</span></p>
                    <p><span class="feed-label">CVSS Score:</span> N/A</p>
                    <p>In the Linux kernel, the following vulnerability has been resolved:

hwmon: (corsair-cpro) Validate the size of the received input buffer

Add buffer_recv_size to store the size of the received bytes.
Validate buffer_recv_size in send_usb_cmd().</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-38547" data-description="in the linux kernel, the following vulnerability has been resolved:

iio: adc: axp20x_adc: add missing sentinel to axp717 adc channel maps

the axp717 adc channel maps is missing a sentinel entry at the end. this
causes a kasan warning.

add the missing sentinel entry.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-38547" target="_blank">CVE-2025-38547</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-08-16 07:15:30 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">N/A</span></p>
                    <p><span class="feed-label">CVSS Score:</span> N/A</p>
                    <p>In the Linux kernel, the following vulnerability has been resolved:

iio: adc: axp20x_adc: Add missing sentinel to AXP717 ADC channel maps

The AXP717 ADC channel maps is missing a sentinel entry at the end. This
causes a KASAN warning.

Add the missing sentinel entry.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-38546" data-description="in the linux kernel, the following vulnerability has been resolved:

atm: clip: fix memory leak of struct clip_vcc.

ioctl(atmarp_mkip) allocates struct clip_vcc and set it to
vcc->user_back.

the code assumes that vcc_destroy_socket() passes null skb
to vcc->push() when the socket is close()d, and then clip_push()
frees clip_vcc.

however, ioctl(atmarpd_ctrl) sets null to vcc->push() in
atm_init_atmarp(), resulting in memory leak.

let's serialise two ioctl() by lock_sock() and check vcc->push()
in atm_init_atmarp() to prevent memleak.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-38546" target="_blank">CVE-2025-38546</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-08-16 07:15:30 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">N/A</span></p>
                    <p><span class="feed-label">CVSS Score:</span> N/A</p>
                    <p>In the Linux kernel, the following vulnerability has been resolved:

atm: clip: Fix memory leak of struct clip_vcc.

ioctl(ATMARP_MKIP) allocates struct clip_vcc and set it to
vcc->user_back.

The code assumes that vcc_destroy_socket() passes NULL skb
to vcc->push() when the socket is close()d, and then clip_push()
frees clip_vcc.

However, ioctl(ATMARPD_CTRL) sets NULL to vcc->push() in
atm_init_atmarp(), resulting in memory leak.

Let's serialise two ioctl() by lock_sock() and check vcc->push()
in atm_init_atmarp() to prevent memleak.</p>
                </div>
        
            </div>
        </div>

        <footer class="footer">
            <p>© 2025 dotne1 - Cybersecurity Portfolio</p>
        </footer>

        <script>
            function searchCVEs() {
                const input = document.getElementById('searchInput').value.toLowerCase();
                const cveEntries = document.getElementsByClassName('cve-entry');
                for (let i = 0; i < cveEntries.length; i++) {
                    const cveId = cveEntries[i].getAttribute('data-cve-id').toLowerCase();
                    const description = cveEntries[i].getAttribute('data-description');
                    if (cveId.includes(input) || description.includes(input)) {
                        cveEntries[i].style.display = '';
                    } else {
                        cveEntries[i].style.display = 'none';
                    }
                }
            }
        </script>
    </body>
    </html>
    