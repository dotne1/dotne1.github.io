
    <!DOCTYPE html>
    <html lang="en">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <meta name="description" content="Security alerts and cybersecurity news feeds">
        <meta name="keywords" content="cybersecurity news, security alerts, vulnerability feeds, threat intelligence">
        <meta name="author" content="dotne1">
        <meta property="og:title" content="Security Feeds - dotne1's Cybersecurity Portfolio">
        <meta property="og:description" content="Stay updated with the latest cybersecurity news and alerts">
        <meta property="og:type" content="website">
        <title>Security Feeds - dotne1's Cybersecurity Portfolio</title>
        <link rel="stylesheet" href="styles.css">
        <link rel="icon" type="image/x-icon" href="/favicon.ico">
    </head>
    <body>
        <nav class="navbar">
            <div class="nav-links">
                <a href="index.html" class="nav-link">Home</a>
                <a href="about-me.html" class="nav-link">About Me</a>
                <a href="projects.html" class="nav-link">Projects</a>
                <a href="resume.html" class="nav-link">Resume</a>
                <a href="feeds.html" class="nav-link">Feeds</a>
            </div>
        </nav>

        <div class="container" role="main">
            <h1 class="main-header">Security Feeds</h1>
            <div class="search-bar">
                <input type="text" id="searchInput" placeholder="Search CVEs..." onkeyup="searchCVEs()">
            </div>
            <div class="feed-preview" id="cveFeed">
                <div class="feed-header">Latest Vulnerabilities</div>
    
                <div class="cve-entry" data-cve-id="CVE-2025-8878" data-description="the the paid membership plugin, ecommerce, user registration form, login form, user profile & restrict content – profilepress plugin for wordpress is vulnerable to arbitrary shortcode execution in all versions up to, and including, 4.16.4. this is due to the software allowing users to execute an action that does not properly validate a value before running do_shortcode. this makes it possible for unauthenticated attackers to execute arbitrary shortcodes.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-8878" target="_blank">CVE-2025-8878</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-08-16 07:15:32 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">MEDIUM</span></p>
                    <p><span class="feed-label">CVSS Score:</span> 6.5</p>
                    <p>The The Paid Membership Plugin, Ecommerce, User Registration Form, Login Form, User Profile & Restrict Content – ProfilePress plugin for WordPress is vulnerable to arbitrary shortcode execution in all versions up to, and including, 4.16.4. This is due to the software allowing users to execute an action that does not properly validate a value before running do_shortcode. This makes it possible for unauthenticated attackers to execute arbitrary shortcodes.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-8143" data-description="the soledad theme for wordpress is vulnerable to stored cross-site scripting via the ‘pcsml_smartlists_h’ parameter in all versions up to, and including, 8.6.7 due to insufficient input sanitization and output escaping. this makes it possible for authenticated attackers, with contributor-level access and above, to inject arbitrary web scripts in pages that will execute whenever a user accesses an injected page.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-8143" target="_blank">CVE-2025-8143</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-08-16 07:15:31 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">MEDIUM</span></p>
                    <p><span class="feed-label">CVSS Score:</span> 6.4</p>
                    <p>The Soledad theme for WordPress is vulnerable to Stored Cross-Site Scripting via the ‘pcsml_smartlists_h’ parameter in all versions up to, and including, 8.6.7 due to insufficient input sanitization and output escaping. This makes it possible for authenticated attackers, with Contributor-level access and above, to inject arbitrary web scripts in pages that will execute whenever a user accesses an injected page.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-8142" data-description="the soledad theme for wordpress is vulnerable to local file inclusion in all versions up to, and including, 8.6.7 via the 'header_layout' parameter. this makes it possible for authenticated attackers, with contributor-level access and above, to include and execute arbitrary .php files on the server, allowing the execution of any php code in those files. this can be used to bypass access controls, obtain sensitive data, or achieve code execution in cases where .php file types can be uploaded and included.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-8142" target="_blank">CVE-2025-8142</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-08-16 07:15:31 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-online">HIGH</span></p>
                    <p><span class="feed-label">CVSS Score:</span> 8.8</p>
                    <p>The Soledad theme for WordPress is vulnerable to Local File Inclusion in all versions up to, and including, 8.6.7 via the 'header_layout' parameter. This makes it possible for authenticated attackers, with Contributor-level access and above, to include and execute arbitrary .php files on the server, allowing the execution of any PHP code in those files. This can be used to bypass access controls, obtain sensitive data, or achieve code execution in cases where .php file types can be uploaded and included.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-8105" data-description="the the soledad theme for wordpress is vulnerable to arbitrary shortcode execution in all versions up to, and including, 8.6.7. this is due to the software allowing users to execute an action that does not properly validate a value before running do_shortcode. this makes it possible for unauthenticated attackers to execute arbitrary shortcodes.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-8105" target="_blank">CVE-2025-8105</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-08-16 07:15:31 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-online">HIGH</span></p>
                    <p><span class="feed-label">CVSS Score:</span> 7.3</p>
                    <p>The The Soledad theme for WordPress is vulnerable to arbitrary shortcode execution in all versions up to, and including, 8.6.7. This is due to the software allowing users to execute an action that does not properly validate a value before running do_shortcode. This makes it possible for unauthenticated attackers to execute arbitrary shortcodes.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-38552" data-description="in the linux kernel, the following vulnerability has been resolved:

mptcp: plug races between subflow fail and subflow creation

we have races similar to the one addressed by the previous patch between
subflow failing and additional subflow creation. they are just harder to
trigger.

the solution is similar. use a separate flag to track the condition
'socket state prevent any additional subflow creation' protected by the
fallback lock.

the socket fallback makes such flag true, and also receiving or sending
an mp_fail option.

the field 'allow_infinite_fallback' is now always touched under the
relevant lock, we can drop the once annotation on write.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-38552" target="_blank">CVE-2025-38552</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-08-16 07:15:31 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">N/A</span></p>
                    <p><span class="feed-label">CVSS Score:</span> N/A</p>
                    <p>In the Linux kernel, the following vulnerability has been resolved:

mptcp: plug races between subflow fail and subflow creation

We have races similar to the one addressed by the previous patch between
subflow failing and additional subflow creation. They are just harder to
trigger.

The solution is similar. Use a separate flag to track the condition
'socket state prevent any additional subflow creation' protected by the
fallback lock.

The socket fallback makes such flag true, and also receiving or sending
an MP_FAIL option.

The field 'allow_infinite_fallback' is now always touched under the
relevant lock, we can drop the ONCE annotation on write.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-38551" data-description="in the linux kernel, the following vulnerability has been resolved:

virtio-net: fix recursived rtnl_lock() during probe()

the deadlock appears in a stack trace like:

  virtnet_probe()
    rtnl_lock()
    virtio_config_changed_work()
      netdev_notify_peers()
        rtnl_lock()

it happens if the vmm sends a virtio_net_s_announce request while the
virtio-net driver is still probing.

the config_work in probe() will get scheduled until virtnet_open() enables
the config change notification via virtio_config_driver_enable().">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-38551" target="_blank">CVE-2025-38551</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-08-16 07:15:31 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">N/A</span></p>
                    <p><span class="feed-label">CVSS Score:</span> N/A</p>
                    <p>In the Linux kernel, the following vulnerability has been resolved:

virtio-net: fix recursived rtnl_lock() during probe()

The deadlock appears in a stack trace like:

  virtnet_probe()
    rtnl_lock()
    virtio_config_changed_work()
      netdev_notify_peers()
        rtnl_lock()

It happens if the VMM sends a VIRTIO_NET_S_ANNOUNCE request while the
virtio-net driver is still probing.

The config_work in probe() will get scheduled until virtnet_open() enables
the config change notification via virtio_config_driver_enable().</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-38550" data-description="in the linux kernel, the following vulnerability has been resolved:

ipv6: mcast: delay put pmc->idev in mld_del_delrec()

pmc->idev is still used in ip6_mc_clear_src(), so as mld_clear_delrec()
does, the reference should be put after ip6_mc_clear_src() return.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-38550" target="_blank">CVE-2025-38550</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-08-16 07:15:31 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">N/A</span></p>
                    <p><span class="feed-label">CVSS Score:</span> N/A</p>
                    <p>In the Linux kernel, the following vulnerability has been resolved:

ipv6: mcast: Delay put pmc->idev in mld_del_delrec()

pmc->idev is still used in ip6_mc_clear_src(), so as mld_clear_delrec()
does, the reference should be put after ip6_mc_clear_src() return.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-38549" data-description="in the linux kernel, the following vulnerability has been resolved:

efivarfs: fix memory leak of efivarfs_fs_info in fs_context error paths

when processing mount options, efivarfs allocates efivarfs_fs_info (sfi)
early in fs_context initialization. however, sfi is associated with the
superblock and typically freed when the superblock is destroyed. if the
fs_context is released (final put) before fill_super is called—such as
on error paths or during reconfiguration—the sfi structure would leak,
as ownership never transfers to the superblock.

implement the .free callback in efivarfs_context_ops to ensure any
allocated sfi is properly freed if the fs_context is torn down before
fill_super, preventing this memory leak.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-38549" target="_blank">CVE-2025-38549</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-08-16 07:15:31 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">N/A</span></p>
                    <p><span class="feed-label">CVSS Score:</span> N/A</p>
                    <p>In the Linux kernel, the following vulnerability has been resolved:

efivarfs: Fix memory leak of efivarfs_fs_info in fs_context error paths

When processing mount options, efivarfs allocates efivarfs_fs_info (sfi)
early in fs_context initialization. However, sfi is associated with the
superblock and typically freed when the superblock is destroyed. If the
fs_context is released (final put) before fill_super is called—such as
on error paths or during reconfiguration—the sfi structure would leak,
as ownership never transfers to the superblock.

Implement the .free callback in efivarfs_context_ops to ensure any
allocated sfi is properly freed if the fs_context is torn down before
fill_super, preventing this memory leak.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-38548" data-description="in the linux kernel, the following vulnerability has been resolved:

hwmon: (corsair-cpro) validate the size of the received input buffer

add buffer_recv_size to store the size of the received bytes.
validate buffer_recv_size in send_usb_cmd().">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-38548" target="_blank">CVE-2025-38548</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-08-16 07:15:30 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">N/A</span></p>
                    <p><span class="feed-label">CVSS Score:</span> N/A</p>
                    <p>In the Linux kernel, the following vulnerability has been resolved:

hwmon: (corsair-cpro) Validate the size of the received input buffer

Add buffer_recv_size to store the size of the received bytes.
Validate buffer_recv_size in send_usb_cmd().</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-38547" data-description="in the linux kernel, the following vulnerability has been resolved:

iio: adc: axp20x_adc: add missing sentinel to axp717 adc channel maps

the axp717 adc channel maps is missing a sentinel entry at the end. this
causes a kasan warning.

add the missing sentinel entry.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-38547" target="_blank">CVE-2025-38547</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-08-16 07:15:30 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">N/A</span></p>
                    <p><span class="feed-label">CVSS Score:</span> N/A</p>
                    <p>In the Linux kernel, the following vulnerability has been resolved:

iio: adc: axp20x_adc: Add missing sentinel to AXP717 ADC channel maps

The AXP717 ADC channel maps is missing a sentinel entry at the end. This
causes a KASAN warning.

Add the missing sentinel entry.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-38546" data-description="in the linux kernel, the following vulnerability has been resolved:

atm: clip: fix memory leak of struct clip_vcc.

ioctl(atmarp_mkip) allocates struct clip_vcc and set it to
vcc->user_back.

the code assumes that vcc_destroy_socket() passes null skb
to vcc->push() when the socket is close()d, and then clip_push()
frees clip_vcc.

however, ioctl(atmarpd_ctrl) sets null to vcc->push() in
atm_init_atmarp(), resulting in memory leak.

let's serialise two ioctl() by lock_sock() and check vcc->push()
in atm_init_atmarp() to prevent memleak.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-38546" target="_blank">CVE-2025-38546</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-08-16 07:15:30 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">N/A</span></p>
                    <p><span class="feed-label">CVSS Score:</span> N/A</p>
                    <p>In the Linux kernel, the following vulnerability has been resolved:

atm: clip: Fix memory leak of struct clip_vcc.

ioctl(ATMARP_MKIP) allocates struct clip_vcc and set it to
vcc->user_back.

The code assumes that vcc_destroy_socket() passes NULL skb
to vcc->push() when the socket is close()d, and then clip_push()
frees clip_vcc.

However, ioctl(ATMARPD_CTRL) sets NULL to vcc->push() in
atm_init_atmarp(), resulting in memory leak.

Let's serialise two ioctl() by lock_sock() and check vcc->push()
in atm_init_atmarp() to prevent memleak.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-38545" data-description="in the linux kernel, the following vulnerability has been resolved:

net: ethernet: ti: am65-cpsw-nuss: fix skb size by accounting for skb_shared_info

while transitioning from netdev_alloc_ip_align() to build_skb(), memory
for the "skb_shared_info" member of an "skb" was not allocated. fix this
by allocating "page_size" as the skb length, accounting for the packet
length, headroom and tailroom, thereby including the required memory space
for skb_shared_info.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-38545" target="_blank">CVE-2025-38545</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-08-16 07:15:30 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">N/A</span></p>
                    <p><span class="feed-label">CVSS Score:</span> N/A</p>
                    <p>In the Linux kernel, the following vulnerability has been resolved:

net: ethernet: ti: am65-cpsw-nuss: Fix skb size by accounting for skb_shared_info

While transitioning from netdev_alloc_ip_align() to build_skb(), memory
for the "skb_shared_info" member of an "skb" was not allocated. Fix this
by allocating "PAGE_SIZE" as the skb length, accounting for the packet
length, headroom and tailroom, thereby including the required memory space
for skb_shared_info.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-38544" data-description="in the linux kernel, the following vulnerability has been resolved:

rxrpc: fix bug due to prealloc collision

when userspace is using af_rxrpc to provide a server, it has to preallocate
incoming calls and assign to them call ids that will be used to thread
related recvmsg() and sendmsg() together.  the preallocated call ids will
automatically be attached to calls as they come in until the pool is empty.

to the kernel, the call ids are just arbitrary numbers, but userspace can
use the call id to hold a pointer to prepared structs.  in any case, the
user isn't permitted to create two calls with the same call id (call ids
become available again when the call ends) and ebadslt should result from
sendmsg() if an attempt is made to preallocate a call with an in-use call
id.

however, the cleanup in the error handling will trigger both assertions in
rxrpc_cleanup_call() because the call isn't marked complete and isn't
marked as having been released.

fix this by setting the call state in rxrpc_service_prealloc_one() and then
marking it as being released before calling the cleanup function.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-38544" target="_blank">CVE-2025-38544</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-08-16 07:15:30 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">N/A</span></p>
                    <p><span class="feed-label">CVSS Score:</span> N/A</p>
                    <p>In the Linux kernel, the following vulnerability has been resolved:

rxrpc: Fix bug due to prealloc collision

When userspace is using AF_RXRPC to provide a server, it has to preallocate
incoming calls and assign to them call IDs that will be used to thread
related recvmsg() and sendmsg() together.  The preallocated call IDs will
automatically be attached to calls as they come in until the pool is empty.

To the kernel, the call IDs are just arbitrary numbers, but userspace can
use the call ID to hold a pointer to prepared structs.  In any case, the
user isn't permitted to create two calls with the same call ID (call IDs
become available again when the call ends) and EBADSLT should result from
sendmsg() if an attempt is made to preallocate a call with an in-use call
ID.

However, the cleanup in the error handling will trigger both assertions in
rxrpc_cleanup_call() because the call isn't marked complete and isn't
marked as having been released.

Fix this by setting the call state in rxrpc_service_prealloc_one() and then
marking it as being released before calling the cleanup function.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-38543" data-description="in the linux kernel, the following vulnerability has been resolved:

drm/tegra: nvdec: fix dma_alloc_coherent error check

check for null return value with dma_alloc_coherent, in line with
robin's fix for vic.c in 'drm/tegra: vic: fix dma api misuse'.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-38543" target="_blank">CVE-2025-38543</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-08-16 07:15:30 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">N/A</span></p>
                    <p><span class="feed-label">CVSS Score:</span> N/A</p>
                    <p>In the Linux kernel, the following vulnerability has been resolved:

drm/tegra: nvdec: Fix dma_alloc_coherent error check

Check for NULL return value with dma_alloc_coherent, in line with
Robin's fix for vic.c in 'drm/tegra: vic: Fix DMA API misuse'.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-38542" data-description="in the linux kernel, the following vulnerability has been resolved:

net: appletalk: fix device refcount leak in atrtr_create()

when updating an existing route entry in atrtr_create(), the old device
reference was not being released before assigning the new device,
leading to a device refcount leak. fix this by calling dev_put() to
release the old device reference before holding the new one.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-38542" target="_blank">CVE-2025-38542</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-08-16 07:15:30 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">N/A</span></p>
                    <p><span class="feed-label">CVSS Score:</span> N/A</p>
                    <p>In the Linux kernel, the following vulnerability has been resolved:

net: appletalk: Fix device refcount leak in atrtr_create()

When updating an existing route entry in atrtr_create(), the old device
reference was not being released before assigning the new device,
leading to a device refcount leak. Fix this by calling dev_put() to
release the old device reference before holding the new one.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-38541" data-description="in the linux kernel, the following vulnerability has been resolved:

wifi: mt76: mt7925: fix null-ptr-deref in mt7925_thermal_init()

devm_kasprintf() returns null on error. currently, mt7925_thermal_init()
does not check for this case, which results in a null pointer
dereference.

add null check after devm_kasprintf() to prevent this issue.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-38541" target="_blank">CVE-2025-38541</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-08-16 07:15:29 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">N/A</span></p>
                    <p><span class="feed-label">CVSS Score:</span> N/A</p>
                    <p>In the Linux kernel, the following vulnerability has been resolved:

wifi: mt76: mt7925: Fix null-ptr-deref in mt7925_thermal_init()

devm_kasprintf() returns NULL on error. Currently, mt7925_thermal_init()
does not check for this case, which results in a NULL pointer
dereference.

Add NULL check after devm_kasprintf() to prevent this issue.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-38540" data-description="in the linux kernel, the following vulnerability has been resolved:

hid: quirks: add quirk for 2 chicony electronics hp 5mp cameras

the chicony electronics hp 5mp cameras (usb id 04f2:b824 & 04f2:b82c)
report a hid sensor interface that is not actually implemented.
attempting to access this non-functional sensor via iio_info causes
system hangs as runtime pm tries to wake up an unresponsive sensor.

add these 2 devices to the hid ignore list since the sensor interface is
non-functional by design and should not be exposed to userspace.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-38540" target="_blank">CVE-2025-38540</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-08-16 07:15:29 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">N/A</span></p>
                    <p><span class="feed-label">CVSS Score:</span> N/A</p>
                    <p>In the Linux kernel, the following vulnerability has been resolved:

HID: quirks: Add quirk for 2 Chicony Electronics HP 5MP Cameras

The Chicony Electronics HP 5MP Cameras (USB ID 04F2:B824 & 04F2:B82C)
report a HID sensor interface that is not actually implemented.
Attempting to access this non-functional sensor via iio_info causes
system hangs as runtime PM tries to wake up an unresponsive sensor.

Add these 2 devices to the HID ignore list since the sensor interface is
non-functional by design and should not be exposed to userspace.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-38539" data-description="in the linux kernel, the following vulnerability has been resolved:

tracing: add down_write(trace_event_sem) when adding trace event

when a module is loaded, it adds trace events defined by the module. it
may also need to modify the modules trace printk formats to replace enum
names with their values.

if two modules are loaded at the same time, the adding of the event to the
ftrace_events list can corrupt the walking of the list in the code that is
modifying the printk format strings and crash the kernel.

the addition of the event should take the trace_event_sem for write while
it adds the new event.

also add a lockdep_assert_held() on that semaphore in
__trace_add_event_dirs() as it iterates the list.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-38539" target="_blank">CVE-2025-38539</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-08-16 07:15:29 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">N/A</span></p>
                    <p><span class="feed-label">CVSS Score:</span> N/A</p>
                    <p>In the Linux kernel, the following vulnerability has been resolved:

tracing: Add down_write(trace_event_sem) when adding trace event

When a module is loaded, it adds trace events defined by the module. It
may also need to modify the modules trace printk formats to replace enum
names with their values.

If two modules are loaded at the same time, the adding of the event to the
ftrace_events list can corrupt the walking of the list in the code that is
modifying the printk format strings and crash the kernel.

The addition of the event should take the trace_event_sem for write while
it adds the new event.

Also add a lockdep_assert_held() on that semaphore in
__trace_add_event_dirs() as it iterates the list.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-38538" data-description="in the linux kernel, the following vulnerability has been resolved:

dmaengine: nbpfaxi: fix memory corruption in probe()

the nbpf->chan[] array is allocated earlier in the nbpf_probe() function
and it has "num_channels" elements.  these three loops iterate one
element farther than they should and corrupt memory.

the changes to the second loop are more involved.  in this case, we're
copying data from the irqbuf[] array into the nbpf->chan[] array.  if
the data in irqbuf[i] is the error irq then we skip it, so the iterators
are not in sync.  i added a check to ensure that we don't go beyond the
end of the irqbuf[] array.  i'm pretty sure this can't happen, but it
seemed harmless to add a check.

on the other hand, after the loop has ended there is a check to ensure
that the "chan" iterator is where we expect it to be.  in the original
code we went one element beyond the end of the array so the iterator
wasn't in the correct place and it would always return -einval.  however,
now it will always be in the correct place.  i deleted the check since
we know the result.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-38538" target="_blank">CVE-2025-38538</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-08-16 07:15:29 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">N/A</span></p>
                    <p><span class="feed-label">CVSS Score:</span> N/A</p>
                    <p>In the Linux kernel, the following vulnerability has been resolved:

dmaengine: nbpfaxi: Fix memory corruption in probe()

The nbpf->chan[] array is allocated earlier in the nbpf_probe() function
and it has "num_channels" elements.  These three loops iterate one
element farther than they should and corrupt memory.

The changes to the second loop are more involved.  In this case, we're
copying data from the irqbuf[] array into the nbpf->chan[] array.  If
the data in irqbuf[i] is the error IRQ then we skip it, so the iterators
are not in sync.  I added a check to ensure that we don't go beyond the
end of the irqbuf[] array.  I'm pretty sure this can't happen, but it
seemed harmless to add a check.

On the other hand, after the loop has ended there is a check to ensure
that the "chan" iterator is where we expect it to be.  In the original
code we went one element beyond the end of the array so the iterator
wasn't in the correct place and it would always return -EINVAL.  However,
now it will always be in the correct place.  I deleted the check since
we know the result.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-38537" data-description="in the linux kernel, the following vulnerability has been resolved:

net: phy: don't register leds for genphy

if a phy has no driver, the genphy driver is probed/removed directly in
phy_attach/detach. if the phy's ofnode has an "leds" subnode, then the
leds will be (un)registered when probing/removing the genphy driver.
this could occur if the leds are for a non-generic driver that isn't
loaded for whatever reason. synchronously removing the phy device in
phy_detach leads to the following deadlock:

rtnl_lock()
ndo_close()
    ...
    phy_detach()
        phy_remove()
            phy_leds_unregister()
                led_classdev_unregister()
                    led_trigger_set()
                        netdev_trigger_deactivate()
                            unregister_netdevice_notifier()
                                rtnl_lock()

there is a corresponding deadlock on the open/register side of things
(and that one is reported by lockdep), but it requires a race while this
one is deterministic.

generic phys do not support leds anyway, so don't bother registering
them.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-38537" target="_blank">CVE-2025-38537</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-08-16 07:15:29 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">N/A</span></p>
                    <p><span class="feed-label">CVSS Score:</span> N/A</p>
                    <p>In the Linux kernel, the following vulnerability has been resolved:

net: phy: Don't register LEDs for genphy

If a PHY has no driver, the genphy driver is probed/removed directly in
phy_attach/detach. If the PHY's ofnode has an "leds" subnode, then the
LEDs will be (un)registered when probing/removing the genphy driver.
This could occur if the leds are for a non-generic driver that isn't
loaded for whatever reason. Synchronously removing the PHY device in
phy_detach leads to the following deadlock:

rtnl_lock()
ndo_close()
    ...
    phy_detach()
        phy_remove()
            phy_leds_unregister()
                led_classdev_unregister()
                    led_trigger_set()
                        netdev_trigger_deactivate()
                            unregister_netdevice_notifier()
                                rtnl_lock()

There is a corresponding deadlock on the open/register side of things
(and that one is reported by lockdep), but it requires a race while this
one is deterministic.

Generic PHYs do not support LEDs anyway, so don't bother registering
them.</p>
                </div>
        
            </div>
        </div>

        <footer class="footer">
            <p>© 2025 dotne1 - Cybersecurity Portfolio</p>
        </footer>

        <script>
            function searchCVEs() {
                const input = document.getElementById('searchInput').value.toLowerCase();
                const cveEntries = document.getElementsByClassName('cve-entry');
                for (let i = 0; i < cveEntries.length; i++) {
                    const cveId = cveEntries[i].getAttribute('data-cve-id').toLowerCase();
                    const description = cveEntries[i].getAttribute('data-description');
                    if (cveId.includes(input) || description.includes(input)) {
                        cveEntries[i].style.display = '';
                    } else {
                        cveEntries[i].style.display = 'none';
                    }
                }
            }
        </script>
    </body>
    </html>
    