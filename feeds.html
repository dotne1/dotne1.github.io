
    <!DOCTYPE html>
    <html lang="en">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <meta name="description" content="Security alerts and cybersecurity news feeds">
        <meta name="keywords" content="cybersecurity news, security alerts, vulnerability feeds, threat intelligence">
        <meta name="author" content="dotne1">
        <meta property="og:title" content="Security Feeds - dotne1's Cybersecurity Portfolio">
        <meta property="og:description" content="Stay updated with the latest cybersecurity news and alerts">
        <meta property="og:type" content="website">
        <title>Security Feeds - dotne1's Cybersecurity Portfolio</title>
        <link rel="stylesheet" href="styles.css">
        <link rel="icon" type="image/x-icon" href="/favicon.ico">
    </head>
    <body>
        <nav class="navbar">
            <div class="nav-links">
                <a href="index.html" class="nav-link">Home</a>
                <a href="about-me.html" class="nav-link">About Me</a>
                <a href="projects.html" class="nav-link">Projects</a>
                <a href="resume.html" class="nav-link">Resume</a>
                <a href="feeds.html" class="nav-link">Feeds</a>
            </div>
        </nav>

        <div class="container" role="main">
            <h1 class="main-header">Security Feeds</h1>
            <div class="search-bar">
                <input type="text" id="searchInput" placeholder="Search CVEs..." onkeyup="searchCVEs()">
            </div>
            <div class="feed-preview" id="cveFeed">
                <div class="feed-header">Latest Vulnerabilities</div>
    
                <div class="cve-entry" data-cve-id="CVE-2025-67111" data-description="an integer overflow in the rtps protocol implementation of opendds dds before v3.33.0 allows attackers to cause a denial of service (dos) via a crafted message.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-67111" target="_blank">CVE-2025-67111</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-12-23 10:16:23 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">N/A</span></p>
                    <p><span class="feed-label">CVSS Score:</span> N/A</p>
                    <p>An integer overflow in the RTPS protocol implementation of OpenDDS DDS before v3.33.0 allows attackers to cause a Denial of Service (DoS) via a crafted message.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-67109" data-description="improper verification of the time certificate in eclipse cyclone dds before v0.10.5 allows attackers to bypass certificate checks and execute commands with system privileges.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-67109" target="_blank">CVE-2025-67109</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-12-23 10:16:23 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-online">CRITICAL</span></p>
                    <p><span class="feed-label">CVSS Score:</span> 10.0</p>
                    <p>Improper verification of the time certificate in Eclipse Cyclone DDS before v0.10.5 allows attackers to bypass certificate checks and execute commands with System privileges.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-67108" data-description="eprosima fast-dds v3.3 was discovered to contain improper validation for ticket revocation, resulting in insecure communications and connections.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-67108" target="_blank">CVE-2025-67108</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-12-23 10:16:22 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-online">CRITICAL</span></p>
                    <p><span class="feed-label">CVSS Score:</span> 10.0</p>
                    <p>eProsima Fast-DDS v3.3 was discovered to contain improper validation for ticket revocation, resulting in insecure communications and connections.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-65865" data-description="an integer overflow in eprosima fast-dds v3.3 allows attackers to cause a denial of service (dos) via a crafted input.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-65865" target="_blank">CVE-2025-65865</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-12-23 10:16:22 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-online">HIGH</span></p>
                    <p><span class="feed-label">CVSS Score:</span> 7.5</p>
                    <p>An integer overflow in eProsima Fast-DDS v3.3 allows attackers to cause a Denial of Service (DoS) via a crafted input.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-50526" data-description="netgear ex8000 v1.0.0.126 was discovered to contain a command injection vulnerability via the switch_status function.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-50526" target="_blank">CVE-2025-50526</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-12-23 10:16:22 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">N/A</span></p>
                    <p><span class="feed-label">CVSS Score:</span> N/A</p>
                    <p>Netgear EX8000 V1.0.0.126 was discovered to contain a command injection vulnerability via the switch_status function.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-48864" data-description="rejected reason: this cve id was assigned but later discarded.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-48864" target="_blank">CVE-2025-48864</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-12-23 10:16:22 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">N/A</span></p>
                    <p><span class="feed-label">CVSS Score:</span> N/A</p>
                    <p>Rejected reason: This CVE id was assigned but later discarded.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-48863" data-description="rejected reason: this cve id was assigned but later discarded.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-48863" target="_blank">CVE-2025-48863</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-12-23 10:16:22 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">N/A</span></p>
                    <p><span class="feed-label">CVSS Score:</span> N/A</p>
                    <p>Rejected reason: This CVE id was assigned but later discarded.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-45493" data-description="netgear ex8000 v1.0.0.126 is vulnerable to command injection via the iface parameter in the action_bandwidth function.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-45493" target="_blank">CVE-2025-45493</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-12-23 10:16:22 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">N/A</span></p>
                    <p><span class="feed-label">CVSS Score:</span> N/A</p>
                    <p>Netgear EX8000 V1.0.0.126 is vulnerable to Command Injection via the iface parameter in the action_bandwidth function.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2024-10398" data-description="rejected reason: this cve id was assigned but later discarded.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2024-10398" target="_blank">CVE-2024-10398</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-12-23 10:16:21 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">N/A</span></p>
                    <p><span class="feed-label">CVSS Score:</span> N/A</p>
                    <p>Rejected reason: This CVE id was assigned but later discarded.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2024-9684" data-description="freyrscada/iec-60870-5-104 server v21.06.008 allows remote attackers to cause a denial of service by sending specific message sequences.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2024-9684" target="_blank">CVE-2024-9684</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-12-23 09:15:44 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-online">HIGH</span></p>
                    <p><span class="feed-label">CVSS Score:</span> 7.5</p>
                    <p>FreyrSCADA/IEC-60870-5-104 server v21.06.008 allows remote attackers to cause a denial of service by sending specific message sequences.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-68343" data-description="in the linux kernel, the following vulnerability has been resolved:

can: gs_usb: gs_usb_receive_bulk_callback(): check actual_length before accessing header

the driver expects to receive a struct gs_host_frame in
gs_usb_receive_bulk_callback().

use struct_group to describe the header of the struct gs_host_frame and
check that we have at least received the header before accessing any
members of it.

to resubmit the urb, do not dereference the pointer chain
"dev->parent->hf_size_rx" but use "parent->hf_size_rx" instead. since
"urb->context" contains "parent", it is always defined, while "dev" is not
defined if the urb it too short.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-68343" target="_blank">CVE-2025-68343</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-12-23 08:16:40 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">N/A</span></p>
                    <p><span class="feed-label">CVSS Score:</span> N/A</p>
                    <p>In the Linux kernel, the following vulnerability has been resolved:

can: gs_usb: gs_usb_receive_bulk_callback(): check actual_length before accessing header

The driver expects to receive a struct gs_host_frame in
gs_usb_receive_bulk_callback().

Use struct_group to describe the header of the struct gs_host_frame and
check that we have at least received the header before accessing any
members of it.

To resubmit the URB, do not dereference the pointer chain
"dev->parent->hf_size_rx" but use "parent->hf_size_rx" instead. Since
"urb->context" contains "parent", it is always defined, while "dev" is not
defined if the URB it too short.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-68342" data-description="in the linux kernel, the following vulnerability has been resolved:

can: gs_usb: gs_usb_receive_bulk_callback(): check actual_length before accessing data

the urb received in gs_usb_receive_bulk_callback() contains a struct
gs_host_frame. the length of the data after the header depends on the
gs_host_frame hf::flags and the active device features (e.g. time
stamping).

introduce a new function gs_usb_get_minimum_length() and check that we have
at least received the required amount of data before accessing it. only
copy the data to that skb that has actually been received.

[mkl: rename gs_usb_get_minimum_length() -> +gs_usb_get_minimum_rx_length()]">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-68342" target="_blank">CVE-2025-68342</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-12-23 08:16:40 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">N/A</span></p>
                    <p><span class="feed-label">CVSS Score:</span> N/A</p>
                    <p>In the Linux kernel, the following vulnerability has been resolved:

can: gs_usb: gs_usb_receive_bulk_callback(): check actual_length before accessing data

The URB received in gs_usb_receive_bulk_callback() contains a struct
gs_host_frame. The length of the data after the header depends on the
gs_host_frame hf::flags and the active device features (e.g. time
stamping).

Introduce a new function gs_usb_get_minimum_length() and check that we have
at least received the required amount of data before accessing it. Only
copy the data to that skb that has actually been received.

[mkl: rename gs_usb_get_minimum_length() -> +gs_usb_get_minimum_rx_length()]</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-68341" data-description="in the linux kernel, the following vulnerability has been resolved:

veth: reduce xdp no_direct return section to fix race

as explain in commit fa349e396e48 ("veth: fix race with af_xdp exposing
old or uninitialized descriptors") for veth there is a chance after
napi_complete_done() that another cpu can manage start another napi
instance running veth_pool(). for napi this is correctly handled as the
napi_schedule_prep() check will prevent multiple instances from getting
scheduled, but for the remaining code in veth_pool() this can run
concurrent with the newly started napi instance.

the problem/race is that xdp_clear_return_frame_no_direct() isn't
designed to be nested.

prior to commit 401cb7dae813 ("net: reference bpf_redirect_info via
task_struct on preempt_rt.") the temporary bpf net context
bpf_redirect_info was stored per cpu, where this wasn't an issue. since
this commit the bpf context is stored in 'current' task_struct. when
running veth in threaded-napi mode, then the kthread becomes the storage
area. now a race exists between two concurrent veth_pool() function calls
one exiting napi and one running new napi, both using the same bpf net
context.

race is when another cpu gets within the xdp_set_return_frame_no_direct()
section before exiting veth_pool() calls the clear-function
xdp_clear_return_frame_no_direct().">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-68341" target="_blank">CVE-2025-68341</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-12-23 08:16:40 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">N/A</span></p>
                    <p><span class="feed-label">CVSS Score:</span> N/A</p>
                    <p>In the Linux kernel, the following vulnerability has been resolved:

veth: reduce XDP no_direct return section to fix race

As explain in commit fa349e396e48 ("veth: Fix race with AF_XDP exposing
old or uninitialized descriptors") for veth there is a chance after
napi_complete_done() that another CPU can manage start another NAPI
instance running veth_pool(). For NAPI this is correctly handled as the
napi_schedule_prep() check will prevent multiple instances from getting
scheduled, but for the remaining code in veth_pool() this can run
concurrent with the newly started NAPI instance.

The problem/race is that xdp_clear_return_frame_no_direct() isn't
designed to be nested.

Prior to commit 401cb7dae813 ("net: Reference bpf_redirect_info via
task_struct on PREEMPT_RT.") the temporary BPF net context
bpf_redirect_info was stored per CPU, where this wasn't an issue. Since
this commit the BPF context is stored in 'current' task_struct. When
running veth in threaded-NAPI mode, then the kthread becomes the storage
area. Now a race exists between two concurrent veth_pool() function calls
one exiting NAPI and one running new NAPI, both using the same BPF net
context.

Race is when another CPU gets within the xdp_set_return_frame_no_direct()
section before exiting veth_pool() calls the clear-function
xdp_clear_return_frame_no_direct().</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-68340" data-description="in the linux kernel, the following vulnerability has been resolved:

team: move team device type change at the end of team_port_add

attempting to add a port device that is already up will expectedly fail,
but not before modifying the team device header_ops.

in the case of the syzbot reproducer the gre0 device is
already in state up when it attempts to add it as a
port device of team0, this fails but before that
header_ops->create of team0 is changed from eth_header to ipgre_header
in the call to team_dev_type_check_change.

later when we end up in ipgre_header() struct ip_tunnel* points to nonsense
as the private data of the device still holds a struct team.

example sequence of iproute2 commands to reproduce the hang/bug():
ip link add dev team0 type team
ip link add dev gre0 type gre
ip link set dev gre0 up
ip link set dev gre0 master team0
ip link set dev team0 up
ping -i team0 1.1.1.1

move team_dev_type_check_change down where all other checks have passed
as it changes the dev type with no way to restore it in case
one of the checks that follow it fail.

also make sure to preserve the origial mtu assignment:
  - if port_dev is not the same type as dev, dev takes mtu from port_dev
  - if port_dev is the same type as dev, port_dev takes mtu from dev

this is done by adding a conditional before the call to dev_set_mtu
to prevent it from assigning port_dev->mtu = dev->mtu and instead
letting team_dev_type_check_change assign dev->mtu = port_dev->mtu.
the conditional is needed because the patch moves the call to
team_dev_type_check_change past dev_set_mtu.

testing:
  - team device driver in-tree selftests
  - add/remove various devices as slaves of team device
  - syzbot">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-68340" target="_blank">CVE-2025-68340</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-12-23 08:16:40 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">N/A</span></p>
                    <p><span class="feed-label">CVSS Score:</span> N/A</p>
                    <p>In the Linux kernel, the following vulnerability has been resolved:

team: Move team device type change at the end of team_port_add

Attempting to add a port device that is already up will expectedly fail,
but not before modifying the team device header_ops.

In the case of the syzbot reproducer the gre0 device is
already in state UP when it attempts to add it as a
port device of team0, this fails but before that
header_ops->create of team0 is changed from eth_header to ipgre_header
in the call to team_dev_type_check_change.

Later when we end up in ipgre_header() struct ip_tunnel* points to nonsense
as the private data of the device still holds a struct team.

Example sequence of iproute2 commands to reproduce the hang/BUG():
ip link add dev team0 type team
ip link add dev gre0 type gre
ip link set dev gre0 up
ip link set dev gre0 master team0
ip link set dev team0 up
ping -I team0 1.1.1.1

Move team_dev_type_check_change down where all other checks have passed
as it changes the dev type with no way to restore it in case
one of the checks that follow it fail.

Also make sure to preserve the origial mtu assignment:
  - If port_dev is not the same type as dev, dev takes mtu from port_dev
  - If port_dev is the same type as dev, port_dev takes mtu from dev

This is done by adding a conditional before the call to dev_set_mtu
to prevent it from assigning port_dev->mtu = dev->mtu and instead
letting team_dev_type_check_change assign dev->mtu = port_dev->mtu.
The conditional is needed because the patch moves the call to
team_dev_type_check_change past dev_set_mtu.

Testing:
  - team device driver in-tree selftests
  - Add/remove various devices as slaves of team device
  - syzbot</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-68339" data-description="in the linux kernel, the following vulnerability has been resolved:

atm/fore200e: fix possible data race in fore200e_open()

protect access to fore200e->available_cell_rate with rate_mtx lock in the
error handling path of fore200e_open() to prevent a data race.

the field fore200e->available_cell_rate is a shared resource used to track
available bandwidth. it is concurrently accessed by fore200e_open(),
fore200e_close(), and fore200e_change_qos().

in fore200e_open(), the lock rate_mtx is correctly held when subtracting
vcc->qos.txtp.max_pcr from available_cell_rate to reserve bandwidth.
however, if the subsequent call to fore200e_activate_vcin() fails, the
function restores the reserved bandwidth by adding back to
available_cell_rate without holding the lock.

this introduces a race condition because available_cell_rate is a global
device resource shared across all vccs. if the error path in
fore200e_open() executes concurrently with operations like
fore200e_close() or fore200e_change_qos() on other vccs, a
read-modify-write race occurs.

specifically, the error path reads the rate without the lock. if another
cpu acquires the lock and modifies the rate (e.g., releasing bandwidth in
fore200e_close()) between this read and the subsequent write, the error
path will overwrite the concurrent update with a stale value. this results
in incorrect bandwidth accounting.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-68339" target="_blank">CVE-2025-68339</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-12-23 08:16:40 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">N/A</span></p>
                    <p><span class="feed-label">CVSS Score:</span> N/A</p>
                    <p>In the Linux kernel, the following vulnerability has been resolved:

atm/fore200e: Fix possible data race in fore200e_open()

Protect access to fore200e->available_cell_rate with rate_mtx lock in the
error handling path of fore200e_open() to prevent a data race.

The field fore200e->available_cell_rate is a shared resource used to track
available bandwidth. It is concurrently accessed by fore200e_open(),
fore200e_close(), and fore200e_change_qos().

In fore200e_open(), the lock rate_mtx is correctly held when subtracting
vcc->qos.txtp.max_pcr from available_cell_rate to reserve bandwidth.
However, if the subsequent call to fore200e_activate_vcin() fails, the
function restores the reserved bandwidth by adding back to
available_cell_rate without holding the lock.

This introduces a race condition because available_cell_rate is a global
device resource shared across all VCCs. If the error path in
fore200e_open() executes concurrently with operations like
fore200e_close() or fore200e_change_qos() on other VCCs, a
read-modify-write race occurs.

Specifically, the error path reads the rate without the lock. If another
CPU acquires the lock and modifies the rate (e.g., releasing bandwidth in
fore200e_close()) between this read and the subsequent write, the error
path will overwrite the concurrent update with a stale value. This results
in incorrect bandwidth accounting.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-68338" data-description="in the linux kernel, the following vulnerability has been resolved:

net: dsa: microchip: don't free uninitialized ksz_irq

if something goes wrong at setup, ksz_irq_free() can be called on
uninitialized ksz_irq (for example when ksz_ptp_irq_setup() fails). it
leads to freeing uninitialized irq numbers and/or domains.

use dsa_switch_for_each_user_port_continue_reverse() in the error path
to iterate only over the fully initialized ports.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-68338" target="_blank">CVE-2025-68338</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-12-23 08:16:40 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">N/A</span></p>
                    <p><span class="feed-label">CVSS Score:</span> N/A</p>
                    <p>In the Linux kernel, the following vulnerability has been resolved:

net: dsa: microchip: Don't free uninitialized ksz_irq

If something goes wrong at setup, ksz_irq_free() can be called on
uninitialized ksz_irq (for example when ksz_ptp_irq_setup() fails). It
leads to freeing uninitialized IRQ numbers and/or domains.

Use dsa_switch_for_each_user_port_continue_reverse() in the error path
to iterate only over the fully initialized ports.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-66845" data-description="a reflected cross-site scripting (xss) vulnerability has been identified in techstore version 1.0. the user_name endpoint reflects the id query parameter directly into the html response without output encoding or sanitization, allowing execution of arbitrary javascript code in a victim’s browser.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-66845" target="_blank">CVE-2025-66845</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-12-23 08:16:40 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">MEDIUM</span></p>
                    <p><span class="feed-label">CVSS Score:</span> 6.1</p>
                    <p>A reflected Cross-Site Scripting (XSS) vulnerability has been identified in TechStore version 1.0. The user_name endpoint reflects the id query parameter directly into the HTML response without output encoding or sanitization, allowing execution of arbitrary JavaScript code in a victim’s browser.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2023-5094" data-description="rejected reason: this cve id was assigned to an issue which was later deemed not security relevant.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2023-5094" target="_blank">CVE-2023-5094</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-12-23 08:16:40 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">N/A</span></p>
                    <p><span class="feed-label">CVSS Score:</span> N/A</p>
                    <p>Rejected reason: This CVE id was assigned to an issue which was later deemed not security relevant.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2023-5093" data-description="rejected reason: this cve id was assigned to an issue which was later deemed not security relevant.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2023-5093" target="_blank">CVE-2023-5093</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-12-23 08:16:40 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">N/A</span></p>
                    <p><span class="feed-label">CVSS Score:</span> N/A</p>
                    <p>Rejected reason: This CVE id was assigned to an issue which was later deemed not security relevant.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2023-5092" data-description="rejected reason: this cve id was assigned to an issue which was later deemed not security relevant.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2023-5092" target="_blank">CVE-2023-5092</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-12-23 08:16:39 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">N/A</span></p>
                    <p><span class="feed-label">CVSS Score:</span> N/A</p>
                    <p>Rejected reason: This CVE id was assigned to an issue which was later deemed not security relevant.</p>
                </div>
        
            </div>
        </div>

        <footer class="footer">
            <p>© 2025 dotne1 - Cybersecurity Portfolio</p>
        </footer>

        <script>
            function searchCVEs() {
                const input = document.getElementById('searchInput').value.toLowerCase();
                const cveEntries = document.getElementsByClassName('cve-entry');
                for (let i = 0; i < cveEntries.length; i++) {
                    const cveId = cveEntries[i].getAttribute('data-cve-id').toLowerCase();
                    const description = cveEntries[i].getAttribute('data-description');
                    if (cveId.includes(input) || description.includes(input)) {
                        cveEntries[i].style.display = '';
                    } else {
                        cveEntries[i].style.display = 'none';
                    }
                }
            }
        </script>
    </body>
    </html>
    