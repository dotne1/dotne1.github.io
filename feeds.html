
    <!DOCTYPE html>
    <html lang="en">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <meta name="description" content="Security alerts and cybersecurity news feeds">
        <meta name="keywords" content="cybersecurity news, security alerts, vulnerability feeds, threat intelligence">
        <meta name="author" content="dotne1">
        <meta property="og:title" content="Security Feeds - dotne1's Cybersecurity Portfolio">
        <meta property="og:description" content="Stay updated with the latest cybersecurity news and alerts">
        <meta property="og:type" content="website">
        <title>Security Feeds - dotne1's Cybersecurity Portfolio</title>
        <link rel="stylesheet" href="styles.css">
        <link rel="icon" type="image/x-icon" href="/favicon.ico">
    </head>
    <body>
        <nav class="navbar">
            <div class="nav-links">
                <a href="index.html" class="nav-link">Home</a>
                <a href="about-me.html" class="nav-link">About Me</a>
                <a href="projects.html" class="nav-link">Projects</a>
                <a href="resume.html" class="nav-link">Resume</a>
                <a href="feeds.html" class="nav-link">Feeds</a>
            </div>
        </nav>

        <div class="container" role="main">
            <h1 class="main-header">Security Feeds</h1>
            <div class="search-bar">
                <input type="text" id="searchInput" placeholder="Search CVEs..." onkeyup="searchCVEs()">
            </div>
            <div class="feed-preview" id="cveFeed">
                <div class="feed-header">Latest Vulnerabilities</div>
    
                <div class="cve-entry" data-cve-id="CVE-2025-57579" data-description="an issue in totolink wi-fi 6 router series device x2000r-gh-v2.0.0 allows a remote attacker to execute arbitrary code via the default password">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-57579" target="_blank">CVE-2025-57579</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-09-12 11:15:35 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-online">HIGH</span></p>
                    <p><span class="feed-label">CVSS Score:</span> 8.0</p>
                    <p>An issue in TOTOLINK Wi-Fi 6 Router Series Device X2000R-Gh-V2.0.0 allows a remote attacker to execute arbitrary code via the default password</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-57578" data-description="an issue in h3c magic m device m2v100r006 allows a remote attacker to execute arbitrary code via the default password">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-57578" target="_blank">CVE-2025-57578</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-09-12 11:15:35 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-online">HIGH</span></p>
                    <p><span class="feed-label">CVSS Score:</span> 8.0</p>
                    <p>An issue in H3C Magic M Device M2V100R006 allows a remote attacker to execute arbitrary code via the default password</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-57577" data-description="an issue in h3c device r365v300r004 allows a remote attacker to execute arbitrary code via the default password">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-57577" target="_blank">CVE-2025-57577</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-09-12 11:15:34 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-online">HIGH</span></p>
                    <p><span class="feed-label">CVSS Score:</span> 8.0</p>
                    <p>An issue in H3C Device R365V300R004 allows a remote attacker to execute arbitrary code via the default password</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-55835" data-description="file upload vulnerability in sueamcms v.0.1.2 allows a remote attacker to execute arbitrary code via the lack of filtering.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-55835" target="_blank">CVE-2025-55835</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-09-12 11:15:34 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-online">CRITICAL</span></p>
                    <p><span class="feed-label">CVSS Score:</span> 9.8</p>
                    <p>File Upload vulnerability in SueamCMS v.0.1.2 allows a remote attacker to execute arbitrary code via the lack of filtering.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-39799" data-description="in the linux kernel, the following vulnerability has been resolved:

acpi: processor: perflib: move problematic pr->performance check

commit d33bd88ac0eb ("acpi: processor: perflib: fix initial _ppc limit
application") added a pr->performance check that prevents the frequency
qos request from being added when the given processor has no performance
object.  unfortunately, this causes a warn() in freq_qos_remove_request()
to trigger on an attempt to take the given cpu offline later because the
frequency qos object has not been added for it due to the missing
performance object.

address this by moving the pr->performance check before calling
acpi_processor_get_platform_limit() so it only prevents a limit from
being set for the cpu if the performance object is not present.  this
way, the frequency qos request is added as it was before the above
commit and it is present all the time along with the cpu's cpufreq
policy regardless of whether or not the cpu is online.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-39799" target="_blank">CVE-2025-39799</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-09-12 11:15:34 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">N/A</span></p>
                    <p><span class="feed-label">CVSS Score:</span> N/A</p>
                    <p>In the Linux kernel, the following vulnerability has been resolved:

ACPI: processor: perflib: Move problematic pr->performance check

Commit d33bd88ac0eb ("ACPI: processor: perflib: Fix initial _PPC limit
application") added a pr->performance check that prevents the frequency
QoS request from being added when the given processor has no performance
object.  Unfortunately, this causes a WARN() in freq_qos_remove_request()
to trigger on an attempt to take the given CPU offline later because the
frequency QoS object has not been added for it due to the missing
performance object.

Address this by moving the pr->performance check before calling
acpi_processor_get_platform_limit() so it only prevents a limit from
being set for the CPU if the performance object is not present.  This
way, the frequency QoS request is added as it was before the above
commit and it is present all the time along with the CPU's cpufreq
policy regardless of whether or not the CPU is online.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-39798" data-description="in the linux kernel, the following vulnerability has been resolved:

nfs: fix the setting of capabilities when automounting a new filesystem

capabilities cannot be inherited when we cross into a new filesystem.
they need to be reset to the minimal defaults, and then probed for
again.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-39798" target="_blank">CVE-2025-39798</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-09-12 11:15:34 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">N/A</span></p>
                    <p><span class="feed-label">CVSS Score:</span> N/A</p>
                    <p>In the Linux kernel, the following vulnerability has been resolved:

NFS: Fix the setting of capabilities when automounting a new filesystem

Capabilities cannot be inherited when we cross into a new filesystem.
They need to be reset to the minimal defaults, and then probed for
again.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-39797" data-description="in the linux kernel, the following vulnerability has been resolved:

xfrm: duplicate spi handling

the issue originates when strongswan initiates an xfrm_msg_allocspi
netlink message, which triggers the kernel function xfrm_alloc_spi().
this function is expected to ensure uniqueness of the security parameter
index (spi) for inbound security associations (sas). however, it can
return success even when the requested spi is already in use, leading
to duplicate spis assigned to multiple inbound sas, differentiated
only by their destination addresses.

this behavior causes inconsistencies during spi lookups for inbound packets.
since the lookup may return an arbitrary sa among those with the same spi,
packet processing can fail, resulting in packet drops.

according to rfc 4301 section 4.4.2 , for inbound processing a unicast sa
is uniquely identified by the spi and optionally protocol.

reproducing the issue reliably:
to consistently reproduce the problem, restrict the available spi range in
charon.conf : spi_min = 0x10000000 spi_max = 0x10000002
this limits the system to only 2 usable spi values.
next, create more than 2 child sa. each using unique pair of src/dst address.
as soon as the 3rd child sa is initiated, it will be assigned a duplicate
spi, since the spi pool is already exhausted.
with a narrow spi range, the issue is consistently reproducible.
with a broader/default range, it becomes rare and unpredictable.

current implementation:
xfrm_spi_hash() lookup function computes hash using daddr, proto, and family.
so if two sas have the same spi but different destination addresses, then
they will:
a. hash into different buckets
b. be stored in different linked lists (byspi + h)
c. not be seen in the same hlist_for_each_entry_rcu() iteration.
as a result, the lookup will result in null and kernel allows that duplicate spi

proposed change:
xfrm_state_lookup_spi_proto() does a truly global search - across all states,
regardless of hash bucket and matches spi and proto.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-39797" target="_blank">CVE-2025-39797</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-09-12 11:15:34 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">N/A</span></p>
                    <p><span class="feed-label">CVSS Score:</span> N/A</p>
                    <p>In the Linux kernel, the following vulnerability has been resolved:

xfrm: Duplicate SPI Handling

The issue originates when Strongswan initiates an XFRM_MSG_ALLOCSPI
Netlink message, which triggers the kernel function xfrm_alloc_spi().
This function is expected to ensure uniqueness of the Security Parameter
Index (SPI) for inbound Security Associations (SAs). However, it can
return success even when the requested SPI is already in use, leading
to duplicate SPIs assigned to multiple inbound SAs, differentiated
only by their destination addresses.

This behavior causes inconsistencies during SPI lookups for inbound packets.
Since the lookup may return an arbitrary SA among those with the same SPI,
packet processing can fail, resulting in packet drops.

According to RFC 4301 section 4.4.2 , for inbound processing a unicast SA
is uniquely identified by the SPI and optionally protocol.

Reproducing the Issue Reliably:
To consistently reproduce the problem, restrict the available SPI range in
charon.conf : spi_min = 0x10000000 spi_max = 0x10000002
This limits the system to only 2 usable SPI values.
Next, create more than 2 Child SA. each using unique pair of src/dst address.
As soon as the 3rd Child SA is initiated, it will be assigned a duplicate
SPI, since the SPI pool is already exhausted.
With a narrow SPI range, the issue is consistently reproducible.
With a broader/default range, it becomes rare and unpredictable.

Current implementation:
xfrm_spi_hash() lookup function computes hash using daddr, proto, and family.
So if two SAs have the same SPI but different destination addresses, then
they will:
a. Hash into different buckets
b. Be stored in different linked lists (byspi + h)
c. Not be seen in the same hlist_for_each_entry_rcu() iteration.
As a result, the lookup will result in NULL and kernel allows that Duplicate SPI

Proposed Change:
xfrm_state_lookup_spi_proto() does a truly global search - across all states,
regardless of hash bucket and matches SPI and proto.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-39796" data-description="in the linux kernel, the following vulnerability has been resolved:

net: lapbether: ignore ops-locked netdevs

syzkaller managed to trigger lock dependency in xsk_notify via
register_netdevice. as discussed in [0], using register_netdevice
in the notifiers is problematic so skip adding lapbeth for ops-locked
devices.

       xsk_notifier+0xa4/0x280 net/xdp/xsk.c:1645
       notifier_call_chain+0xbc/0x410 kernel/notifier.c:85
       call_netdevice_notifiers_info+0xbe/0x140 net/core/dev.c:2230
       call_netdevice_notifiers_extack net/core/dev.c:2268 [inline]
       call_netdevice_notifiers net/core/dev.c:2282 [inline]
       unregister_netdevice_many_notify+0xf9d/0x2700 net/core/dev.c:12077
       unregister_netdevice_many net/core/dev.c:12140 [inline]
       unregister_netdevice_queue+0x305/0x3f0 net/core/dev.c:11984
       register_netdevice+0x18f1/0x2270 net/core/dev.c:11149
       lapbeth_new_device drivers/net/wan/lapbether.c:420 [inline]
       lapbeth_device_event+0x5b1/0xbe0 drivers/net/wan/lapbether.c:462
       notifier_call_chain+0xbc/0x410 kernel/notifier.c:85
       call_netdevice_notifiers_info+0xbe/0x140 net/core/dev.c:2230
       call_netdevice_notifiers_extack net/core/dev.c:2268 [inline]
       call_netdevice_notifiers net/core/dev.c:2282 [inline]
       __dev_notify_flags+0x12c/0x2e0 net/core/dev.c:9497
       netif_change_flags+0x108/0x160 net/core/dev.c:9526
       dev_change_flags+0xba/0x250 net/core/dev_api.c:68
       devinet_ioctl+0x11d5/0x1f50 net/ipv4/devinet.c:1200
       inet_ioctl+0x3a7/0x3f0 net/ipv4/af_inet.c:1001

0: https://lore.kernel.org/netdev/20250625140357.6203d0af@kernel.org/">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-39796" target="_blank">CVE-2025-39796</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-09-12 11:15:33 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">N/A</span></p>
                    <p><span class="feed-label">CVSS Score:</span> N/A</p>
                    <p>In the Linux kernel, the following vulnerability has been resolved:

net: lapbether: ignore ops-locked netdevs

Syzkaller managed to trigger lock dependency in xsk_notify via
register_netdevice. As discussed in [0], using register_netdevice
in the notifiers is problematic so skip adding lapbeth for ops-locked
devices.

       xsk_notifier+0xa4/0x280 net/xdp/xsk.c:1645
       notifier_call_chain+0xbc/0x410 kernel/notifier.c:85
       call_netdevice_notifiers_info+0xbe/0x140 net/core/dev.c:2230
       call_netdevice_notifiers_extack net/core/dev.c:2268 [inline]
       call_netdevice_notifiers net/core/dev.c:2282 [inline]
       unregister_netdevice_many_notify+0xf9d/0x2700 net/core/dev.c:12077
       unregister_netdevice_many net/core/dev.c:12140 [inline]
       unregister_netdevice_queue+0x305/0x3f0 net/core/dev.c:11984
       register_netdevice+0x18f1/0x2270 net/core/dev.c:11149
       lapbeth_new_device drivers/net/wan/lapbether.c:420 [inline]
       lapbeth_device_event+0x5b1/0xbe0 drivers/net/wan/lapbether.c:462
       notifier_call_chain+0xbc/0x410 kernel/notifier.c:85
       call_netdevice_notifiers_info+0xbe/0x140 net/core/dev.c:2230
       call_netdevice_notifiers_extack net/core/dev.c:2268 [inline]
       call_netdevice_notifiers net/core/dev.c:2282 [inline]
       __dev_notify_flags+0x12c/0x2e0 net/core/dev.c:9497
       netif_change_flags+0x108/0x160 net/core/dev.c:9526
       dev_change_flags+0xba/0x250 net/core/dev_api.c:68
       devinet_ioctl+0x11d5/0x1f50 net/ipv4/devinet.c:1200
       inet_ioctl+0x3a7/0x3f0 net/ipv4/af_inet.c:1001

0: https://lore.kernel.org/netdev/20250625140357.6203d0af@kernel.org/</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-39795" data-description="in the linux kernel, the following vulnerability has been resolved:

block: avoid possible overflow for chunk_sectors check in blk_stack_limits()

in blk_stack_limits(), we check that the t->chunk_sectors value is a
multiple of the t->physical_block_size value.

however, by finding the chunk_sectors value in bytes, we may overflow
the unsigned int which holds chunk_sectors, so change the check to be
based on sectors.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-39795" target="_blank">CVE-2025-39795</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-09-12 11:15:33 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">N/A</span></p>
                    <p><span class="feed-label">CVSS Score:</span> N/A</p>
                    <p>In the Linux kernel, the following vulnerability has been resolved:

block: avoid possible overflow for chunk_sectors check in blk_stack_limits()

In blk_stack_limits(), we check that the t->chunk_sectors value is a
multiple of the t->physical_block_size value.

However, by finding the chunk_sectors value in bytes, we may overflow
the unsigned int which holds chunk_sectors, so change the check to be
based on sectors.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-39794" data-description="in the linux kernel, the following vulnerability has been resolved:

arm: tegra: use i/o memcpy to write to iram

kasan crashes the kernel trying to check boundaries when using the
normal memcpy.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-39794" target="_blank">CVE-2025-39794</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-09-12 11:15:33 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">N/A</span></p>
                    <p><span class="feed-label">CVSS Score:</span> N/A</p>
                    <p>In the Linux kernel, the following vulnerability has been resolved:

ARM: tegra: Use I/O memcpy to write to IRAM

Kasan crashes the kernel trying to check boundaries when using the
normal memcpy.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-39793" data-description="in the linux kernel, the following vulnerability has been resolved:

io_uring/memmap: cast nr_pages to size_t before shifting

if the allocated size exceeds uint_max, then it's necessary to cast
the mr->nr_pages value to size_t to prevent it from overflowing. in
practice this isn't much of a concern as the required memory size will
have been validated upfront, and accounted to the user. and > 4gb sizes
will be necessary to make the lack of a cast a problem, which greatly
exceeds normal user locked_vm settings that are generally in the kb to
mb range. however, if root is used, then accounting isn't done, and
then it's possible to hit this issue.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-39793" target="_blank">CVE-2025-39793</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-09-12 11:15:33 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">N/A</span></p>
                    <p><span class="feed-label">CVSS Score:</span> N/A</p>
                    <p>In the Linux kernel, the following vulnerability has been resolved:

io_uring/memmap: cast nr_pages to size_t before shifting

If the allocated size exceeds UINT_MAX, then it's necessary to cast
the mr->nr_pages value to size_t to prevent it from overflowing. In
practice this isn't much of a concern as the required memory size will
have been validated upfront, and accounted to the user. And > 4GB sizes
will be necessary to make the lack of a cast a problem, which greatly
exceeds normal user locked_vm settings that are generally in the kb to
mb range. However, if root is used, then accounting isn't done, and
then it's possible to hit this issue.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-39792" data-description="in the linux kernel, the following vulnerability has been resolved:

dm: always split write bios to zoned device limits

any zoned dm target that requires zone append emulation will use the
block layer zone write plugging. in such case, dm target drivers must
not split bios using dm_accept_partial_bio() as doing so can potentially
lead to deadlocks with queue freeze operations. regular write operations
used to emulate zone append operations also cannot be split by the
target driver as that would result in an invalid writen sector value
return using the bio sector.

in order for zoned dm target drivers to avoid such incorrect bio
splitting, we must ensure that large bios are split before being passed
to the map() function of the target, thus guaranteeing that the
limits for the mapped device are not exceeded.

dm-crypt and dm-flakey are the only target drivers supporting zoned
devices and using dm_accept_partial_bio().

in the case of dm-crypt, this function is used to split bios to the
internal max_write_size limit (which will be suppressed in a different
patch). however, since crypt_alloc_buffer() uses a bioset allowing only
up to bio_max_vecs (256) vectors in a bio. the dm-crypt device
max_segments limit, which is not set and so default to blk_max_segments
(128), must thus be respected and write bios split accordingly.

in the case of dm-flakey, since zone append emulation is not required,
the block layer zone write plugging is not used and no splitting of bios
required.

modify the function dm_zone_bio_needs_split() to use the block layer
helper function bio_needs_zone_write_plugging() to force a call to
bio_split_to_limits() in dm_split_and_process_bio(). this allows dm
target drivers to avoid using dm_accept_partial_bio() for write
operations on zoned dm devices.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-39792" target="_blank">CVE-2025-39792</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-09-12 11:15:33 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">N/A</span></p>
                    <p><span class="feed-label">CVSS Score:</span> N/A</p>
                    <p>In the Linux kernel, the following vulnerability has been resolved:

dm: Always split write BIOs to zoned device limits

Any zoned DM target that requires zone append emulation will use the
block layer zone write plugging. In such case, DM target drivers must
not split BIOs using dm_accept_partial_bio() as doing so can potentially
lead to deadlocks with queue freeze operations. Regular write operations
used to emulate zone append operations also cannot be split by the
target driver as that would result in an invalid writen sector value
return using the BIO sector.

In order for zoned DM target drivers to avoid such incorrect BIO
splitting, we must ensure that large BIOs are split before being passed
to the map() function of the target, thus guaranteeing that the
limits for the mapped device are not exceeded.

dm-crypt and dm-flakey are the only target drivers supporting zoned
devices and using dm_accept_partial_bio().

In the case of dm-crypt, this function is used to split BIOs to the
internal max_write_size limit (which will be suppressed in a different
patch). However, since crypt_alloc_buffer() uses a bioset allowing only
up to BIO_MAX_VECS (256) vectors in a BIO. The dm-crypt device
max_segments limit, which is not set and so default to BLK_MAX_SEGMENTS
(128), must thus be respected and write BIOs split accordingly.

In the case of dm-flakey, since zone append emulation is not required,
the block layer zone write plugging is not used and no splitting of BIOs
required.

Modify the function dm_zone_bio_needs_split() to use the block layer
helper function bio_needs_zone_write_plugging() to force a call to
bio_split_to_limits() in dm_split_and_process_bio(). This allows DM
target drivers to avoid using dm_accept_partial_bio() for write
operations on zoned DM devices.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-10320" data-description="a vulnerability was detected in iteachyou dreamer cms up to 4.1.3.2. this issue affects some unknown processing of the file /admin/user/updatepwd. performing manipulation results in weak password requirements. remote exploitation of the attack is possible. a high degree of complexity is needed for the attack. the exploitability is assessed as difficult. the exploit is now public and may be used. the vendor was contacted early about this disclosure but did not respond in any way.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-10320" target="_blank">CVE-2025-10320</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-09-12 11:15:33 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">LOW</span></p>
                    <p><span class="feed-label">CVSS Score:</span> 3.1</p>
                    <p>A vulnerability was detected in iteachyou Dreamer CMS up to 4.1.3.2. This issue affects some unknown processing of the file /admin/user/updatePwd. Performing manipulation results in weak password requirements. Remote exploitation of the attack is possible. A high degree of complexity is needed for the attack. The exploitability is assessed as difficult. The exploit is now public and may be used. The vendor was contacted early about this disclosure but did not respond in any way.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-55996" data-description="viber desktop 25.6.0 is vulnerable to html injection via the text parameter of the message compose/forward interface">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-55996" target="_blank">CVE-2025-55996</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-09-12 10:15:32 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">MEDIUM</span></p>
                    <p><span class="feed-label">CVSS Score:</span> 6.3</p>
                    <p>Viber Desktop 25.6.0 is vulnerable to HTML Injection via the text parameter of the message compose/forward interface</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-10319" data-description="a security flaw has been discovered in jeecgboot up to 3.8.2. affected by this issue is some unknown functionality of the file /sys/tenant/exportlog of the component tenant log export. the manipulation results in improper authorization. the attack can be launched remotely. the exploit has been released to the public and may be exploited. the vendor was contacted early about this disclosure but did not respond in any way.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-10319" target="_blank">CVE-2025-10319</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-09-12 10:15:32 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">MEDIUM</span></p>
                    <p><span class="feed-label">CVSS Score:</span> 4.3</p>
                    <p>A security flaw has been discovered in JeecgBoot up to 3.8.2. Affected by this issue is some unknown functionality of the file /sys/tenant/exportLog of the component Tenant Log Export. The manipulation results in improper authorization. The attack can be launched remotely. The exploit has been released to the public and may be exploited. The vendor was contacted early about this disclosure but did not respond in any way.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-9556" data-description="langchaingo supports the use of jinja2 syntax when parsing prompts, which is in turn parsed using the gonja library v1.5.3.
gonja supports include and extends syntax to read files, which leads to a server side template injection vulnerability within langchaingo, allowing an attacker to insert a statement into a prompt to read the "etc/passwd" file.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-9556" target="_blank">CVE-2025-9556</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-09-12 09:15:42 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-online">CRITICAL</span></p>
                    <p><span class="feed-label">CVSS Score:</span> 9.8</p>
                    <p>Langchaingo supports the use of jinja2 syntax when parsing prompts, which is in turn parsed using the gonja library v1.5.3.
Gonja supports include and extends syntax to read files, which leads to a server side template injection vulnerability within langchaingo, allowing an attacker to insert a statement into a prompt to read the "etc/passwd" file.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-59139" data-description="hono is a web application framework that provides support for any javascript runtime. in versions prior to 4.9.7, a flaw in the `bodylimit` middleware could allow bypassing the configured request body size limit when conflicting http headers were present. the middleware previously prioritized the `content-length` header even when a `transfer-encoding: chunked` header was also included. according to the http specification, `content-length` must be ignored in such cases. this discrepancy could allow oversized request bodies to bypass the configured limit. most standards-compliant runtimes and reverse proxies may reject such malformed requests with `400 bad request`, so the practical impact depends on the runtime and deployment environment. if body size limits are used as a safeguard against large or malicious requests, this flaw could allow attackers to send oversized request bodies. the primary risk is denial of service (dos) due to excessive memory or cpu consumption when handling very large requests. the implementation has been updated to align with the http specification, ensuring that `transfer-encoding` takes precedence over `content-length`. the issue is fixed in hono v4.9.7, and all users should upgrade immediately.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-59139" target="_blank">CVE-2025-59139</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-09-12 09:15:41 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">MEDIUM</span></p>
                    <p><span class="feed-label">CVSS Score:</span> 5.3</p>
                    <p>Hono is a Web application framework that provides support for any JavaScript runtime. In versions prior to 4.9.7, a flaw in the `bodyLimit` middleware could allow bypassing the configured request body size limit when conflicting HTTP headers were present. The middleware previously prioritized the `Content-Length` header even when a `Transfer-Encoding: chunked` header was also included. According to the HTTP specification, `Content-Length` must be ignored in such cases. This discrepancy could allow oversized request bodies to bypass the configured limit. Most standards-compliant runtimes and reverse proxies may reject such malformed requests with `400 Bad Request`, so the practical impact depends on the runtime and deployment environment. If body size limits are used as a safeguard against large or malicious requests, this flaw could allow attackers to send oversized request bodies. The primary risk is denial of service (DoS) due to excessive memory or CPU consumption when handling very large requests. The implementation has been updated to align with the HTTP specification, ensuring that `Transfer-Encoding` takes precedence over `Content-Length`. The issue is fixed in Hono v4.9.7, and all users should upgrade immediately.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-59058" data-description="httpsig-rs is a rust implementation of ietf rfc 9421 http message signatures. prior to version 0.0.19, the hmac signature comparison is not timing-safe. this makes anyone who uses hs256 signature verification vulnerable to a timing attack that allows the attacker to forge a signature. version 0.0.19 fixes the issue.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-59058" target="_blank">CVE-2025-59058</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-09-12 09:15:41 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">MEDIUM</span></p>
                    <p><span class="feed-label">CVSS Score:</span> 5.9</p>
                    <p>httpsig-rs is a Rust implementation of IETF RFC 9421 http message signatures. Prior to version 0.0.19, the HMAC signature comparison is not timing-safe. This makes anyone who uses HS256 signature verification vulnerable to a timing attack that allows the attacker to forge a signature. Version 0.0.19 fixes the issue.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-10365" data-description="the evertz sdvn 3080ipx-10g is a high bandwidth ethernet switching fabric for video application. this device exposes a web management interface on port 80. this web management interface can be used by administrators to control product
features, setup network switching, and register license among other features. the application has been developed in php with the webeasy sdk, also named ‘ewb’ by evertz.

this web interface has two endpoints that are vulnerable to arbitrary command injection (cve-2025-4009, cve-2025-10364) and the authentication mechanism has a flaw leading to authentication bypass (cve-2025-10365).

remote unauthenticated attackers can gain arbitrary command execution with elevated privileges ( root ) on affected devices.

this level of access could lead to serious business impact such as the interruption of media streaming, modification of media being streamed, alteration of closed captions being generated, among others.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-10365" target="_blank">CVE-2025-10365</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-09-12 09:15:40 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">N/A</span></p>
                    <p><span class="feed-label">CVSS Score:</span> N/A</p>
                    <p>The Evertz SDVN 3080ipx-10G is a High Bandwidth Ethernet Switching Fabric for Video Application. This device exposes a web management interface on port 80. This web management interface can be used by administrators to control product
features, setup network switching, and register license among other features. The application has been developed in PHP with the webEASY SDK, also named ‘ewb’ by Evertz.

This web interface has two endpoints that are vulnerable to arbitrary command injection (CVE-2025-4009, CVE-2025-10364) and the authentication mechanism has a flaw leading to authentication bypass (CVE-2025-10365).

Remote unauthenticated attackers can gain arbitrary command execution with elevated privileges ( root ) on affected devices.

This level of access could lead to serious business impact such as the interruption of media streaming, modification of media being streamed, alteration of closed captions being generated, among others.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-10364" data-description="the evertz sdvn 3080ipx-10g is a high bandwidth ethernet switching fabric for video application. this device exposes a web management interface on port 80. this web management interface can be used by administrators to control product
features, setup network switching, and register license among other features. the application has been developed in php with the webeasy sdk, also named ‘ewb’ by evertz.

this web interface has two endpoints that are vulnerable to arbitrary command injection (cve-2025-4009, cve-2025-10364) and the authentication mechanism has a flaw leading to authentication bypass (cve-2025-10365).

cve-2025-4009 covers the command injection in feature-transfer-import.php
cve-2025-10364 covers the command injection in feature-transfer-export.php

remote unauthenticated attackers can gain arbitrary command execution with elevated privileges ( root ) on affected devices.

this level of access could lead to serious business impact such as the interruption of media streaming, modification of media being streamed, alteration of closed captions being generated, among others.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-10364" target="_blank">CVE-2025-10364</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-09-12 09:15:40 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">N/A</span></p>
                    <p><span class="feed-label">CVSS Score:</span> N/A</p>
                    <p>The Evertz SDVN 3080ipx-10G is a High Bandwidth Ethernet Switching Fabric for Video Application. This device exposes a web management interface on port 80. This web management interface can be used by administrators to control product
features, setup network switching, and register license among other features. The application has been developed in PHP with the webEASY SDK, also named ‘ewb’ by Evertz.

This web interface has two endpoints that are vulnerable to arbitrary command injection (CVE-2025-4009, CVE-2025-10364) and the authentication mechanism has a flaw leading to authentication bypass (CVE-2025-10365).

CVE-2025-4009 covers the command injection in feature-transfer-import.php
CVE-2025-10364 covers the command injection in feature-transfer-export.php

Remote unauthenticated attackers can gain arbitrary command execution with elevated privileges ( root ) on affected devices.

This level of access could lead to serious business impact such as the interruption of media streaming, modification of media being streamed, alteration of closed captions being generated, among others.</p>
                </div>
        
            </div>
        </div>

        <footer class="footer">
            <p>© 2025 dotne1 - Cybersecurity Portfolio</p>
        </footer>

        <script>
            function searchCVEs() {
                const input = document.getElementById('searchInput').value.toLowerCase();
                const cveEntries = document.getElementsByClassName('cve-entry');
                for (let i = 0; i < cveEntries.length; i++) {
                    const cveId = cveEntries[i].getAttribute('data-cve-id').toLowerCase();
                    const description = cveEntries[i].getAttribute('data-description');
                    if (cveId.includes(input) || description.includes(input)) {
                        cveEntries[i].style.display = '';
                    } else {
                        cveEntries[i].style.display = 'none';
                    }
                }
            }
        </script>
    </body>
    </html>
    