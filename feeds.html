
    <!DOCTYPE html>
    <html lang="en">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <meta name="description" content="Security alerts and cybersecurity news feeds">
        <meta name="keywords" content="cybersecurity news, security alerts, vulnerability feeds, threat intelligence">
        <meta name="author" content="dotne1">
        <meta property="og:title" content="Security Feeds - dotne1's Cybersecurity Portfolio">
        <meta property="og:description" content="Stay updated with the latest cybersecurity news and alerts">
        <meta property="og:type" content="website">
        <title>Security Feeds - dotne1's Cybersecurity Portfolio</title>
        <link rel="stylesheet" href="styles.css">
        <link rel="icon" type="image/x-icon" href="/favicon.ico">
    </head>
    <body>
        <nav class="navbar">
            <div class="nav-links">
                <a href="index.html" class="nav-link">Home</a>
                <a href="about-me.html" class="nav-link">About Me</a>
                <a href="projects.html" class="nav-link">Projects</a>
                <a href="resume.html" class="nav-link">Resume</a>
                <a href="feeds.html" class="nav-link">Feeds</a>
            </div>
        </nav>

        <div class="container" role="main">
            <h1 class="main-header">Security Feeds</h1>
            <div class="search-bar">
                <input type="text" id="searchInput" placeholder="Search CVEs..." onkeyup="searchCVEs()">
            </div>
            <div class="feed-preview" id="cveFeed">
                <div class="feed-header">Latest Vulnerabilities</div>
    
                <div class="cve-entry" data-cve-id="CVE-2025-4470" data-description="a vulnerability classified as problematic was found in sourcecodester online student clearance system 1.0. affected by this vulnerability is an unknown functionality of the file /admin/add-student.php. the manipulation of the argument fullname leads to cross site scripting. the attack can be launched remotely. the exploit has been disclosed to the public and may be used. other parameters might be affected as well.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-4470" target="_blank">CVE-2025-4470</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-05-09 02:16:11 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">LOW</span></p>
                    <p><span class="feed-label">CVSS Score:</span> 2.4</p>
                    <p>A vulnerability classified as problematic was found in SourceCodester Online Student Clearance System 1.0. Affected by this vulnerability is an unknown functionality of the file /admin/add-student.php. The manipulation of the argument Fullname leads to cross site scripting. The attack can be launched remotely. The exploit has been disclosed to the public and may be used. Other parameters might be affected as well.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-4469" data-description="a vulnerability classified as problematic has been found in sourcecodester online student clearance system 1.0. affected is an unknown function of the file /admin/add-admin.php. the manipulation of the argument username leads to cross site scripting. it is possible to launch the attack remotely. the exploit has been disclosed to the public and may be used.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-4469" target="_blank">CVE-2025-4469</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-05-09 02:16:11 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">LOW</span></p>
                    <p><span class="feed-label">CVSS Score:</span> 2.4</p>
                    <p>A vulnerability classified as problematic has been found in SourceCodester Online Student Clearance System 1.0. Affected is an unknown function of the file /admin/add-admin.php. The manipulation of the argument Username leads to cross site scripting. It is possible to launch the attack remotely. The exploit has been disclosed to the public and may be used.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-4468" data-description="a vulnerability was found in sourcecodester online student clearance system 1.0. it has been rated as critical. this issue affects some unknown processing of the file /edit-photo.php. the manipulation of the argument userimage leads to unrestricted upload. the attack may be initiated remotely. the exploit has been disclosed to the public and may be used.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-4468" target="_blank">CVE-2025-4468</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-05-09 02:16:11 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-online">HIGH</span></p>
                    <p><span class="feed-label">CVSS Score:</span> 7.3</p>
                    <p>A vulnerability was found in SourceCodester Online Student Clearance System 1.0. It has been rated as critical. This issue affects some unknown processing of the file /edit-photo.php. The manipulation of the argument userImage leads to unrestricted upload. The attack may be initiated remotely. The exploit has been disclosed to the public and may be used.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-4467" data-description="a vulnerability was found in sourcecodester online student clearance system 1.0. it has been declared as critical. this vulnerability affects unknown code of the file /admin/edit-admin.php. the manipulation of the argument txtfullname/txtemail/cmddesignation leads to sql injection. the attack can be initiated remotely. the exploit has been disclosed to the public and may be used.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-4467" target="_blank">CVE-2025-4467</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-05-09 02:16:10 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-online">HIGH</span></p>
                    <p><span class="feed-label">CVSS Score:</span> 7.3</p>
                    <p>A vulnerability was found in SourceCodester Online Student Clearance System 1.0. It has been declared as critical. This vulnerability affects unknown code of the file /admin/edit-admin.php. The manipulation of the argument txtfullname/txtemail/cmddesignation leads to sql injection. The attack can be initiated remotely. The exploit has been disclosed to the public and may be used.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-3605" data-description="the frontend login and registration blocks plugin for wordpress is vulnerable to privilege escalation via account takeover in all versions up to, and including, 1.0.7. this is due to the plugin not properly validating a user's identity prior to updating their details like email via the flr_blocks_user_settings_handle_ajax_callback() function. this makes it possible for unauthenticated attackers to change arbitrary user's email addresses, including administrators, and leverage that to reset the user's password and gain access to their account.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-3605" target="_blank">CVE-2025-3605</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-05-09 02:16:10 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-online">CRITICAL</span></p>
                    <p><span class="feed-label">CVSS Score:</span> 9.8</p>
                    <p>The Frontend Login and Registration Blocks plugin for WordPress is vulnerable to privilege escalation via account takeover in all versions up to, and including, 1.0.7. This is due to the plugin not properly validating a user's identity prior to updating their details like email via the flr_blocks_user_settings_handle_ajax_callback() function. This makes it possible for unauthenticated attackers to change arbitrary user's email addresses, including administrators, and leverage that to reset the user's password and gain access to their account.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-3455" data-description="the 1 click wordpress migration plugin – 100% free for a limited time plugin for wordpress is vulnerable to unauthorized modification of data due to a missing capability check on the 'start_restore' function in all versions up to, and including, 2.2. this makes it possible for authenticated attackers, with subscriber-level access and above, to upload arbitrary files on the affected site's server which may make remote code execution possible.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-3455" target="_blank">CVE-2025-3455</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-05-09 02:16:10 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-online">HIGH</span></p>
                    <p><span class="feed-label">CVSS Score:</span> 8.8</p>
                    <p>The 1 Click WordPress Migration Plugin – 100% FREE for a limited time plugin for WordPress is vulnerable to unauthorized modification of data due to a missing capability check on the 'start_restore' function in all versions up to, and including, 2.2. This makes it possible for authenticated attackers, with Subscriber-level access and above, to upload arbitrary files on the affected site's server which may make remote code execution possible.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-37889" data-description="in the linux kernel, the following vulnerability has been resolved:

pci/msi: handle the nomask flag correctly for all pci/msi backends

the conversion of the xen specific global variable pci_msi_ignore_mask to a
msi domain flag, missed the facts that:

    1) legacy architectures do not provide a interrupt domain
    2) parent msi domains do not necessarily have a domain info attached
   
both cases result in an unconditional null pointer dereference. this was
unfortunatly missed in review and testing revealed it late.

cure this by using the existing pci_msi_domain_supports() helper, which
handles all possible cases correctly.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-37889" target="_blank">CVE-2025-37889</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-05-09 02:16:10 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">N/A</span></p>
                    <p><span class="feed-label">CVSS Score:</span> N/A</p>
                    <p>In the Linux kernel, the following vulnerability has been resolved:

PCI/MSI: Handle the NOMASK flag correctly for all PCI/MSI backends

The conversion of the XEN specific global variable pci_msi_ignore_mask to a
MSI domain flag, missed the facts that:

    1) Legacy architectures do not provide a interrupt domain
    2) Parent MSI domains do not necessarily have a domain info attached
   
Both cases result in an unconditional NULL pointer dereference. This was
unfortunatly missed in review and testing revealed it late.

Cure this by using the existing pci_msi_domain_supports() helper, which
handles all possible cases correctly.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-37888" data-description="in the linux kernel, the following vulnerability has been resolved:

net/mlx5: fix null-ptr-deref in mlx5_create_{inner_,}ttc_table()

add null check for mlx5_get_flow_namespace() returns in
mlx5_create_inner_ttc_table() and mlx5_create_ttc_table() to prevent
null pointer dereference.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-37888" target="_blank">CVE-2025-37888</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-05-09 02:16:10 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">N/A</span></p>
                    <p><span class="feed-label">CVSS Score:</span> N/A</p>
                    <p>In the Linux kernel, the following vulnerability has been resolved:

net/mlx5: Fix null-ptr-deref in mlx5_create_{inner_,}ttc_table()

Add NULL check for mlx5_get_flow_namespace() returns in
mlx5_create_inner_ttc_table() and mlx5_create_ttc_table() to prevent
NULL pointer dereference.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-37887" data-description="in the linux kernel, the following vulnerability has been resolved:

pds_core: handle unsupported pds_core_cmd_fw_control result

if the fw doesn't support the pds_core_cmd_fw_control command
the driver might at the least print garbage and at the worst
crash when the user runs the "devlink dev info" devlink command.

this happens because the stack variable fw_list is not 0
initialized which results in fw_list.num_fw_slots being a
garbage value from the stack.  then the driver tries to access
fw_list.fw_names[i] with i >= array_size and runs off the end
of the array.

fix this by initializing the fw_list and by not failing
completely if the devcmd fails because other useful information
is printed via devlink dev info even if the devcmd fails.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-37887" target="_blank">CVE-2025-37887</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-05-09 02:16:10 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">N/A</span></p>
                    <p><span class="feed-label">CVSS Score:</span> N/A</p>
                    <p>In the Linux kernel, the following vulnerability has been resolved:

pds_core: handle unsupported PDS_CORE_CMD_FW_CONTROL result

If the FW doesn't support the PDS_CORE_CMD_FW_CONTROL command
the driver might at the least print garbage and at the worst
crash when the user runs the "devlink dev info" devlink command.

This happens because the stack variable fw_list is not 0
initialized which results in fw_list.num_fw_slots being a
garbage value from the stack.  Then the driver tries to access
fw_list.fw_names[i] with i >= ARRAY_SIZE and runs off the end
of the array.

Fix this by initializing the fw_list and by not failing
completely if the devcmd fails because other useful information
is printed via devlink dev info even if the devcmd fails.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-37886" data-description="in the linux kernel, the following vulnerability has been resolved:

pds_core: make wait_context part of q_info

make the wait_context a full part of the q_info struct rather
than a stack variable that goes away after pdsc_adminq_post()
is done so that the context is still available after the wait
loop has given up.

there was a case where a slow development firmware caused
the adminq request to time out, but then later the fw finally
finished the request and sent the interrupt.  the handler tried
to complete_all() the completion context that had been created
on the stack in pdsc_adminq_post() but no longer existed.
this caused bad pointer usage, kernel crashes, and much wailing
and gnashing of teeth.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-37886" target="_blank">CVE-2025-37886</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-05-09 02:16:09 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">N/A</span></p>
                    <p><span class="feed-label">CVSS Score:</span> N/A</p>
                    <p>In the Linux kernel, the following vulnerability has been resolved:

pds_core: make wait_context part of q_info

Make the wait_context a full part of the q_info struct rather
than a stack variable that goes away after pdsc_adminq_post()
is done so that the context is still available after the wait
loop has given up.

There was a case where a slow development firmware caused
the adminq request to time out, but then later the FW finally
finished the request and sent the interrupt.  The handler tried
to complete_all() the completion context that had been created
on the stack in pdsc_adminq_post() but no longer existed.
This caused bad pointer usage, kernel crashes, and much wailing
and gnashing of teeth.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-37885" data-description="in the linux kernel, the following vulnerability has been resolved:

kvm: x86: reset irte to host control if *new* route isn't postable

restore an irte back to host control (remapped or posted msi mode) if the
*new* gsi route prevents posting the irq directly to a vcpu, regardless of
the gsi routing type.  updating the irte if and only if the new gsi is an
msi results in kvm leaving an irte posting to a vcpu.

the dangling irte can result in interrupts being incorrectly delivered to
the guest, and in the worst case scenario can result in use-after-free,
e.g. if the vm is torn down, but the underlying host irq isn't freed.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-37885" target="_blank">CVE-2025-37885</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-05-09 02:16:09 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">N/A</span></p>
                    <p><span class="feed-label">CVSS Score:</span> N/A</p>
                    <p>In the Linux kernel, the following vulnerability has been resolved:

KVM: x86: Reset IRTE to host control if *new* route isn't postable

Restore an IRTE back to host control (remapped or posted MSI mode) if the
*new* GSI route prevents posting the IRQ directly to a vCPU, regardless of
the GSI routing type.  Updating the IRTE if and only if the new GSI is an
MSI results in KVM leaving an IRTE posting to a vCPU.

The dangling IRTE can result in interrupts being incorrectly delivered to
the guest, and in the worst case scenario can result in use-after-free,
e.g. if the VM is torn down, but the underlying host IRQ isn't freed.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-37884" data-description="in the linux kernel, the following vulnerability has been resolved:

bpf: fix deadlock between rcu_tasks_trace and event_mutex.

fix the following deadlock:
cpu a
_free_event()
  perf_kprobe_destroy()
    mutex_lock(&event_mutex)
      perf_trace_event_unreg()
        synchronize_rcu_tasks_trace()

there are several paths where _free_event() grabs event_mutex
and calls sync_rcu_tasks_trace. above is one such case.

cpu b
bpf_prog_test_run_syscall()
  rcu_read_lock_trace()
    bpf_prog_run_pin_on_cpu()
      bpf_prog_load()
        bpf_tracing_func_proto()
          trace_set_clr_event()
            mutex_lock(&event_mutex)

delegate trace_set_clr_event() to workqueue to avoid
such lock dependency.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-37884" target="_blank">CVE-2025-37884</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-05-09 02:16:09 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">N/A</span></p>
                    <p><span class="feed-label">CVSS Score:</span> N/A</p>
                    <p>In the Linux kernel, the following vulnerability has been resolved:

bpf: Fix deadlock between rcu_tasks_trace and event_mutex.

Fix the following deadlock:
CPU A
_free_event()
  perf_kprobe_destroy()
    mutex_lock(&event_mutex)
      perf_trace_event_unreg()
        synchronize_rcu_tasks_trace()

There are several paths where _free_event() grabs event_mutex
and calls sync_rcu_tasks_trace. Above is one such case.

CPU B
bpf_prog_test_run_syscall()
  rcu_read_lock_trace()
    bpf_prog_run_pin_on_cpu()
      bpf_prog_load()
        bpf_tracing_func_proto()
          trace_set_clr_event()
            mutex_lock(&event_mutex)

Delegate trace_set_clr_event() to workqueue to avoid
such lock dependency.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-37883" data-description="in the linux kernel, the following vulnerability has been resolved:

s390/sclp: add check for get_zeroed_page()

add check for the return value of get_zeroed_page() in
sclp_console_init() to prevent null pointer dereference.
furthermore, to solve the memory leak caused by the loop
allocation, add a free helper to do the free job.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-37883" target="_blank">CVE-2025-37883</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-05-09 02:16:09 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">N/A</span></p>
                    <p><span class="feed-label">CVSS Score:</span> N/A</p>
                    <p>In the Linux kernel, the following vulnerability has been resolved:

s390/sclp: Add check for get_zeroed_page()

Add check for the return value of get_zeroed_page() in
sclp_console_init() to prevent null pointer dereference.
Furthermore, to solve the memory leak caused by the loop
allocation, add a free helper to do the free job.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-37882" data-description="in the linux kernel, the following vulnerability has been resolved:

usb: xhci: fix isochronous ring underrun/overrun event handling

the trb pointer of these events points at enqueue at the time of error
occurrence on xhci 1.1+ hcs or it's null on older ones. by the time we
are handling the event, a new td may be queued at this ring position.

i can trigger this race by rising interrupt moderation to increase irq
handling delay. similar delay may occur naturally due to system load.

if this ever happens after a missed service error, missed tds will be
skipped and the new td processed as if it matched the event. it could
be given back prematurely, risking data loss or buffer uaf by the xhc.

don't complete tds on xrun events and don't warn if queued tds don't
match the event's trb pointer, which can be null or a link/no-op trb.
don't warn if there are no queued tds at all.

now that it's safe, also handle xrun events if the skip flag is clear.
this ensures completion of any td stuck in 'error mid td' state right
before the xrun event, which could happen if a driver submits a finite
number of urbs to a buggy hc and then an error occurs on the last td.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-37882" target="_blank">CVE-2025-37882</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-05-09 02:16:09 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">N/A</span></p>
                    <p><span class="feed-label">CVSS Score:</span> N/A</p>
                    <p>In the Linux kernel, the following vulnerability has been resolved:

usb: xhci: Fix isochronous Ring Underrun/Overrun event handling

The TRB pointer of these events points at enqueue at the time of error
occurrence on xHCI 1.1+ HCs or it's NULL on older ones. By the time we
are handling the event, a new TD may be queued at this ring position.

I can trigger this race by rising interrupt moderation to increase IRQ
handling delay. Similar delay may occur naturally due to system load.

If this ever happens after a Missed Service Error, missed TDs will be
skipped and the new TD processed as if it matched the event. It could
be given back prematurely, risking data loss or buffer UAF by the xHC.

Don't complete TDs on xrun events and don't warn if queued TDs don't
match the event's TRB pointer, which can be NULL or a link/no-op TRB.
Don't warn if there are no queued TDs at all.

Now that it's safe, also handle xrun events if the skip flag is clear.
This ensures completion of any TD stuck in 'error mid TD' state right
before the xrun event, which could happen if a driver submits a finite
number of URBs to a buggy HC and then an error occurs on the last TD.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-37881" data-description="in the linux kernel, the following vulnerability has been resolved:

usb: gadget: aspeed: add null pointer check in ast_vhub_init_dev()

the variable d->name, returned by devm_kasprintf(), could be null.
a pointer check is added to prevent potential null pointer dereference.
this is similar to the fix in commit 3027e7b15b02
("ice: fix some null pointer dereference issues in ice_ptp.c").

this issue is found by our static analysis tool">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-37881" target="_blank">CVE-2025-37881</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-05-09 02:16:09 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">N/A</span></p>
                    <p><span class="feed-label">CVSS Score:</span> N/A</p>
                    <p>In the Linux kernel, the following vulnerability has been resolved:

usb: gadget: aspeed: Add NULL pointer check in ast_vhub_init_dev()

The variable d->name, returned by devm_kasprintf(), could be NULL.
A pointer check is added to prevent potential NULL pointer dereference.
This is similar to the fix in commit 3027e7b15b02
("ice: Fix some null pointer dereference issues in ice_ptp.c").

This issue is found by our static analysis tool</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-37880" data-description="in the linux kernel, the following vulnerability has been resolved:

um: work around sched_yield not yielding in time-travel mode

sched_yield by a userspace may not actually cause scheduling in
time-travel mode as no time has passed. in the case seen it appears to
be a badly implemented userspace spinlock in asan. unfortunately, with
time-travel it causes an extreme slowdown or even deadlock depending on
the kernel configuration (config_uml_max_userspace_iterations).

work around it by accounting time to the process whenever it executes a
sched_yield syscall.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-37880" target="_blank">CVE-2025-37880</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-05-09 02:16:09 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">N/A</span></p>
                    <p><span class="feed-label">CVSS Score:</span> N/A</p>
                    <p>In the Linux kernel, the following vulnerability has been resolved:

um: work around sched_yield not yielding in time-travel mode

sched_yield by a userspace may not actually cause scheduling in
time-travel mode as no time has passed. In the case seen it appears to
be a badly implemented userspace spinlock in ASAN. Unfortunately, with
time-travel it causes an extreme slowdown or even deadlock depending on
the kernel configuration (CONFIG_UML_MAX_USERSPACE_ITERATIONS).

Work around it by accounting time to the process whenever it executes a
sched_yield syscall.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-37879" data-description="in the linux kernel, the following vulnerability has been resolved:

9p/net: fix improper handling of bogus negative read/write replies

in p9_client_write() and p9_client_read_once(), if the server
incorrectly replies with success but a negative write/read count then we
would consider written (negative) <= rsize (positive) because both
variables were signed.

make variables unsigned to avoid this problem.

the reproducer linked below now fails with the following error instead
of a null pointer deref:
9pnet: bogus rwrite count (4294967295 > 3)">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-37879" target="_blank">CVE-2025-37879</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-05-09 02:16:09 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">N/A</span></p>
                    <p><span class="feed-label">CVSS Score:</span> N/A</p>
                    <p>In the Linux kernel, the following vulnerability has been resolved:

9p/net: fix improper handling of bogus negative read/write replies

In p9_client_write() and p9_client_read_once(), if the server
incorrectly replies with success but a negative write/read count then we
would consider written (negative) <= rsize (positive) because both
variables were signed.

Make variables unsigned to avoid this problem.

The reproducer linked below now fails with the following error instead
of a null pointer deref:
9pnet: bogus RWRITE count (4294967295 > 3)</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-37878" data-description="in the linux kernel, the following vulnerability has been resolved:

perf/core: fix warn_on(!ctx) in __free_event() for partial init

move the get_ctx(child_ctx) call and the child_event->ctx assignment to
occur immediately after the child event is allocated. ensure that
child_event->ctx is non-null before any subsequent error path within
inherit_event calls free_event(), satisfying the assumptions of the
cleanup code.

details:

there's no clear fixes tag, because this bug is a side-effect of
multiple interacting commits over time (up to 15 years old), not
a single regression.

the code initially incremented refcount then assigned context
immediately after the child_event was created. later, an early
validity check for child_event was added before the
refcount/assignment. even later, a warn_on_once() cleanup check was
added, assuming event->ctx is valid if the pmu_ctx is valid.
the problem is that the warn_on_once() could trigger after the initial
check passed but before child_event->ctx was assigned, violating its
precondition. the solution is to assign child_event->ctx right after
its initial validation. this ensures the context exists for any
subsequent checks or cleanup routines, resolving the warn_on_once().

to resolve it, defer the refcount update and child_event->ctx assignment
directly after child_event->pmu_ctx is set but before checking if the
parent event is orphaned. the cleanup routine depends on
event->pmu_ctx being non-null before it verifies event->ctx is
non-null. this also maintains the author's original intent of passing
in child_ctx to find_get_pmu_context before its refcount/assignment.

[ mingo: expanded the changelog from another email by gabriel shahrouzi. ]">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-37878" target="_blank">CVE-2025-37878</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-05-09 02:16:09 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">N/A</span></p>
                    <p><span class="feed-label">CVSS Score:</span> N/A</p>
                    <p>In the Linux kernel, the following vulnerability has been resolved:

perf/core: Fix WARN_ON(!ctx) in __free_event() for partial init

Move the get_ctx(child_ctx) call and the child_event->ctx assignment to
occur immediately after the child event is allocated. Ensure that
child_event->ctx is non-NULL before any subsequent error path within
inherit_event calls free_event(), satisfying the assumptions of the
cleanup code.

Details:

There's no clear Fixes tag, because this bug is a side-effect of
multiple interacting commits over time (up to 15 years old), not
a single regression.

The code initially incremented refcount then assigned context
immediately after the child_event was created. Later, an early
validity check for child_event was added before the
refcount/assignment. Even later, a WARN_ON_ONCE() cleanup check was
added, assuming event->ctx is valid if the pmu_ctx is valid.
The problem is that the WARN_ON_ONCE() could trigger after the initial
check passed but before child_event->ctx was assigned, violating its
precondition. The solution is to assign child_event->ctx right after
its initial validation. This ensures the context exists for any
subsequent checks or cleanup routines, resolving the WARN_ON_ONCE().

To resolve it, defer the refcount update and child_event->ctx assignment
directly after child_event->pmu_ctx is set but before checking if the
parent event is orphaned. The cleanup routine depends on
event->pmu_ctx being non-NULL before it verifies event->ctx is
non-NULL. This also maintains the author's original intent of passing
in child_ctx to find_get_pmu_context before its refcount/assignment.

[ mingo: Expanded the changelog from another email by Gabriel Shahrouzi. ]</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-37877" data-description="in the linux kernel, the following vulnerability has been resolved:

iommu: clear iommu-dma ops on cleanup

if iommu_device_register() encounters an error, it can end up tearing
down already-configured groups and default domains, however this
currently still leaves devices hooked up to iommu-dma (and even
historically the behaviour in this area was at best inconsistent across
architectures/drivers...) although in the case that an iommu is present
whose driver has failed to probe, users cannot necessarily expect dma to
work anyway, it's still arguable that we should do our best to put
things back as if the iommu driver was never there at all, and certainly
the potential for crashing in iommu-dma itself is undesirable. make sure
we clean up the dev->dma_iommu flag along with everything else.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-37877" target="_blank">CVE-2025-37877</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-05-09 02:16:08 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">N/A</span></p>
                    <p><span class="feed-label">CVSS Score:</span> N/A</p>
                    <p>In the Linux kernel, the following vulnerability has been resolved:

iommu: Clear iommu-dma ops on cleanup

If iommu_device_register() encounters an error, it can end up tearing
down already-configured groups and default domains, however this
currently still leaves devices hooked up to iommu-dma (and even
historically the behaviour in this area was at best inconsistent across
architectures/drivers...) Although in the case that an IOMMU is present
whose driver has failed to probe, users cannot necessarily expect DMA to
work anyway, it's still arguable that we should do our best to put
things back as if the IOMMU driver was never there at all, and certainly
the potential for crashing in iommu-dma itself is undesirable. Make sure
we clean up the dev->dma_iommu flag along with everything else.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-37876" data-description="in the linux kernel, the following vulnerability has been resolved:

netfs: only create /proc/fs/netfs with config_proc_fs

when testing a special config:

config_netfs_supports=y
config_proc_fs=n

the system crashes with something like:

[    3.766197] ------------[ cut here ]------------
[    3.766484] kernel bug at mm/mempool.c:560!
[    3.766789] oops: invalid opcode: 0000 [#1] smp nopti
[    3.767123] cpu: 0 uid: 0 pid: 1 comm: swapper/0 tainted: g        w
[    3.767777] tainted: [w]=warn
[    3.767968] hardware name: qemu standard pc (i440fx + piix, 1996),
[    3.768523] rip: 0010:mempool_alloc_slab.cold+0x17/0x19
[    3.768847] code: 50 fe ff 58 5b 5d 41 5c 41 5d 41 5e 41 5f e9 93 95 13 00
[    3.769977] rsp: 0018:ffffc90000013998 eflags: 00010286
[    3.770315] rax: 000000000000002f rbx: ffff888100ba8640 rcx: 0000000000000000
[    3.770749] rdx: 0000000000000000 rsi: 0000000000000003 rdi: 00000000ffffffff
[    3.771217] rbp: 0000000000092880 r08: 0000000000000000 r09: ffffc90000013828
[    3.771664] r10: 0000000000000001 r11: 00000000ffffffea r12: 0000000000092cc0
[    3.772117] r13: 0000000000000400 r14: ffff8881004b1620 r15: ffffea0004ef7e40
[    3.772554] fs:  0000000000000000(0000) gs:ffff8881b5f3c000(0000) knlgs:0000000000000000
[    3.773061] cs:  0010 ds: 0000 es: 0000 cr0: 0000000080050033
[    3.773443] cr2: ffffffff830901b4 cr3: 0000000004296001 cr4: 0000000000770ef0
[    3.773884] pkru: 55555554
[    3.774058] call trace:
[    3.774232]  <task>
[    3.774371]  mempool_alloc_noprof+0x6a/0x190
[    3.774649]  ? _printk+0x57/0x80
[    3.774862]  netfs_alloc_request+0x85/0x2ce
[    3.775147]  netfs_readahead+0x28/0x170
[    3.775395]  read_pages+0x6c/0x350
[    3.775623]  ? srso_alias_return_thunk+0x5/0xfbef5
[    3.775928]  page_cache_ra_unbounded+0x1bd/0x2a0
[    3.776247]  filemap_get_pages+0x139/0x970
[    3.776510]  ? srso_alias_return_thunk+0x5/0xfbef5
[    3.776820]  filemap_read+0xf9/0x580
[    3.777054]  ? srso_alias_return_thunk+0x5/0xfbef5
[    3.777368]  ? srso_alias_return_thunk+0x5/0xfbef5
[    3.777674]  ? find_held_lock+0x32/0x90
[    3.777929]  ? netfs_start_io_read+0x19/0x70
[    3.778221]  ? netfs_start_io_read+0x19/0x70
[    3.778489]  ? srso_alias_return_thunk+0x5/0xfbef5
[    3.778800]  ? lock_acquired+0x1e6/0x450
[    3.779054]  ? srso_alias_return_thunk+0x5/0xfbef5
[    3.779379]  netfs_buffered_read_iter+0x57/0x80
[    3.779670]  __kernel_read+0x158/0x2c0
[    3.779927]  bprm_execve+0x300/0x7a0
[    3.780185]  kernel_execve+0x10c/0x140
[    3.780423]  ? __pfx_kernel_init+0x10/0x10
[    3.780690]  kernel_init+0xd5/0x150
[    3.780910]  ret_from_fork+0x2d/0x50
[    3.781156]  ? __pfx_kernel_init+0x10/0x10
[    3.781414]  ret_from_fork_asm+0x1a/0x30
[    3.781677]  </task>
[    3.781823] modules linked in:
[    3.782065] ---[ end trace 0000000000000000 ]---

this is caused by the following error path in netfs_init():

        if (!proc_mkdir("fs/netfs", null))
                goto error_proc;

fix this by adding ifdef in netfs_main(), so that /proc/fs/netfs is only
created with config_proc_fs.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-37876" target="_blank">CVE-2025-37876</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-05-09 02:16:08 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">N/A</span></p>
                    <p><span class="feed-label">CVSS Score:</span> N/A</p>
                    <p>In the Linux kernel, the following vulnerability has been resolved:

netfs: Only create /proc/fs/netfs with CONFIG_PROC_FS

When testing a special config:

CONFIG_NETFS_SUPPORTS=y
CONFIG_PROC_FS=n

The system crashes with something like:

[    3.766197] ------------[ cut here ]------------
[    3.766484] kernel BUG at mm/mempool.c:560!
[    3.766789] Oops: invalid opcode: 0000 [#1] SMP NOPTI
[    3.767123] CPU: 0 UID: 0 PID: 1 Comm: swapper/0 Tainted: G        W
[    3.767777] Tainted: [W]=WARN
[    3.767968] Hardware name: QEMU Standard PC (i440FX + PIIX, 1996),
[    3.768523] RIP: 0010:mempool_alloc_slab.cold+0x17/0x19
[    3.768847] Code: 50 fe ff 58 5b 5d 41 5c 41 5d 41 5e 41 5f e9 93 95 13 00
[    3.769977] RSP: 0018:ffffc90000013998 EFLAGS: 00010286
[    3.770315] RAX: 000000000000002f RBX: ffff888100ba8640 RCX: 0000000000000000
[    3.770749] RDX: 0000000000000000 RSI: 0000000000000003 RDI: 00000000ffffffff
[    3.771217] RBP: 0000000000092880 R08: 0000000000000000 R09: ffffc90000013828
[    3.771664] R10: 0000000000000001 R11: 00000000ffffffea R12: 0000000000092cc0
[    3.772117] R13: 0000000000000400 R14: ffff8881004b1620 R15: ffffea0004ef7e40
[    3.772554] FS:  0000000000000000(0000) GS:ffff8881b5f3c000(0000) knlGS:0000000000000000
[    3.773061] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
[    3.773443] CR2: ffffffff830901b4 CR3: 0000000004296001 CR4: 0000000000770ef0
[    3.773884] PKRU: 55555554
[    3.774058] Call Trace:
[    3.774232]  <TASK>
[    3.774371]  mempool_alloc_noprof+0x6a/0x190
[    3.774649]  ? _printk+0x57/0x80
[    3.774862]  netfs_alloc_request+0x85/0x2ce
[    3.775147]  netfs_readahead+0x28/0x170
[    3.775395]  read_pages+0x6c/0x350
[    3.775623]  ? srso_alias_return_thunk+0x5/0xfbef5
[    3.775928]  page_cache_ra_unbounded+0x1bd/0x2a0
[    3.776247]  filemap_get_pages+0x139/0x970
[    3.776510]  ? srso_alias_return_thunk+0x5/0xfbef5
[    3.776820]  filemap_read+0xf9/0x580
[    3.777054]  ? srso_alias_return_thunk+0x5/0xfbef5
[    3.777368]  ? srso_alias_return_thunk+0x5/0xfbef5
[    3.777674]  ? find_held_lock+0x32/0x90
[    3.777929]  ? netfs_start_io_read+0x19/0x70
[    3.778221]  ? netfs_start_io_read+0x19/0x70
[    3.778489]  ? srso_alias_return_thunk+0x5/0xfbef5
[    3.778800]  ? lock_acquired+0x1e6/0x450
[    3.779054]  ? srso_alias_return_thunk+0x5/0xfbef5
[    3.779379]  netfs_buffered_read_iter+0x57/0x80
[    3.779670]  __kernel_read+0x158/0x2c0
[    3.779927]  bprm_execve+0x300/0x7a0
[    3.780185]  kernel_execve+0x10c/0x140
[    3.780423]  ? __pfx_kernel_init+0x10/0x10
[    3.780690]  kernel_init+0xd5/0x150
[    3.780910]  ret_from_fork+0x2d/0x50
[    3.781156]  ? __pfx_kernel_init+0x10/0x10
[    3.781414]  ret_from_fork_asm+0x1a/0x30
[    3.781677]  </TASK>
[    3.781823] Modules linked in:
[    3.782065] ---[ end trace 0000000000000000 ]---

This is caused by the following error path in netfs_init():

        if (!proc_mkdir("fs/netfs", NULL))
                goto error_proc;

Fix this by adding ifdef in netfs_main(), so that /proc/fs/netfs is only
created with CONFIG_PROC_FS.</p>
                </div>
        
            </div>
        </div>

        <footer class="footer">
            <p>© 2025 dotne1 - Cybersecurity Portfolio</p>
        </footer>

        <script>
            function searchCVEs() {
                const input = document.getElementById('searchInput').value.toLowerCase();
                const cveEntries = document.getElementsByClassName('cve-entry');
                for (let i = 0; i < cveEntries.length; i++) {
                    const cveId = cveEntries[i].getAttribute('data-cve-id').toLowerCase();
                    const description = cveEntries[i].getAttribute('data-description');
                    if (cveId.includes(input) || description.includes(input)) {
                        cveEntries[i].style.display = '';
                    } else {
                        cveEntries[i].style.display = 'none';
                    }
                }
            }
        </script>
    </body>
    </html>
    