
    <!DOCTYPE html>
    <html lang="en">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <meta name="description" content="Security alerts and cybersecurity news feeds">
        <meta name="keywords" content="cybersecurity news, security alerts, vulnerability feeds, threat intelligence">
        <meta name="author" content="dotne1">
        <meta property="og:title" content="Security Feeds - dotne1's Cybersecurity Portfolio">
        <meta property="og:description" content="Stay updated with the latest cybersecurity news and alerts">
        <meta property="og:type" content="website">
        <title>Security Feeds - dotne1's Cybersecurity Portfolio</title>
        <link rel="stylesheet" href="styles.css">
        <link rel="icon" type="image/x-icon" href="/favicon.ico">
    </head>
    <body>
        <nav class="navbar">
            <div class="nav-links">
                <a href="index.html" class="nav-link">Home</a>
                <a href="about-me.html" class="nav-link">About Me</a>
                <a href="projects.html" class="nav-link">Projects</a>
                <a href="resume.html" class="nav-link">Resume</a>
                <a href="feeds.html" class="nav-link">Feeds</a>
            </div>
        </nav>

        <div class="container" role="main">
            <h1 class="main-header">Security Feeds</h1>
            <div class="search-bar">
                <input type="text" id="searchInput" placeholder="Search CVEs..." onkeyup="searchCVEs()">
            </div>
            <div class="feed-preview" id="cveFeed">
                <div class="feed-header">Latest Vulnerabilities</div>
    
                <div class="cve-entry" data-cve-id="CVE-2025-29069" data-description="a heap buffer overflow vulnerability has been identified in the lcms2-2.16. the vulnerability exists in the unrollchunkybytes function in cmspack.c, which is responsible for handling color space transformations.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-29069" target="_blank">CVE-2025-29069</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-04-01 15:15:17 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">N/A</span></p>
                    <p><span class="feed-label">CVSS Score:</span> N/A</p>
                    <p>A heap buffer overflow vulnerability has been identified in the lcms2-2.16. The vulnerability exists in the UnrollChunkyBytes function in cmspack.c, which is responsible for handling color space transformations.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-3096" data-description="clinic’s patient management system versions 2.0 suffers from a sql injection vulnerability in the login page.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-3096" target="_blank">CVE-2025-3096</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-04-01 14:15:47 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">N/A</span></p>
                    <p><span class="feed-label">CVSS Score:</span> N/A</p>
                    <p>Clinic’s Patient Management System versions 2.0 suffers from a SQL injection vulnerability in the login page.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-31137" data-description="react router is a multi-strategy router for react bridging the gap from react 18 to react 19. there is a vulnerability in remix/react router that affects all remix 2 and react router 7 consumers using the express adapter. basically, this vulnerability allows anyone to spoof the url used in an incoming request by putting a url pathname in the port section of a url that is part of a host or x-forwarded-host header sent to a remix/react router request handler. this issue has been patched and released in remix 2.16.3 and react router 7.4.1.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-31137" target="_blank">CVE-2025-31137</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-04-01 14:15:45 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-online">HIGH</span></p>
                    <p><span class="feed-label">CVSS Score:</span> 7.5</p>
                    <p>React Router is a multi-strategy router for React bridging the gap from React 18 to React 19. There is a vulnerability in Remix/React Router that affects all Remix 2 and React Router 7 consumers using the Express adapter. Basically, this vulnerability allows anyone to spoof the URL used in an incoming Request by putting a URL pathname in the port section of a URL that is part of a Host or X-Forwarded-Host header sent to a Remix/React Router request handler. This issue has been patched and released in Remix 2.16.3 and React Router 7.4.1.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-26056" data-description="a command injection vulnerability exists in the infinxt iedge 100 2.1.32 in the troubleshoot module "mtr" functionality. the vulnerability is due to improper validation of user-supplied input in the mtrip parameter. an attacker can exploit this flaw to execute arbitrary operating system commands on the underlying system with the same privileges as the web application process.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-26056" target="_blank">CVE-2025-26056</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-04-01 14:15:44 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">N/A</span></p>
                    <p><span class="feed-label">CVSS Score:</span> N/A</p>
                    <p>A command injection vulnerability exists in the Infinxt iEdge 100 2.1.32 in the Troubleshoot module "MTR" functionality. The vulnerability is due to improper validation of user-supplied input in the mtrIp parameter. An attacker can exploit this flaw to execute arbitrary operating system commands on the underlying system with the same privileges as the web application process.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-26055" data-description="an os command injection vulnerability exists in the infinxt iedge 100 2.1.32 troubleshoot module, specifically in the tracertval parameter of the tracert function.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-26055" target="_blank">CVE-2025-26055</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-04-01 14:15:44 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">N/A</span></p>
                    <p><span class="feed-label">CVSS Score:</span> N/A</p>
                    <p>An OS Command Injection vulnerability exists in the Infinxt iEdge 100 2.1.32 Troubleshoot module, specifically in the tracertVal parameter of the Tracert function.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-26054" data-description="infinxt iedge 100 2.1.32 is vulnerable to cross site scripting (xss) via the "description" field during lan configuration.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-26054" target="_blank">CVE-2025-26054</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-04-01 14:15:44 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">N/A</span></p>
                    <p><span class="feed-label">CVSS Score:</span> N/A</p>
                    <p>Infinxt iEdge 100 2.1.32 is vulnerable to Cross Site Scripting (XSS) via the "Description" field during LAN configuration.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-29208" data-description="codezips gym management system v1.0 is vulnerable to sql injection in the name parameter within /dashboard/admin/deleteroutine.php.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-29208" target="_blank">CVE-2025-29208</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-04-01 13:15:29 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">N/A</span></p>
                    <p><span class="feed-label">CVSS Score:</span> N/A</p>
                    <p>CodeZips Gym Management System v1.0 is vulnerable to SQL injection in the name parameter within /dashboard/admin/deleteroutine.php.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2018-1472" data-description="rejected reason: this cve id has been rejected or withdrawn by its cve numbering authority because it was erroneously associated with an open source vulnerability by another vendor.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2018-1472" target="_blank">CVE-2018-1472</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-04-01 13:15:28 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">N/A</span></p>
                    <p><span class="feed-label">CVSS Score:</span> N/A</p>
                    <p>Rejected reason: This CVE ID has been rejected or withdrawn by its CVE Numbering Authority because it was erroneously associated with an open source vulnerability by another vendor.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-28132" data-description="a session management flaw in nagios network analyzer 2024r1.0.3 allows an attacker to reuse session tokens even after a user logs out, leading to unauthorized access and account takeover. this occurs due to insufficient session expiration, where session tokens remain valid beyond logout, allowing an attacker to impersonate users and perform actions on their behalf.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-28132" target="_blank">CVE-2025-28132</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-04-01 12:15:46 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">MEDIUM</span></p>
                    <p><span class="feed-label">CVSS Score:</span> 4.6</p>
                    <p>A session management flaw in Nagios Network Analyzer 2024R1.0.3 allows an attacker to reuse session tokens even after a user logs out, leading to unauthorized access and account takeover. This occurs due to insufficient session expiration, where session tokens remain valid beyond logout, allowing an attacker to impersonate users and perform actions on their behalf.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-28131" data-description="a broken access control vulnerability in nagios network analyzer 2024r1.0.3 allows low-privilege users with "read-only" access to perform administrative actions, including stopping system services and deleting critical resources. this flaw arises due to improper authorization enforcement, enabling unauthorized modifications that compromise system integrity and availability.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-28131" target="_blank">CVE-2025-28131</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-04-01 12:15:46 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">MEDIUM</span></p>
                    <p><span class="feed-label">CVSS Score:</span> 4.6</p>
                    <p>A Broken Access Control vulnerability in Nagios Network Analyzer 2024R1.0.3 allows low-privilege users with "Read-Only" access to perform administrative actions, including stopping system services and deleting critical resources. This flaw arises due to improper authorization enforcement, enabling unauthorized modifications that compromise system integrity and availability.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-27829" data-description="an issue was discovered in stormshield network security (sns) 4.3.x before 4.3.35. if multicast streams are enabled on different interfaces, it may be possible to interrupt multicast traffic on some of these interfaces. that could result in a denial of the multicast routing service on the firewall.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-27829" target="_blank">CVE-2025-27829</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-04-01 12:15:46 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">N/A</span></p>
                    <p><span class="feed-label">CVSS Score:</span> N/A</p>
                    <p>An issue was discovered in Stormshield Network Security (SNS) 4.3.x before 4.3.35. If multicast streams are enabled on different interfaces, it may be possible to interrupt multicast traffic on some of these interfaces. That could result in a denial of the multicast routing service on the firewall.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-25041" data-description="a vulnerability in the hpe aruba networking virtual intranet access (via) client could allow malicious users to overwrite arbitrary files as nt authority\system (root). a successful exploit could allow the creation of a denial-of-service (dos) condition affecting the microsoft windows operating system. this vulnerability does not affect linux and android based clients.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-25041" target="_blank">CVE-2025-25041</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-04-01 12:15:44 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">MEDIUM</span></p>
                    <p><span class="feed-label">CVSS Score:</span> 5.5</p>
                    <p>A vulnerability in the HPE Aruba Networking Virtual Intranet Access (VIA) client could allow malicious users to overwrite arbitrary files as NT AUTHORITY\SYSTEM (root). A successful exploit could allow the creation of a Denial-of-Service (DoS) condition affecting the Microsoft Windows Operating System. This vulnerability does not affect Linux and Android based clients.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-21986" data-description="in the linux kernel, the following vulnerability has been resolved:

net: switchdev: convert blocking notification chain to a raw one

a blocking notification chain uses a read-write semaphore to protect the
integrity of the chain. the semaphore is acquired for writing when
adding / removing notifiers to / from the chain and acquired for reading
when traversing the chain and informing notifiers about an event.

in case of the blocking switchdev notification chain, recursive
notifications are possible which leads to the semaphore being acquired
twice for reading and to lockdep warnings being generated [1].

specifically, this can happen when the bridge driver processes a
switchdev_brport_unoffloaded event which causes it to emit notifications
about deferred events when calling switchdev_deferred_process().

fix this by converting the notification chain to a raw notification
chain in a similar fashion to the netdev notification chain. protect
the chain using the rtnl mutex by acquiring it when modifying the chain.
events are always informed under the rtnl mutex, but add an assertion in
call_switchdev_blocking_notifiers() to make sure this is not violated in
the future.

maintain the "blocking" prefix as events are always emitted from process
context and listeners are allowed to block.

[1]:
warning: possible recursive locking detected
6.14.0-rc4-custom-g079270089484 #1 not tainted
--------------------------------------------
ip/52731 is trying to acquire lock:
ffffffff850918d8 ((switchdev_blocking_notif_chain).rwsem){++++}-{4:4}, at: blocking_notifier_call_chain+0x58/0xa0

but task is already holding lock:
ffffffff850918d8 ((switchdev_blocking_notif_chain).rwsem){++++}-{4:4}, at: blocking_notifier_call_chain+0x58/0xa0

other info that might help us debug this:
possible unsafe locking scenario:
cpu0
----
lock((switchdev_blocking_notif_chain).rwsem);
lock((switchdev_blocking_notif_chain).rwsem);

*** deadlock ***
may be due to missing lock nesting notation
3 locks held by ip/52731:
 #0: ffffffff84f795b0 (rtnl_mutex){+.+.}-{4:4}, at: rtnl_newlink+0x727/0x1dc0
 #1: ffffffff8731f628 (&net->rtnl_mutex){+.+.}-{4:4}, at: rtnl_newlink+0x790/0x1dc0
 #2: ffffffff850918d8 ((switchdev_blocking_notif_chain).rwsem){++++}-{4:4}, at: blocking_notifier_call_chain+0x58/0xa0

stack backtrace:
...
? __pfx_down_read+0x10/0x10
? __pfx_mark_lock+0x10/0x10
? __pfx_switchdev_port_attr_set_deferred+0x10/0x10
blocking_notifier_call_chain+0x58/0xa0
switchdev_port_attr_notify.constprop.0+0xb3/0x1b0
? __pfx_switchdev_port_attr_notify.constprop.0+0x10/0x10
? mark_held_locks+0x94/0xe0
? switchdev_deferred_process+0x11a/0x340
switchdev_port_attr_set_deferred+0x27/0xd0
switchdev_deferred_process+0x164/0x340
br_switchdev_port_unoffload+0xc8/0x100 [bridge]
br_switchdev_blocking_event+0x29f/0x580 [bridge]
notifier_call_chain+0xa2/0x440
blocking_notifier_call_chain+0x6e/0xa0
switchdev_bridge_port_unoffload+0xde/0x1a0
...">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-21986" target="_blank">CVE-2025-21986</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-04-01 11:15:30 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">N/A</span></p>
                    <p><span class="feed-label">CVSS Score:</span> N/A</p>
                    <p>In the Linux kernel, the following vulnerability has been resolved:

net: switchdev: Convert blocking notification chain to a raw one

A blocking notification chain uses a read-write semaphore to protect the
integrity of the chain. The semaphore is acquired for writing when
adding / removing notifiers to / from the chain and acquired for reading
when traversing the chain and informing notifiers about an event.

In case of the blocking switchdev notification chain, recursive
notifications are possible which leads to the semaphore being acquired
twice for reading and to lockdep warnings being generated [1].

Specifically, this can happen when the bridge driver processes a
SWITCHDEV_BRPORT_UNOFFLOADED event which causes it to emit notifications
about deferred events when calling switchdev_deferred_process().

Fix this by converting the notification chain to a raw notification
chain in a similar fashion to the netdev notification chain. Protect
the chain using the RTNL mutex by acquiring it when modifying the chain.
Events are always informed under the RTNL mutex, but add an assertion in
call_switchdev_blocking_notifiers() to make sure this is not violated in
the future.

Maintain the "blocking" prefix as events are always emitted from process
context and listeners are allowed to block.

[1]:
WARNING: possible recursive locking detected
6.14.0-rc4-custom-g079270089484 #1 Not tainted
--------------------------------------------
ip/52731 is trying to acquire lock:
ffffffff850918d8 ((switchdev_blocking_notif_chain).rwsem){++++}-{4:4}, at: blocking_notifier_call_chain+0x58/0xa0

but task is already holding lock:
ffffffff850918d8 ((switchdev_blocking_notif_chain).rwsem){++++}-{4:4}, at: blocking_notifier_call_chain+0x58/0xa0

other info that might help us debug this:
Possible unsafe locking scenario:
CPU0
----
lock((switchdev_blocking_notif_chain).rwsem);
lock((switchdev_blocking_notif_chain).rwsem);

*** DEADLOCK ***
May be due to missing lock nesting notation
3 locks held by ip/52731:
 #0: ffffffff84f795b0 (rtnl_mutex){+.+.}-{4:4}, at: rtnl_newlink+0x727/0x1dc0
 #1: ffffffff8731f628 (&net->rtnl_mutex){+.+.}-{4:4}, at: rtnl_newlink+0x790/0x1dc0
 #2: ffffffff850918d8 ((switchdev_blocking_notif_chain).rwsem){++++}-{4:4}, at: blocking_notifier_call_chain+0x58/0xa0

stack backtrace:
...
? __pfx_down_read+0x10/0x10
? __pfx_mark_lock+0x10/0x10
? __pfx_switchdev_port_attr_set_deferred+0x10/0x10
blocking_notifier_call_chain+0x58/0xa0
switchdev_port_attr_notify.constprop.0+0xb3/0x1b0
? __pfx_switchdev_port_attr_notify.constprop.0+0x10/0x10
? mark_held_locks+0x94/0xe0
? switchdev_deferred_process+0x11a/0x340
switchdev_port_attr_set_deferred+0x27/0xd0
switchdev_deferred_process+0x164/0x340
br_switchdev_port_unoffload+0xc8/0x100 [bridge]
br_switchdev_blocking_event+0x29f/0x580 [bridge]
notifier_call_chain+0xa2/0x440
blocking_notifier_call_chain+0x6e/0xa0
switchdev_bridge_port_unoffload+0xde/0x1a0
...</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-21985" data-description="in the linux kernel, the following vulnerability has been resolved:

drm/amd/display: fix out-of-bound accesses

[what & how]
hpo_stream_to_link_encoder_mapping has size max_hpo_dp2_encoders(=4),
but location can have size up to 6. as a result, it is necessary to
check location against max_hpo_dp2_encoders.

similiarly, disp_cfg_stream_location can be used as an array index which
should be 0..5, so the assert's conditions should be less without equal.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-21985" target="_blank">CVE-2025-21985</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-04-01 11:15:29 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">N/A</span></p>
                    <p><span class="feed-label">CVSS Score:</span> N/A</p>
                    <p>In the Linux kernel, the following vulnerability has been resolved:

drm/amd/display: Fix out-of-bound accesses

[WHAT & HOW]
hpo_stream_to_link_encoder_mapping has size MAX_HPO_DP2_ENCODERS(=4),
but location can have size up to 6. As a result, it is necessary to
check location against MAX_HPO_DP2_ENCODERS.

Similiarly, disp_cfg_stream_location can be used as an array index which
should be 0..5, so the ASSERT's conditions should be less without equal.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-21984" data-description="in the linux kernel, the following vulnerability has been resolved:

mm: fix kernel bug when userfaultfd_move encounters swapcache

userfaultfd_move() checks whether the pte entry is present or a
swap entry.

- if the pte entry is present, move_present_pte() handles folio
  migration by setting:

  src_folio->index = linear_page_index(dst_vma, dst_addr);

- if the pte entry is a swap entry, move_swap_pte() simply copies
  the pte to the new dst_addr.

this approach is incorrect because, even if the pte is a swap entry,
it can still reference a folio that remains in the swap cache.

this creates a race window between steps 2 and 4.
 1. add_to_swap: the folio is added to the swapcache.
 2. try_to_unmap: ptes are converted to swap entries.
 3. pageout: the folio is written back.
 4. swapcache is cleared.
if userfaultfd_move() occurs in the window between steps 2 and 4,
after the swap pte has been moved to the destination, accessing the
destination triggers do_swap_page(), which may locate the folio in
the swapcache. however, since the folio's index has not been updated
to match the destination vma, do_swap_page() will detect a mismatch.

this can result in two critical issues depending on the system
configuration.

if ksm is disabled, both small and large folios can trigger a bug
during the add_rmap operation due to:

 page_pgoff(folio, page) != linear_page_index(vma, address)

[   13.336953] page: refcount:6 mapcount:1 mapping:00000000f43db19c index:0xffffaf150 pfn:0x4667c
[   13.337520] head: order:2 mapcount:1 entire_mapcount:0 nr_pages_mapped:1 pincount:0
[   13.337716] memcg:ffff00000405f000
[   13.337849] anon flags: 0x3fffc0000020459(locked|uptodate|dirty|owner_priv_1|head|swapbacked|node=0|zone=0|lastcpupid=0xffff)
[   13.338630] raw: 03fffc0000020459 ffff80008507b538 ffff80008507b538 ffff000006260361
[   13.338831] raw: 0000000ffffaf150 0000000000004000 0000000600000000 ffff00000405f000
[   13.339031] head: 03fffc0000020459 ffff80008507b538 ffff80008507b538 ffff000006260361
[   13.339204] head: 0000000ffffaf150 0000000000004000 0000000600000000 ffff00000405f000
[   13.339375] head: 03fffc0000000202 fffffdffc0199f01 ffffffff00000000 0000000000000001
[   13.339546] head: 0000000000000004 0000000000000000 00000000ffffffff 0000000000000000
[   13.339736] page dumped because: vm_bug_on_page(page_pgoff(folio, page) != linear_page_index(vma, address))
[   13.340190] ------------[ cut here ]------------
[   13.340316] kernel bug at mm/rmap.c:1380!
[   13.340683] internal error: oops - bug: 00000000f2000800 [#1] preempt smp
[   13.340969] modules linked in:
[   13.341257] cpu: 1 uid: 0 pid: 107 comm: a.out not tainted 6.14.0-rc3-gcf42737e247a-dirty #299
[   13.341470] hardware name: linux,dummy-virt (dt)
[   13.341671] pstate: 60000005 (nzcv daif -pan -uao -tco -dit -ssbs btype=--)
[   13.341815] pc : __page_check_anon_rmap+0xa0/0xb0
[   13.341920] lr : __page_check_anon_rmap+0xa0/0xb0
[   13.342018] sp : ffff80008752bb20
[   13.342093] x29: ffff80008752bb20 x28: fffffdffc0199f00 x27: 0000000000000001
[   13.342404] x26: 0000000000000000 x25: 0000000000000001 x24: 0000000000000001
[   13.342575] x23: 0000ffffaf0d0000 x22: 0000ffffaf0d0000 x21: fffffdffc0199f00
[   13.342731] x20: fffffdffc0199f00 x19: ffff000006210700 x18: 00000000ffffffff
[   13.342881] x17: 6c203d2120296567 x16: 6170202c6f696c6f x15: 662866666f67705f
[   13.343033] x14: 6567617028454741 x13: 2929737365726464 x12: ffff800083728ab0
[   13.343183] x11: ffff800082996bf8 x10: 0000000000000fd7 x9 : ffff80008011bc40
[   13.343351] x8 : 0000000000017fe8 x7 : 00000000fffff000 x6 : ffff8000829eebf8
[   13.343498] x5 : c0000000fffff000 x4 : 0000000000000000 x3 : 0000000000000000
[   13.343645] x2 : 0000000000000000 x1 : ffff0000062db980 x0 : 000000000000005f
[   13.343876] call trace:
[   13.344045]  __page_check_anon_rmap+0xa0/0xb0 (p)
[   13.344234]  folio_add_anon_rmap_ptes+0x22c/0x320
[   13.344333]  do_swap_page+0x1060/0x1400
[   13.344417]  __handl
---truncated---">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-21984" target="_blank">CVE-2025-21984</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-04-01 11:15:29 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">N/A</span></p>
                    <p><span class="feed-label">CVSS Score:</span> N/A</p>
                    <p>In the Linux kernel, the following vulnerability has been resolved:

mm: fix kernel BUG when userfaultfd_move encounters swapcache

userfaultfd_move() checks whether the PTE entry is present or a
swap entry.

- If the PTE entry is present, move_present_pte() handles folio
  migration by setting:

  src_folio->index = linear_page_index(dst_vma, dst_addr);

- If the PTE entry is a swap entry, move_swap_pte() simply copies
  the PTE to the new dst_addr.

This approach is incorrect because, even if the PTE is a swap entry,
it can still reference a folio that remains in the swap cache.

This creates a race window between steps 2 and 4.
 1. add_to_swap: The folio is added to the swapcache.
 2. try_to_unmap: PTEs are converted to swap entries.
 3. pageout: The folio is written back.
 4. Swapcache is cleared.
If userfaultfd_move() occurs in the window between steps 2 and 4,
after the swap PTE has been moved to the destination, accessing the
destination triggers do_swap_page(), which may locate the folio in
the swapcache. However, since the folio's index has not been updated
to match the destination VMA, do_swap_page() will detect a mismatch.

This can result in two critical issues depending on the system
configuration.

If KSM is disabled, both small and large folios can trigger a BUG
during the add_rmap operation due to:

 page_pgoff(folio, page) != linear_page_index(vma, address)

[   13.336953] page: refcount:6 mapcount:1 mapping:00000000f43db19c index:0xffffaf150 pfn:0x4667c
[   13.337520] head: order:2 mapcount:1 entire_mapcount:0 nr_pages_mapped:1 pincount:0
[   13.337716] memcg:ffff00000405f000
[   13.337849] anon flags: 0x3fffc0000020459(locked|uptodate|dirty|owner_priv_1|head|swapbacked|node=0|zone=0|lastcpupid=0xffff)
[   13.338630] raw: 03fffc0000020459 ffff80008507b538 ffff80008507b538 ffff000006260361
[   13.338831] raw: 0000000ffffaf150 0000000000004000 0000000600000000 ffff00000405f000
[   13.339031] head: 03fffc0000020459 ffff80008507b538 ffff80008507b538 ffff000006260361
[   13.339204] head: 0000000ffffaf150 0000000000004000 0000000600000000 ffff00000405f000
[   13.339375] head: 03fffc0000000202 fffffdffc0199f01 ffffffff00000000 0000000000000001
[   13.339546] head: 0000000000000004 0000000000000000 00000000ffffffff 0000000000000000
[   13.339736] page dumped because: VM_BUG_ON_PAGE(page_pgoff(folio, page) != linear_page_index(vma, address))
[   13.340190] ------------[ cut here ]------------
[   13.340316] kernel BUG at mm/rmap.c:1380!
[   13.340683] Internal error: Oops - BUG: 00000000f2000800 [#1] PREEMPT SMP
[   13.340969] Modules linked in:
[   13.341257] CPU: 1 UID: 0 PID: 107 Comm: a.out Not tainted 6.14.0-rc3-gcf42737e247a-dirty #299
[   13.341470] Hardware name: linux,dummy-virt (DT)
[   13.341671] pstate: 60000005 (nZCv daif -PAN -UAO -TCO -DIT -SSBS BTYPE=--)
[   13.341815] pc : __page_check_anon_rmap+0xa0/0xb0
[   13.341920] lr : __page_check_anon_rmap+0xa0/0xb0
[   13.342018] sp : ffff80008752bb20
[   13.342093] x29: ffff80008752bb20 x28: fffffdffc0199f00 x27: 0000000000000001
[   13.342404] x26: 0000000000000000 x25: 0000000000000001 x24: 0000000000000001
[   13.342575] x23: 0000ffffaf0d0000 x22: 0000ffffaf0d0000 x21: fffffdffc0199f00
[   13.342731] x20: fffffdffc0199f00 x19: ffff000006210700 x18: 00000000ffffffff
[   13.342881] x17: 6c203d2120296567 x16: 6170202c6f696c6f x15: 662866666f67705f
[   13.343033] x14: 6567617028454741 x13: 2929737365726464 x12: ffff800083728ab0
[   13.343183] x11: ffff800082996bf8 x10: 0000000000000fd7 x9 : ffff80008011bc40
[   13.343351] x8 : 0000000000017fe8 x7 : 00000000fffff000 x6 : ffff8000829eebf8
[   13.343498] x5 : c0000000fffff000 x4 : 0000000000000000 x3 : 0000000000000000
[   13.343645] x2 : 0000000000000000 x1 : ffff0000062db980 x0 : 000000000000005f
[   13.343876] Call trace:
[   13.344045]  __page_check_anon_rmap+0xa0/0xb0 (P)
[   13.344234]  folio_add_anon_rmap_ptes+0x22c/0x320
[   13.344333]  do_swap_page+0x1060/0x1400
[   13.344417]  __handl
---truncated---</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-21983" data-description="in the linux kernel, the following vulnerability has been resolved:

mm/slab/kvfree_rcu: switch to wq_mem_reclaim wq

currently kvfree_rcu() apis use a system workqueue which is
"system_unbound_wq" to driver rcu machinery to reclaim a memory.

recently, it has been noted that the following kernel warning can
be observed:

<snip>
workqueue: wq_mem_reclaim nvme-wq:nvme_scan_work is flushing !wq_mem_reclaim events_unbound:kfree_rcu_work
  warning: cpu: 21 pid: 330 at kernel/workqueue.c:3719 check_flush_dependency+0x112/0x120
  modules linked in: intel_uncore_frequency(e) intel_uncore_frequency_common(e) skx_edac(e) ...
  cpu: 21 uid: 0 pid: 330 comm: kworker/u144:6 tainted: g            e      6.13.2-0_g925d379822da #1
  hardware name: wiwynn twin lakes mp/twin lakes passive mp, bios ymm20 02/01/2023
  workqueue: nvme-wq nvme_scan_work
  rip: 0010:check_flush_dependency+0x112/0x120
  code: 05 9a 40 14 02 01 48 81 c6 c0 00 00 00 48 8b 50 18 48 81 c7 c0 00 00 00 48 89 f9 48 ...
  rsp: 0018:ffffc90000df7bd8 eflags: 00010082
  rax: 000000000000006a rbx: ffffffff81622390 rcx: 0000000000000027
  rdx: 00000000fffeffff rsi: 000000000057ffa8 rdi: ffff88907f960c88
  rbp: 0000000000000000 r08: ffffffff83068e50 r09: 000000000002fffd
  r10: 0000000000000004 r11: 0000000000000000 r12: ffff8881001a4400
  r13: 0000000000000000 r14: ffff88907f420fb8 r15: 0000000000000000
  fs:  0000000000000000(0000) gs:ffff88907f940000(0000) knlgs:0000000000000000
  cr2: 00007f60c3001000 cr3: 000000107d010005 cr4: 00000000007726f0
  pkru: 55555554
  call trace:
   <task>
   ? __warn+0xa4/0x140
   ? check_flush_dependency+0x112/0x120
   ? report_bug+0xe1/0x140
   ? check_flush_dependency+0x112/0x120
   ? handle_bug+0x5e/0x90
   ? exc_invalid_op+0x16/0x40
   ? asm_exc_invalid_op+0x16/0x20
   ? timer_recalc_next_expiry+0x190/0x190
   ? check_flush_dependency+0x112/0x120
   ? check_flush_dependency+0x112/0x120
   __flush_work.llvm.1643880146586177030+0x174/0x2c0
   flush_rcu_work+0x28/0x30
   kvfree_rcu_barrier+0x12f/0x160
   kmem_cache_destroy+0x18/0x120
   bioset_exit+0x10c/0x150
   disk_release.llvm.6740012984264378178+0x61/0xd0
   device_release+0x4f/0x90
   kobject_put+0x95/0x180
   nvme_put_ns+0x23/0xc0
   nvme_remove_invalid_namespaces+0xb3/0xd0
   nvme_scan_work+0x342/0x490
   process_scheduled_works+0x1a2/0x370
   worker_thread+0x2ff/0x390
   ? pwq_release_workfn+0x1e0/0x1e0
   kthread+0xb1/0xe0
   ? __kthread_parkme+0x70/0x70
   ret_from_fork+0x30/0x40
   ? __kthread_parkme+0x70/0x70
   ret_from_fork_asm+0x11/0x20
   </task>
  ---[ end trace 0000000000000000 ]---
<snip>

to address this switch to use of independent wq_mem_reclaim
workqueue, so the rules are not violated from workqueue framework
point of view.

apart of that, since kvfree_rcu() does reclaim memory it is worth
to go with wq_mem_reclaim type of wq because it is designed for
this purpose.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-21983" target="_blank">CVE-2025-21983</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-04-01 11:15:29 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">N/A</span></p>
                    <p><span class="feed-label">CVSS Score:</span> N/A</p>
                    <p>In the Linux kernel, the following vulnerability has been resolved:

mm/slab/kvfree_rcu: Switch to WQ_MEM_RECLAIM wq

Currently kvfree_rcu() APIs use a system workqueue which is
"system_unbound_wq" to driver RCU machinery to reclaim a memory.

Recently, it has been noted that the following kernel warning can
be observed:

<snip>
workqueue: WQ_MEM_RECLAIM nvme-wq:nvme_scan_work is flushing !WQ_MEM_RECLAIM events_unbound:kfree_rcu_work
  WARNING: CPU: 21 PID: 330 at kernel/workqueue.c:3719 check_flush_dependency+0x112/0x120
  Modules linked in: intel_uncore_frequency(E) intel_uncore_frequency_common(E) skx_edac(E) ...
  CPU: 21 UID: 0 PID: 330 Comm: kworker/u144:6 Tainted: G            E      6.13.2-0_g925d379822da #1
  Hardware name: Wiwynn Twin Lakes MP/Twin Lakes Passive MP, BIOS YMM20 02/01/2023
  Workqueue: nvme-wq nvme_scan_work
  RIP: 0010:check_flush_dependency+0x112/0x120
  Code: 05 9a 40 14 02 01 48 81 c6 c0 00 00 00 48 8b 50 18 48 81 c7 c0 00 00 00 48 89 f9 48 ...
  RSP: 0018:ffffc90000df7bd8 EFLAGS: 00010082
  RAX: 000000000000006a RBX: ffffffff81622390 RCX: 0000000000000027
  RDX: 00000000fffeffff RSI: 000000000057ffa8 RDI: ffff88907f960c88
  RBP: 0000000000000000 R08: ffffffff83068e50 R09: 000000000002fffd
  R10: 0000000000000004 R11: 0000000000000000 R12: ffff8881001a4400
  R13: 0000000000000000 R14: ffff88907f420fb8 R15: 0000000000000000
  FS:  0000000000000000(0000) GS:ffff88907f940000(0000) knlGS:0000000000000000
  CR2: 00007f60c3001000 CR3: 000000107d010005 CR4: 00000000007726f0
  PKRU: 55555554
  Call Trace:
   <TASK>
   ? __warn+0xa4/0x140
   ? check_flush_dependency+0x112/0x120
   ? report_bug+0xe1/0x140
   ? check_flush_dependency+0x112/0x120
   ? handle_bug+0x5e/0x90
   ? exc_invalid_op+0x16/0x40
   ? asm_exc_invalid_op+0x16/0x20
   ? timer_recalc_next_expiry+0x190/0x190
   ? check_flush_dependency+0x112/0x120
   ? check_flush_dependency+0x112/0x120
   __flush_work.llvm.1643880146586177030+0x174/0x2c0
   flush_rcu_work+0x28/0x30
   kvfree_rcu_barrier+0x12f/0x160
   kmem_cache_destroy+0x18/0x120
   bioset_exit+0x10c/0x150
   disk_release.llvm.6740012984264378178+0x61/0xd0
   device_release+0x4f/0x90
   kobject_put+0x95/0x180
   nvme_put_ns+0x23/0xc0
   nvme_remove_invalid_namespaces+0xb3/0xd0
   nvme_scan_work+0x342/0x490
   process_scheduled_works+0x1a2/0x370
   worker_thread+0x2ff/0x390
   ? pwq_release_workfn+0x1e0/0x1e0
   kthread+0xb1/0xe0
   ? __kthread_parkme+0x70/0x70
   ret_from_fork+0x30/0x40
   ? __kthread_parkme+0x70/0x70
   ret_from_fork_asm+0x11/0x20
   </TASK>
  ---[ end trace 0000000000000000 ]---
<snip>

To address this switch to use of independent WQ_MEM_RECLAIM
workqueue, so the rules are not violated from workqueue framework
point of view.

Apart of that, since kvfree_rcu() does reclaim memory it is worth
to go with WQ_MEM_RECLAIM type of wq because it is designed for
this purpose.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-21982" data-description="in the linux kernel, the following vulnerability has been resolved:

pinctrl: nuvoton: npcm8xx: add null check in npcm8xx_gpio_fw

devm_kasprintf() calls can return null pointers on failure.
but the return values were not checked in npcm8xx_gpio_fw().
add null check in npcm8xx_gpio_fw(), to handle kernel null
pointer dereference error.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-21982" target="_blank">CVE-2025-21982</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-04-01 11:15:29 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">N/A</span></p>
                    <p><span class="feed-label">CVSS Score:</span> N/A</p>
                    <p>In the Linux kernel, the following vulnerability has been resolved:

pinctrl: nuvoton: npcm8xx: Add NULL check in npcm8xx_gpio_fw

devm_kasprintf() calls can return null pointers on failure.
But the return values were not checked in npcm8xx_gpio_fw().
Add NULL check in npcm8xx_gpio_fw(), to handle kernel NULL
pointer dereference error.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-21981" data-description="in the linux kernel, the following vulnerability has been resolved:

ice: fix memory leak in arfs after reset

fix arfs (accelerated receive flow steering) structures memory leak by
adding a checker to verify if arfs memory is already allocated while
configuring vsi. arfs objects are allocated in two cases:
- as part of vsi initialization (at probe), and
- as part of reset handling

however, vsi reconfiguration executed during reset involves memory
allocation one more time, without prior releasing already allocated
resources. this led to the memory leak with the following signature:

[root@os-delivery ~]# cat /sys/kernel/debug/kmemleak
unreferenced object 0xff3c1ca7252e6000 (size 8192):
  comm "kworker/0:0", pid 8, jiffies 4296833052
  hex dump (first 32 bytes):
    00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
    00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
  backtrace (crc 0):
    [<ffffffff991ec485>] __kmalloc_cache_noprof+0x275/0x340
    [<ffffffffc0a6e06a>] ice_init_arfs+0x3a/0xe0 [ice]
    [<ffffffffc09f1027>] ice_vsi_cfg_def+0x607/0x850 [ice]
    [<ffffffffc09f244b>] ice_vsi_setup+0x5b/0x130 [ice]
    [<ffffffffc09c2131>] ice_init+0x1c1/0x460 [ice]
    [<ffffffffc09c64af>] ice_probe+0x2af/0x520 [ice]
    [<ffffffff994fbcd3>] local_pci_probe+0x43/0xa0
    [<ffffffff98f07103>] work_for_cpu_fn+0x13/0x20
    [<ffffffff98f0b6d9>] process_one_work+0x179/0x390
    [<ffffffff98f0c1e9>] worker_thread+0x239/0x340
    [<ffffffff98f14abc>] kthread+0xcc/0x100
    [<ffffffff98e45a6d>] ret_from_fork+0x2d/0x50
    [<ffffffff98e083ba>] ret_from_fork_asm+0x1a/0x30
    ...">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-21981" target="_blank">CVE-2025-21981</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-04-01 11:15:29 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">N/A</span></p>
                    <p><span class="feed-label">CVSS Score:</span> N/A</p>
                    <p>In the Linux kernel, the following vulnerability has been resolved:

ice: fix memory leak in aRFS after reset

Fix aRFS (accelerated Receive Flow Steering) structures memory leak by
adding a checker to verify if aRFS memory is already allocated while
configuring VSI. aRFS objects are allocated in two cases:
- as part of VSI initialization (at probe), and
- as part of reset handling

However, VSI reconfiguration executed during reset involves memory
allocation one more time, without prior releasing already allocated
resources. This led to the memory leak with the following signature:

[root@os-delivery ~]# cat /sys/kernel/debug/kmemleak
unreferenced object 0xff3c1ca7252e6000 (size 8192):
  comm "kworker/0:0", pid 8, jiffies 4296833052
  hex dump (first 32 bytes):
    00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
    00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
  backtrace (crc 0):
    [<ffffffff991ec485>] __kmalloc_cache_noprof+0x275/0x340
    [<ffffffffc0a6e06a>] ice_init_arfs+0x3a/0xe0 [ice]
    [<ffffffffc09f1027>] ice_vsi_cfg_def+0x607/0x850 [ice]
    [<ffffffffc09f244b>] ice_vsi_setup+0x5b/0x130 [ice]
    [<ffffffffc09c2131>] ice_init+0x1c1/0x460 [ice]
    [<ffffffffc09c64af>] ice_probe+0x2af/0x520 [ice]
    [<ffffffff994fbcd3>] local_pci_probe+0x43/0xa0
    [<ffffffff98f07103>] work_for_cpu_fn+0x13/0x20
    [<ffffffff98f0b6d9>] process_one_work+0x179/0x390
    [<ffffffff98f0c1e9>] worker_thread+0x239/0x340
    [<ffffffff98f14abc>] kthread+0xcc/0x100
    [<ffffffff98e45a6d>] ret_from_fork+0x2d/0x50
    [<ffffffff98e083ba>] ret_from_fork_asm+0x1a/0x30
    ...</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-21980" data-description="in the linux kernel, the following vulnerability has been resolved:

sched: address a potential null pointer dereference in the gred scheduler.

if kzalloc in gred_init returns a null pointer, the code follows the
error handling path, invoking gred_destroy. this, in turn, calls
gred_offload, where memset could receive a null pointer as input,
potentially leading to a kernel crash.

when table->opt is null in gred_init(), gred_change_table_def()
is not called yet, so it is not necessary to call ->ndo_setup_tc()
in gred_offload().">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-21980" target="_blank">CVE-2025-21980</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-04-01 11:15:29 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">N/A</span></p>
                    <p><span class="feed-label">CVSS Score:</span> N/A</p>
                    <p>In the Linux kernel, the following vulnerability has been resolved:

sched: address a potential NULL pointer dereference in the GRED scheduler.

If kzalloc in gred_init returns a NULL pointer, the code follows the
error handling path, invoking gred_destroy. This, in turn, calls
gred_offload, where memset could receive a NULL pointer as input,
potentially leading to a kernel crash.

When table->opt is NULL in gred_init(), gred_change_table_def()
is not called yet, so it is not necessary to call ->ndo_setup_tc()
in gred_offload().</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-21979" data-description="in the linux kernel, the following vulnerability has been resolved:

wifi: cfg80211: cancel wiphy_work before freeing wiphy

a wiphy_work can be queued from the moment the wiphy is allocated and
initialized (i.e. wiphy_new_nm). when a wiphy_work is queued, the
rdev::wiphy_work is getting queued.

if wiphy_free is called before the rdev::wiphy_work had a chance to run,
the wiphy memory will be freed, and then when it eventally gets to run
it'll use invalid memory.

fix this by canceling the work before freeing the wiphy.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-21979" target="_blank">CVE-2025-21979</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-04-01 11:15:29 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">N/A</span></p>
                    <p><span class="feed-label">CVSS Score:</span> N/A</p>
                    <p>In the Linux kernel, the following vulnerability has been resolved:

wifi: cfg80211: cancel wiphy_work before freeing wiphy

A wiphy_work can be queued from the moment the wiphy is allocated and
initialized (i.e. wiphy_new_nm). When a wiphy_work is queued, the
rdev::wiphy_work is getting queued.

If wiphy_free is called before the rdev::wiphy_work had a chance to run,
the wiphy memory will be freed, and then when it eventally gets to run
it'll use invalid memory.

Fix this by canceling the work before freeing the wiphy.</p>
                </div>
        
            </div>
        </div>

        <footer class="footer">
            <p>© 2025 dotne1 - Cybersecurity Portfolio</p>
        </footer>

        <script>
            function searchCVEs() {
                const input = document.getElementById('searchInput').value.toLowerCase();
                const cveEntries = document.getElementsByClassName('cve-entry');
                for (let i = 0; i < cveEntries.length; i++) {
                    const cveId = cveEntries[i].getAttribute('data-cve-id').toLowerCase();
                    const description = cveEntries[i].getAttribute('data-description');
                    if (cveId.includes(input) || description.includes(input)) {
                        cveEntries[i].style.display = '';
                    } else {
                        cveEntries[i].style.display = 'none';
                    }
                }
            }
        </script>
    </body>
    </html>
    