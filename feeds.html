
    <!DOCTYPE html>
    <html lang="en">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <meta name="description" content="Security alerts and cybersecurity news feeds">
        <meta name="keywords" content="cybersecurity news, security alerts, vulnerability feeds, threat intelligence">
        <meta name="author" content="dotne1">
        <meta property="og:title" content="Security Feeds - dotne1's Cybersecurity Portfolio">
        <meta property="og:description" content="Stay updated with the latest cybersecurity news and alerts">
        <meta property="og:type" content="website">
        <title>Security Feeds - dotne1's Cybersecurity Portfolio</title>
        <link rel="stylesheet" href="styles.css">
        <link rel="icon" type="image/x-icon" href="/favicon.ico">
    </head>
    <body>
        <nav class="navbar">
            <div class="nav-links">
                <a href="index.html" class="nav-link">Home</a>
                <a href="about-me.html" class="nav-link">About Me</a>
                <a href="projects.html" class="nav-link">Projects</a>
                <a href="resume.html" class="nav-link">Resume</a>
                <a href="feeds.html" class="nav-link">Feeds</a>
            </div>
        </nav>

        <div class="container" role="main">
            <h1 class="main-header">Security Feeds</h1>
            <div class="search-bar">
                <input type="text" id="searchInput" placeholder="Search CVEs..." onkeyup="searchCVEs()">
            </div>
            <div class="feed-preview" id="cveFeed">
                <div class="feed-header">Latest Vulnerabilities</div>
    
                <div class="cve-entry" data-cve-id="CVE-2025-10127" data-description="daikin security gateway is vulnerable to an authorization bypass through
 a user-controlled key vulnerability that could allow an attacker to 
bypass authentication. an unauthorized attacker could access the system 
without prior credentials.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-10127" target="_blank">CVE-2025-10127</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-09-11 15:15:33 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-online">HIGH</span></p>
                    <p><span class="feed-label">CVSS Score:</span> 7.3</p>
                    <p>Daikin Security Gateway is vulnerable to an authorization bypass through
 a user-controlled key vulnerability that could allow an attacker to 
bypass authentication. An unauthorized attacker could access the system 
without prior credentials.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-9319" data-description="a potential vulnerability was reported in the lenovo wallpaper client that could allow arbitrary code execution under certain conditions.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-9319" target="_blank">CVE-2025-9319</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-09-11 14:15:35 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-online">HIGH</span></p>
                    <p><span class="feed-label">CVSS Score:</span> 7.5</p>
                    <p>A potential vulnerability was reported in the Lenovo Wallpaper Client that could allow arbitrary code execution under certain conditions.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-9214" data-description="a missing authentication vulnerability was reported in some lenovo printers that could allow a user to view limited device information or modify network settings via the cups service.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-9214" target="_blank">CVE-2025-9214</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-09-11 14:15:35 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">MEDIUM</span></p>
                    <p><span class="feed-label">CVSS Score:</span> 5.4</p>
                    <p>A missing authentication vulnerability was reported in some Lenovo printers that could allow a user to view limited device information or modify network settings via the CUPS service.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-9201" data-description="a potential dll hijacking vulnerability was discovered in lenovo browser during an internal security assessment that could allow a local user to execute code with elevated privileges.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-9201" target="_blank">CVE-2025-9201</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-09-11 14:15:35 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-online">HIGH</span></p>
                    <p><span class="feed-label">CVSS Score:</span> 7.8</p>
                    <p>A potential DLL hijacking vulnerability was discovered in Lenovo Browser during an internal security assessment that could allow a local user to execute code with elevated privileges.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-8557" data-description="an internal product security audit of lenovo xclarity orchestrator (lxco) discovered the below vulnerability:

an attacker with access to a device on the local lenovo xclarity orchestrator (lxco) network segment may be able to manipulate the local device to create an alternate communication channel which could allow the attacker, under certain conditions, to directly interact with backend lxco api services typically inaccessible to users. while access controls may limit the scope of interaction, this could result in unauthorized access to internal functionality or data. this issue is not exploitable from remote networks.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-8557" target="_blank">CVE-2025-8557</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-09-11 14:15:35 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-online">HIGH</span></p>
                    <p><span class="feed-label">CVSS Score:</span> 8.8</p>
                    <p>An internal product security audit of Lenovo XClarity Orchestrator (LXCO) discovered the below vulnerability:

An attacker with access to a device on the local Lenovo XClarity Orchestrator (LXCO) network segment may be able to manipulate the local device to create an alternate communication channel which could allow the attacker, under certain conditions, to directly interact with backend LXCO API services typically inaccessible to users. While access controls may limit the scope of interaction, this could result in unauthorized access to internal functionality or data. This issue is not exploitable from remote networks.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-8061" data-description="a potential insufficient access control vulnerability was reported in the lenovo dispatcher 3.0 and dispatcher 3.1 drivers used by some lenovo consumer notebooks that could allow an authenticated local user to execute code with elevated privileges. the lenovo dispatcher 3.2 driver is not affected. this vulnerability does not affect systems when the windows feature core isolation memory integrity is enabled. lenovo systems preloaded with windows 11 have this feature enabled by default.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-8061" target="_blank">CVE-2025-8061</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-09-11 14:15:35 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-online">HIGH</span></p>
                    <p><span class="feed-label">CVSS Score:</span> 7.0</p>
                    <p>A potential insufficient access control vulnerability was reported in the Lenovo Dispatcher 3.0 and Dispatcher 3.1 drivers used by some Lenovo consumer notebooks that could allow an authenticated local user to execute code with elevated privileges. The Lenovo Dispatcher 3.2 driver is not affected. This vulnerability does not affect systems when the Windows feature Core Isolation Memory Integrity is enabled. Lenovo systems preloaded with Windows 11 have this feature enabled by default.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-59055" data-description="instantcms is a free and open source content management system. a blind server-side request forgery (ssrf) vulnerability in instantcms up to and including 2.17.3 allows authenticated remote attackers to make nay http/https request via the package parameter. it is possible to make any http/https request to any website in installer functionality. due to such vulnerability it is possible to for example scan local network, call local services and its functions, conduct a dos attack, and/or disclose a server's real ip if it's behind a reverse proxy. it is also possible to exhaust server resources by sending plethora of such requests. as of time of publication, no patched releases are available.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-59055" target="_blank">CVE-2025-59055</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-09-11 14:15:34 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">MEDIUM</span></p>
                    <p><span class="feed-label">CVSS Score:</span> 4.7</p>
                    <p>InstantCMS is a free and open source content management system. A blind Server-Side Request Forgery (SSRF) vulnerability in InstantCMS up to and including 2.17.3 allows authenticated remote attackers to make nay HTTP/HTTPS request via the package parameter. It is possible to make any HTTP/HTTPS request to any website in installer functionality. Due to such vulnerability it is possible to for example scan local network, call local services and its functions, conduct a DoS attack, and/or disclose a server's real IP if it's behind a reverse proxy. It is also possible to exhaust server resources by sending plethora of such requests. As of time of publication, no patched releases are available.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-59053" data-description="airi is a self-hosted, artificial intelligence based grok companion. in v0.7.2-beta.2 in the `packages/stage-ui/src/components/markdownrenderer.vue` path, the markdown content is processed using the usemarkdown composable, and the processed html is rendered directly into the dom using v-html. an attacker creates a card file containing malicious html/javascript, then simply processes it using the highlighttagtohtml function (which simply replaces template tags without html escaping), and then directly renders it using v-html, leading to cross-site scripting (xss). the project also exposes the tauri api, which can be called from the frontend. the mcp plugin exposes a command execution interface function in `crates/tauri-plugin-mcp/src/lib.rs`. this allows arbitrary command execution. `connect_server` directly passes the user-supplied `command` and `args` parameters to `command::new(command).args(args)` without any input validation or whitelisting. thus, the previous xss exploit could achieve command execution through this interface. v0.7.2-beta.3 fixes the issue.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-59053" target="_blank">CVE-2025-59053</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-09-11 14:15:34 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-online">CRITICAL</span></p>
                    <p><span class="feed-label">CVSS Score:</span> 9.6</p>
                    <p>AIRI is a self-hosted, artificial intelligence based Grok Companion. In v0.7.2-beta.2 in the `packages/stage-ui/src/components/MarkdownRenderer.vue` path, the Markdown content is processed using the useMarkdown composable, and the processed HTML is rendered directly into the DOM using v-html. An attacker creates a card file containing malicious HTML/JavaScript, then simply processes it using the highlightTagToHtml function (which simply replaces template tags without HTML escaping), and then directly renders it using v-html, leading to cross-site scripting (XSS). The project also exposes the Tauri API, which can be called from the frontend. The MCP plugin exposes a command execution interface function in `crates/tauri-plugin-mcp/src/lib.rs`. This allows arbitrary command execution. `connect_server` directly passes the user-supplied `command` and `args` parameters to `Command::new(command).args(args)` without any input validation or whitelisting. Thus, the previous XSS exploit could achieve command execution through this interface. v0.7.2-beta.3 fixes the issue.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-56556" data-description="an issue was discovered in subrion cms 4.2.1, allowing authenticated adminitrators or moderators with access to the built-in run sql query feature under the sql tool admin panel - to gain escalated privileges in the context of the sql query tool.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-56556" target="_blank">CVE-2025-56556</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-09-11 14:15:32 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">N/A</span></p>
                    <p><span class="feed-label">CVSS Score:</span> N/A</p>
                    <p>An issue was discovered in Subrion CMS 4.2.1, allowing authenticated adminitrators or moderators with access to the built-in Run SQL Query feature under the SQL Tool admin panel - to gain escalated privileges in the context of the SQL query tool.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-59047" data-description="matrix-sdk-base is the base component to build a matrix client library. in matrix-sdk-base before 0.14.1, calling the `roommember::normalized_power_level()` method can cause a panic if a room member has a power level of `int::min`. the issue is fixed in matrix-sdk-base 0.14.1. the affected method isn’t used internally, so avoiding calling `roommember::normalized_power_level()` prevents the panic.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-59047" target="_blank">CVE-2025-59047</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-09-11 13:15:35 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">N/A</span></p>
                    <p><span class="feed-label">CVSS Score:</span> N/A</p>
                    <p>matrix-sdk-base is the base component to build a Matrix client library. In matrix-sdk-base before 0.14.1, calling the `RoomMember::normalized_power_level()` method can cause a panic if a room member has a power level of `Int::Min`. The issue is fixed in matrix-sdk-base 0.14.1. The affected method isn’t used internally, so avoiding calling `RoomMember::normalized_power_level()` prevents the panic.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-58364" data-description="openprinting cups is an open source printing system for linux and other unix-like operating systems. in versions 2.4.12 and earlier, an unsafe deserialization and validation of printer attributes causes null dereference in the libcups library. this is a remote dos vulnerability available in local subnet in default configurations. it can cause the cups & cups-browsed to crash, on all the machines in local network who are listening for printers (so by default for all regular linux machines). on systems where the vulnerability cve-2024-47176 (cups-filters 1.x/cups-browsed 2.x vulnerability) was not fixed, and the firewall on the machine does not reject incoming communication to ipp port, and the machine is set to be available to public internet, attack vector "network" is possible. the current versions of cups and cups-browsed projects have the attack vector "adjacent" in their default configurations. version 2.4.13 contains a patch for cve-2025-58364.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-58364" target="_blank">CVE-2025-58364</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-09-11 13:15:35 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">MEDIUM</span></p>
                    <p><span class="feed-label">CVSS Score:</span> 6.5</p>
                    <p>OpenPrinting CUPS is an open source printing system for Linux and other Unix-like operating systems. In versions 2.4.12 and earlier, an unsafe deserialization and validation of printer attributes causes null dereference in the libcups library. This is a remote DoS vulnerability available in local subnet in default configurations. It can cause the cups & cups-browsed to crash, on all the machines in local network who are listening for printers (so by default for all regular linux machines). On systems where the vulnerability CVE-2024-47176 (cups-filters 1.x/cups-browsed 2.x vulnerability) was not fixed, and the firewall on the machine does not reject incoming communication to IPP port, and the machine is set to be available to public internet, attack vector "Network" is possible. The current versions of CUPS and cups-browsed projects have the attack vector "Adjacent" in their default configurations. Version 2.4.13 contains a patch for CVE-2025-58364.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-58065" data-description="flask-appbuilder is an application development framework. prior to version 4.8.1, when flask-appbuilder is configured to use oauth, ldap, or other non-database authentication methods, the password reset endpoint remains registered and accessible, despite not being displayed in the user interface. this allows an enabled user to reset their password and be able to create jwt tokens even after the user is disabled on the authentication provider. users should upgrade to flask-appbuilder version 4.8.1 or later to receive a fix. if immediate upgrade is not possible, manually disable password reset routes in the application configuration; implement additional access controls at the web server or proxy level to block access to the reset my password url; and/or monitor for suspicious password reset attempts from disabled accounts.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-58065" target="_blank">CVE-2025-58065</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-09-11 13:15:35 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">MEDIUM</span></p>
                    <p><span class="feed-label">CVSS Score:</span> 6.5</p>
                    <p>Flask-AppBuilder is an application development framework. Prior to version 4.8.1, when Flask-AppBuilder is configured to use OAuth, LDAP, or other non-database authentication methods, the password reset endpoint remains registered and accessible, despite not being displayed in the user interface. This allows an enabled user to reset their password and be able to create JWT tokens even after the user is disabled on the authentication provider. Users should upgrade to Flask-AppBuilder version 4.8.1 or later to receive a fix. If immediate upgrade is not possible, manually disable password reset routes in the application configuration; implement additional access controls at the web server or proxy level to block access to the reset my password URL; and/or monitor for suspicious password reset attempts from disabled accounts.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-58060" data-description="openprinting cups is an open source printing system for linux and other unix-like operating systems. in versions 2.4.12 and earlier, when the `authtype` is set to anything but `basic`, if the request contains an `authorization: basic ...` header, the password is not checked. this results in authentication bypass. any configuration that allows an `authtype` that is not `basic` is affected. version 2.4.13 fixes the issue.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-58060" target="_blank">CVE-2025-58060</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-09-11 13:15:34 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-online">HIGH</span></p>
                    <p><span class="feed-label">CVSS Score:</span> 8.0</p>
                    <p>OpenPrinting CUPS is an open source printing system for Linux and other Unix-like operating systems. In versions 2.4.12 and earlier, when the `AuthType` is set to anything but `Basic`, if the request contains an `Authorization: Basic ...` header, the password is not checked. This results in authentication bypass. Any configuration that allows an `AuthType` that is not `Basic` is affected. Version 2.4.13 fixes the issue.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-43790" data-description="insecure direct object reference (idor) vulnerability in liferay portal 7.4.0 through 7.4.3.124, and liferay dxp 2024.q2.0 through 2024.q2.6, 2024.q1.1 through 2024.q1.12 and 7.4 ga through update 92 allows remote authenticated users to from one virtual instance to access, create, edit, relate data/object entries/definitions to an object in a different virtual instance.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-43790" target="_blank">CVE-2025-43790</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-09-11 13:15:34 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">N/A</span></p>
                    <p><span class="feed-label">CVSS Score:</span> N/A</p>
                    <p>Insecure Direct Object Reference (IDOR) vulnerability in Liferay Portal 7.4.0 through 7.4.3.124, and Liferay DXP 2024.Q2.0 through 2024.Q2.6, 2024.Q1.1 through 2024.Q1.12 and 7.4 GA through update 92 allows remote authenticated users to from one virtual instance to access, create, edit, relate data/object entries/definitions to an object in a different virtual instance.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-43782" data-description="insecure direct object reference (idor) vulnerability in liferay portal 7.4.0 through 7.4.3.124, and liferay dxp 2024.q2.0 through 2024.q2.7, 2024.q1.1 through 2024.q1.12, and 7.4 ga through update 92 allows remote authenticated users to access a workflow definition by name via the api">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-43782" target="_blank">CVE-2025-43782</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-09-11 13:15:33 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">N/A</span></p>
                    <p><span class="feed-label">CVSS Score:</span> N/A</p>
                    <p>Insecure Direct Object Reference (IDOR) vulnerability in Liferay Portal 7.4.0 through 7.4.3.124, and Liferay DXP 2024.Q2.0 through 2024.Q2.7, 2024.Q1.1 through 2024.Q1.12, and 7.4 GA through update 92 allows remote authenticated users to access a workflow definition by name via the API</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-40300" data-description="in the linux kernel, the following vulnerability has been resolved:

x86/vmscape: add conditional ibpb mitigation

vmscape is a vulnerability that exploits insufficient branch predictor
isolation between a guest and a userspace hypervisor (like qemu). existing
mitigations already protect kernel/kvm from a malicious guest. userspace
can additionally be protected by flushing the branch predictors after a
vmexit.

since it is the userspace that consumes the poisoned branch predictors,
conditionally issue an ibpb after a vmexit and before returning to
userspace. workloads that frequently switch between hypervisor and
userspace will incur the most overhead from the new ibpb.

this new ibpb is not integrated with the existing ibpb sites. for
instance, a task can use the existing speculation control prctl() to
get an ibpb at context switch time. with this implementation, the
ibpb is doubled up: one at context switch and another before running
userspace.

the intent is to integrate and optimize these cases post-embargo.

[ dhansen: elaborate on suboptimal ibpb solution ]">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-40300" target="_blank">CVE-2025-40300</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-09-11 12:15:45 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">N/A</span></p>
                    <p><span class="feed-label">CVSS Score:</span> N/A</p>
                    <p>In the Linux kernel, the following vulnerability has been resolved:

x86/vmscape: Add conditional IBPB mitigation

VMSCAPE is a vulnerability that exploits insufficient branch predictor
isolation between a guest and a userspace hypervisor (like QEMU). Existing
mitigations already protect kernel/KVM from a malicious guest. Userspace
can additionally be protected by flushing the branch predictors after a
VMexit.

Since it is the userspace that consumes the poisoned branch predictors,
conditionally issue an IBPB after a VMexit and before returning to
userspace. Workloads that frequently switch between hypervisor and
userspace will incur the most overhead from the new IBPB.

This new IBPB is not integrated with the existing IBPB sites. For
instance, a task can use the existing speculation control prctl() to
get an IBPB at context switch time. With this implementation, the
IBPB is doubled up: one at context switch and another before running
userspace.

The intent is to integrate and optimize these cases post-embargo.

[ dhansen: elaborate on suboptimal IBPB solution ]</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-39791" data-description="in the linux kernel, the following vulnerability has been resolved:

dm: dm-crypt: do not partially accept write bios with zoned targets

read and write operations issued to a dm-crypt target may be split
according to the dm-crypt internal limits defined by the max_read_size
and max_write_size module parameters (default is 128 kb). the intent is
to improve processing time of large bios by splitting them into smaller
operations that can be parallelized on different cpus.

for zoned dm-crypt targets, this bio splitting is still done but without
the parallel execution to ensure that the issuing order of write
operations to the underlying devices remains sequential. however, the
splitting itself causes other problems:

1) since dm-crypt relies on the block layer zone write plugging to
   handle zone append emulation using regular write operations, the
   reminder of a split write bio will always be plugged into the target
   zone write plugged. once the on-going write bio finishes, this
   reminder bio is unplugged and issued from the zone write plug work.
   if this reminder bio itself needs to be split, the reminder will be
   re-issued and plugged again, but that causes a call to a
   blk_queue_enter(), which may block if a queue freeze operation was
   initiated. this results in a deadlock as dm submission still holds
   bios that the queue freeze side is waiting for.

2) dm-crypt relies on the emulation done by the block layer using
   regular write operations for processing zone append operations. this
   still requires to properly return the written sector as the bio
   sector of the original bio. however, this can be done correctly only
   and only if there is a single clone bio used for processing the
   original zone append operation issued by the user. if the size of a
   zone append operation is larger than dm-crypt max_write_size, then
   the orginal bio will be split and processed as a chain of regular
   write operations. such chaining result in an incorrect written sector
   being returned to the zone append issuer using the original bio
   sector.  this in turn results in file system data corruptions using
   xfs or btrfs.

fix this by modifying get_max_request_size() to always return the size
of the bio to avoid it being split with dm_accpet_partial_bio() in
crypt_map(). get_max_request_size() is renamed to
get_max_request_sectors() to clarify the unit of the value returned
and its interface is changed to take a struct dm_target pointer and a
pointer to the struct bio being processed. in addition to this change,
to ensure that crypt_alloc_buffer() works correctly, set the dm-crypt
device max_hw_sectors limit to be at most
bio_max_vecs << page_sectors_shift (1 mb with a 4kb page architecture).
this forces dm core to split write bios before passing them to
crypt_map(), and thus guaranteeing that dm-crypt can always accept an
entire write bio without needing to split it.

this change does not have any effect on the read path of dm-crypt. read
operations can still be split and the bio fragments processed in
parallel. there is also no impact on the performance of the write path
given that all zone write bios were already processed inline instead of
in parallel.

this change also does not affect in any way regular dm-crypt block
devices.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-39791" target="_blank">CVE-2025-39791</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-09-11 12:15:45 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">N/A</span></p>
                    <p><span class="feed-label">CVSS Score:</span> N/A</p>
                    <p>In the Linux kernel, the following vulnerability has been resolved:

dm: dm-crypt: Do not partially accept write BIOs with zoned targets

Read and write operations issued to a dm-crypt target may be split
according to the dm-crypt internal limits defined by the max_read_size
and max_write_size module parameters (default is 128 KB). The intent is
to improve processing time of large BIOs by splitting them into smaller
operations that can be parallelized on different CPUs.

For zoned dm-crypt targets, this BIO splitting is still done but without
the parallel execution to ensure that the issuing order of write
operations to the underlying devices remains sequential. However, the
splitting itself causes other problems:

1) Since dm-crypt relies on the block layer zone write plugging to
   handle zone append emulation using regular write operations, the
   reminder of a split write BIO will always be plugged into the target
   zone write plugged. Once the on-going write BIO finishes, this
   reminder BIO is unplugged and issued from the zone write plug work.
   If this reminder BIO itself needs to be split, the reminder will be
   re-issued and plugged again, but that causes a call to a
   blk_queue_enter(), which may block if a queue freeze operation was
   initiated. This results in a deadlock as DM submission still holds
   BIOs that the queue freeze side is waiting for.

2) dm-crypt relies on the emulation done by the block layer using
   regular write operations for processing zone append operations. This
   still requires to properly return the written sector as the BIO
   sector of the original BIO. However, this can be done correctly only
   and only if there is a single clone BIO used for processing the
   original zone append operation issued by the user. If the size of a
   zone append operation is larger than dm-crypt max_write_size, then
   the orginal BIO will be split and processed as a chain of regular
   write operations. Such chaining result in an incorrect written sector
   being returned to the zone append issuer using the original BIO
   sector.  This in turn results in file system data corruptions using
   xfs or btrfs.

Fix this by modifying get_max_request_size() to always return the size
of the BIO to avoid it being split with dm_accpet_partial_bio() in
crypt_map(). get_max_request_size() is renamed to
get_max_request_sectors() to clarify the unit of the value returned
and its interface is changed to take a struct dm_target pointer and a
pointer to the struct bio being processed. In addition to this change,
to ensure that crypt_alloc_buffer() works correctly, set the dm-crypt
device max_hw_sectors limit to be at most
BIO_MAX_VECS << PAGE_SECTORS_SHIFT (1 MB with a 4KB page architecture).
This forces DM core to split write BIOs before passing them to
crypt_map(), and thus guaranteeing that dm-crypt can always accept an
entire write BIO without needing to split it.

This change does not have any effect on the read path of dm-crypt. Read
operations can still be split and the BIO fragments processed in
parallel. There is also no impact on the performance of the write path
given that all zone write BIOs were already processed inline instead of
in parallel.

This change also does not affect in any way regular dm-crypt block
devices.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-39790" data-description="in the linux kernel, the following vulnerability has been resolved:

bus: mhi: host: detect events pointing to unexpected tres

when a remote device sends a completion event to the host, it contains a
pointer to the consumed tre. the host uses this pointer to process all of
the tres between it and the host's local copy of the ring's read pointer.
this works when processing completion for chained transactions, but can
lead to nasty results if the device sends an event for a single-element
transaction with a read pointer that is multiple elements ahead of the
host's read pointer.

for instance, if the host accesses an event ring while the device is
updating it, the pointer inside of the event might still point to an old
tre. if the host uses the channel's xfer_cb() to directly free the buffer
pointed to by the tre, the buffer will be double-freed.

this behavior was observed on an ep that used upstream ep stack without
'commit 6f18d174b73d ("bus: mhi: ep: update read pointer only after buffer
is written")'. where the device updated the events ring pointer before
updating the event contents, so it left a window where the host was able to
access the stale data the event pointed to, before the device had the
chance to update them. the usual pattern was that the host received an
event pointing to a tre that is not immediately after the last processed
one, so it got treated as if it was a chained transaction, processing all
of the tres in between the two read pointers.

this commit aims to harden the host by ensuring transactions where the
event points to a tre that isn't local_rp + 1 are chained.

[mani: added stable tag and reworded commit message]">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-39790" target="_blank">CVE-2025-39790</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-09-11 12:15:45 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">N/A</span></p>
                    <p><span class="feed-label">CVSS Score:</span> N/A</p>
                    <p>In the Linux kernel, the following vulnerability has been resolved:

bus: mhi: host: Detect events pointing to unexpected TREs

When a remote device sends a completion event to the host, it contains a
pointer to the consumed TRE. The host uses this pointer to process all of
the TREs between it and the host's local copy of the ring's read pointer.
This works when processing completion for chained transactions, but can
lead to nasty results if the device sends an event for a single-element
transaction with a read pointer that is multiple elements ahead of the
host's read pointer.

For instance, if the host accesses an event ring while the device is
updating it, the pointer inside of the event might still point to an old
TRE. If the host uses the channel's xfer_cb() to directly free the buffer
pointed to by the TRE, the buffer will be double-freed.

This behavior was observed on an ep that used upstream EP stack without
'commit 6f18d174b73d ("bus: mhi: ep: Update read pointer only after buffer
is written")'. Where the device updated the events ring pointer before
updating the event contents, so it left a window where the host was able to
access the stale data the event pointed to, before the device had the
chance to update them. The usual pattern was that the host received an
event pointing to a TRE that is not immediately after the last processed
one, so it got treated as if it was a chained transaction, processing all
of the TREs in between the two read pointers.

This commit aims to harden the host by ensuring transactions where the
event points to a TRE that isn't local_rp + 1 are chained.

[mani: added stable tag and reworded commit message]</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-39789" data-description="in the linux kernel, the following vulnerability has been resolved:

crypto: x86/aegis - add missing error checks

the skcipher_walk functions can allocate memory and can fail, so
checking for errors is necessary.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-39789" target="_blank">CVE-2025-39789</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-09-11 12:15:45 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">N/A</span></p>
                    <p><span class="feed-label">CVSS Score:</span> N/A</p>
                    <p>In the Linux kernel, the following vulnerability has been resolved:

crypto: x86/aegis - Add missing error checks

The skcipher_walk functions can allocate memory and can fail, so
checking for errors is necessary.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-39788" data-description="in the linux kernel, the following vulnerability has been resolved:

scsi: ufs: exynos: fix programming of hci_utrl_nexus_type

on google gs101, the number of utp transfer request slots (nutrs) is 32,
and in this case the driver ends up programming the utrl_nexus_type
incorrectly as 0.

this is because the left hand side of the shift is 1, which is of type
int, i.e. 31 bits wide. shifting by more than that width results in
undefined behaviour.

fix this by switching to the bit() macro, which applies correct type
casting as required. this ensures the correct value is written to
utrl_nexus_type (0xffffffff on gs101), and it also fixes a ubsan shift
warning:

    ubsan: shift-out-of-bounds in drivers/ufs/host/ufs-exynos.c:1113:21
    shift exponent 32 is too large for 32-bit type 'int'

for consistency, apply the same change to the nutmrs / utmrl_nexus_type
write.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-39788" target="_blank">CVE-2025-39788</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-09-11 12:15:45 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">N/A</span></p>
                    <p><span class="feed-label">CVSS Score:</span> N/A</p>
                    <p>In the Linux kernel, the following vulnerability has been resolved:

scsi: ufs: exynos: Fix programming of HCI_UTRL_NEXUS_TYPE

On Google gs101, the number of UTP transfer request slots (nutrs) is 32,
and in this case the driver ends up programming the UTRL_NEXUS_TYPE
incorrectly as 0.

This is because the left hand side of the shift is 1, which is of type
int, i.e. 31 bits wide. Shifting by more than that width results in
undefined behaviour.

Fix this by switching to the BIT() macro, which applies correct type
casting as required. This ensures the correct value is written to
UTRL_NEXUS_TYPE (0xffffffff on gs101), and it also fixes a UBSAN shift
warning:

    UBSAN: shift-out-of-bounds in drivers/ufs/host/ufs-exynos.c:1113:21
    shift exponent 32 is too large for 32-bit type 'int'

For consistency, apply the same change to the nutmrs / UTMRL_NEXUS_TYPE
write.</p>
                </div>
        
            </div>
        </div>

        <footer class="footer">
            <p>© 2025 dotne1 - Cybersecurity Portfolio</p>
        </footer>

        <script>
            function searchCVEs() {
                const input = document.getElementById('searchInput').value.toLowerCase();
                const cveEntries = document.getElementsByClassName('cve-entry');
                for (let i = 0; i < cveEntries.length; i++) {
                    const cveId = cveEntries[i].getAttribute('data-cve-id').toLowerCase();
                    const description = cveEntries[i].getAttribute('data-description');
                    if (cveId.includes(input) || description.includes(input)) {
                        cveEntries[i].style.display = '';
                    } else {
                        cveEntries[i].style.display = 'none';
                    }
                }
            }
        </script>
    </body>
    </html>
    