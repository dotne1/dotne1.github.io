
    <!DOCTYPE html>
    <html lang="en">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <meta name="description" content="Security alerts and cybersecurity news feeds">
        <meta name="keywords" content="cybersecurity news, security alerts, vulnerability feeds, threat intelligence">
        <meta name="author" content="dotne1">
        <meta property="og:title" content="Security Feeds - dotne1's Cybersecurity Portfolio">
        <meta property="og:description" content="Stay updated with the latest cybersecurity news and alerts">
        <meta property="og:type" content="website">
        <title>Security Feeds - dotne1's Cybersecurity Portfolio</title>
        <link rel="stylesheet" href="styles.css">
        <link rel="icon" type="image/x-icon" href="/favicon.ico">
    </head>
    <body>
        <nav class="navbar">
            <div class="nav-links">
                <a href="index.html" class="nav-link">Home</a>
                <a href="about-me.html" class="nav-link">About Me</a>
                <a href="projects.html" class="nav-link">Projects</a>
                <a href="resume.html" class="nav-link">Resume</a>
                <a href="feeds.html" class="nav-link">Feeds</a>
            </div>
        </nav>

        <div class="container" role="main">
            <h1 class="main-header">Security Feeds</h1>
            <div class="search-bar">
                <input type="text" id="searchInput" placeholder="Search CVEs..." onkeyup="searchCVEs()">
            </div>
            <div class="feed-preview" id="cveFeed">
                <div class="feed-header">Latest Vulnerabilities</div>
    
                <div class="cve-entry" data-cve-id="CVE-2025-14186" data-description="a security flaw has been discovered in grandstream gxp1625 1.0.7.4. the impacted element is an unknown function of the file /cgi-bin/api.values.post of the component network status page. performing manipulation of the argument vpn_ip results in basic cross site scripting. remote exploitation of the attack is possible. the exploit has been released to the public and may be exploited. the vendor was contacted early about this disclosure but did not respond in any way.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-14186" target="_blank">CVE-2025-14186</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-12-07 02:15:46 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">LOW</span></p>
                    <p><span class="feed-label">CVSS Score:</span> 3.5</p>
                    <p>A security flaw has been discovered in Grandstream GXP1625 1.0.7.4. The impacted element is an unknown function of the file /cgi-bin/api.values.post of the component Network Status Page. Performing manipulation of the argument vpn_ip results in basic cross site scripting. Remote exploitation of the attack is possible. The exploit has been released to the public and may be exploited. The vendor was contacted early about this disclosure but did not respond in any way.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-14185" data-description="a vulnerability was identified in yonyou u8 cloud 5.0/5.0sp/5.1/5.1sp. the affected element is an unknown function of the file nc/pubitf/erm/mobile/appservice/appservletservice.class. such manipulation of the argument usercode leads to sql injection. the attack may be launched remotely. the exploit is publicly available and might be used. the vendor was contacted early about this disclosure but did not respond in any way.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-14185" target="_blank">CVE-2025-14185</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-12-06 23:15:59 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">MEDIUM</span></p>
                    <p><span class="feed-label">CVSS Score:</span> 6.3</p>
                    <p>A vulnerability was identified in Yonyou U8 Cloud 5.0/5.0sp/5.1/5.1sp. The affected element is an unknown function of the file nc/pubitf/erm/mobile/appservice/AppServletService.class. Such manipulation of the argument usercode leads to sql injection. The attack may be launched remotely. The exploit is publicly available and might be used. The vendor was contacted early about this disclosure but did not respond in any way.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-14184" data-description="a vulnerability was determined in sgai space1 nas n1211ds up to 1.0.915. impacted is the function rename_file/operate_file/ngnix_upload of the file /cgi-bin/jsonapi of the component gsaiagent. this manipulation causes command injection. the attack may be initiated remotely. the exploit has been publicly disclosed and may be utilized. the vendor was contacted early about this disclosure but did not respond in any way.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-14184" target="_blank">CVE-2025-14184</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-12-06 23:15:49 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">MEDIUM</span></p>
                    <p><span class="feed-label">CVSS Score:</span> 6.3</p>
                    <p>A vulnerability was determined in SGAI Space1 NAS N1211DS up to 1.0.915. Impacted is the function RENAME_FILE/OPERATE_FILE/NGNIX_UPLOAD of the file /cgi-bin/JSONAPI of the component gsaiagent. This manipulation causes command injection. The attack may be initiated remotely. The exploit has been publicly disclosed and may be utilized. The vendor was contacted early about this disclosure but did not respond in any way.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-14183" data-description="a vulnerability was found in sgai space1 nas n1211ds up to 1.0.915. this issue affects the function get_factory_info/get_user_info of the file /cgi-bin/jsonapi of the component gsaiagent. the manipulation results in unprotected storage of credentials. the attack can be launched remotely. the exploit has been made public and could be used. the vendor was contacted early about this disclosure but did not respond in any way.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-14183" target="_blank">CVE-2025-14183</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-12-06 21:15:59 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">MEDIUM</span></p>
                    <p><span class="feed-label">CVSS Score:</span> 4.3</p>
                    <p>A vulnerability was found in SGAI Space1 NAS N1211DS up to 1.0.915. This issue affects the function GET_FACTORY_INFO/GET_USER_INFO of the file /cgi-bin/JSONAPI of the component gsaiagent. The manipulation results in unprotected storage of credentials. The attack can be launched remotely. The exploit has been made public and could be used. The vendor was contacted early about this disclosure but did not respond in any way.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-14182" data-description="a vulnerability has been found in sobey media convergence system 2.0/2.1. this vulnerability affects unknown code of the file /sobey-mcheditor/watermark/upload. the manipulation of the argument file leads to path traversal. the attack can be initiated remotely. the exploit has been disclosed to the public and may be used.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-14182" target="_blank">CVE-2025-14182</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-12-06 21:15:58 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">MEDIUM</span></p>
                    <p><span class="feed-label">CVSS Score:</span> 6.3</p>
                    <p>A vulnerability has been found in Sobey Media Convergence System 2.0/2.1. This vulnerability affects unknown code of the file /sobey-mchEditor/watermark/upload. The manipulation of the argument File leads to path traversal. The attack can be initiated remotely. The exploit has been disclosed to the public and may be used.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-40289" data-description="in the linux kernel, the following vulnerability has been resolved:

drm/amdgpu: hide vram sysfs attributes on gpus without vram

otherwise accessing them can cause a crash.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-40289" target="_blank">CVE-2025-40289</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-12-06 16:15:57 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">N/A</span></p>
                    <p><span class="feed-label">CVSS Score:</span> N/A</p>
                    <p>In the Linux kernel, the following vulnerability has been resolved:

drm/amdgpu: hide VRAM sysfs attributes on GPUs without VRAM

Otherwise accessing them can cause a crash.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-40288" data-description="in the linux kernel, the following vulnerability has been resolved:

drm/amdgpu: fix null pointer dereference in vram logic for apu devices

previously, apu platforms (and other scenarios with uninitialized vram managers)
triggered a null pointer dereference in `ttm_resource_manager_usage()`. the root
cause is not that the `struct ttm_resource_manager *man` pointer itself is null,
but that `man->bdev` (the backing device pointer within the manager) remains
uninitialized (null) on apus—since apus lack dedicated vram and do not fully
set up vram manager structures. when `ttm_resource_manager_usage()` attempts to
acquire `man->bdev->lru_lock`, it dereferences the null `man->bdev`, leading to
a kernel oops.

1. **amdgpu_cs.c**: extend the existing bandwidth control check in
   `amdgpu_cs_get_threshold_for_moves()` to include a check for
   `ttm_resource_manager_used()`. if the manager is not used (uninitialized
   `bdev`), return 0 for migration thresholds immediately—skipping vram-specific
   logic that would trigger the null dereference.

2. **amdgpu_kms.c**: update the `amdgpu_info_vram_usage` ioctl and memory info
   reporting to use a conditional: if the manager is used, return the real vram
   usage; otherwise, return 0. this avoids accessing `man->bdev` when it is
   null.

3. **amdgpu_virt.c**: modify the vf2pf (virtual function to physical function)
   data write path. use `ttm_resource_manager_used()` to check validity: if the
   manager is usable, calculate `fb_usage` from vram usage; otherwise, set
   `fb_usage` to 0 (apus have no discrete framebuffer to report).

this approach is more robust than apu-specific checks because it:
- works for all scenarios where the vram manager is uninitialized (not just apus),
- aligns with ttm's design by using its native helper function,
- preserves correct behavior for discrete gpus (which have fully initialized
  `man->bdev` and pass the `ttm_resource_manager_used()` check).

v4: use ttm_resource_manager_used(&adev->mman.vram_mgr.manager) instead of checking the adev->gmc.is_app_apu flag (christian)">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-40288" target="_blank">CVE-2025-40288</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-12-06 16:15:57 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">N/A</span></p>
                    <p><span class="feed-label">CVSS Score:</span> N/A</p>
                    <p>In the Linux kernel, the following vulnerability has been resolved:

drm/amdgpu: Fix NULL pointer dereference in VRAM logic for APU devices

Previously, APU platforms (and other scenarios with uninitialized VRAM managers)
triggered a NULL pointer dereference in `ttm_resource_manager_usage()`. The root
cause is not that the `struct ttm_resource_manager *man` pointer itself is NULL,
but that `man->bdev` (the backing device pointer within the manager) remains
uninitialized (NULL) on APUs—since APUs lack dedicated VRAM and do not fully
set up VRAM manager structures. When `ttm_resource_manager_usage()` attempts to
acquire `man->bdev->lru_lock`, it dereferences the NULL `man->bdev`, leading to
a kernel OOPS.

1. **amdgpu_cs.c**: Extend the existing bandwidth control check in
   `amdgpu_cs_get_threshold_for_moves()` to include a check for
   `ttm_resource_manager_used()`. If the manager is not used (uninitialized
   `bdev`), return 0 for migration thresholds immediately—skipping VRAM-specific
   logic that would trigger the NULL dereference.

2. **amdgpu_kms.c**: Update the `AMDGPU_INFO_VRAM_USAGE` ioctl and memory info
   reporting to use a conditional: if the manager is used, return the real VRAM
   usage; otherwise, return 0. This avoids accessing `man->bdev` when it is
   NULL.

3. **amdgpu_virt.c**: Modify the vf2pf (virtual function to physical function)
   data write path. Use `ttm_resource_manager_used()` to check validity: if the
   manager is usable, calculate `fb_usage` from VRAM usage; otherwise, set
   `fb_usage` to 0 (APUs have no discrete framebuffer to report).

This approach is more robust than APU-specific checks because it:
- Works for all scenarios where the VRAM manager is uninitialized (not just APUs),
- Aligns with TTM's design by using its native helper function,
- Preserves correct behavior for discrete GPUs (which have fully initialized
  `man->bdev` and pass the `ttm_resource_manager_used()` check).

v4: use ttm_resource_manager_used(&adev->mman.vram_mgr.manager) instead of checking the adev->gmc.is_app_apu flag (Christian)</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-40287" data-description="in the linux kernel, the following vulnerability has been resolved:

exfat: fix improper check of dentry.stream.valid_size

we found an infinite loop bug in the exfat file system that can lead to a
denial-of-service (dos) condition. when a dentry in an exfat filesystem is
malformed, the following system calls — sys_openat, sys_ftruncate, and
sys_pwrite64 — can cause the kernel to hang.

root cause analysis shows that the size validation code in exfat_find()
does not check whether dentry.stream.valid_size is negative. as a result,
the system calls mentioned above can succeed and eventually trigger the dos
issue.

this patch adds a check for negative dentry.stream.valid_size to prevent
this vulnerability.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-40287" target="_blank">CVE-2025-40287</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-12-06 16:15:56 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">N/A</span></p>
                    <p><span class="feed-label">CVSS Score:</span> N/A</p>
                    <p>In the Linux kernel, the following vulnerability has been resolved:

exfat: fix improper check of dentry.stream.valid_size

We found an infinite loop bug in the exFAT file system that can lead to a
Denial-of-Service (DoS) condition. When a dentry in an exFAT filesystem is
malformed, the following system calls — SYS_openat, SYS_ftruncate, and
SYS_pwrite64 — can cause the kernel to hang.

Root cause analysis shows that the size validation code in exfat_find()
does not check whether dentry.stream.valid_size is negative. As a result,
the system calls mentioned above can succeed and eventually trigger the DoS
issue.

This patch adds a check for negative dentry.stream.valid_size to prevent
this vulnerability.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-40286" data-description="in the linux kernel, the following vulnerability has been resolved:

smb/server: fix possible memory leak in smb2_read()

memory leak occurs when ksmbd_vfs_read() fails.
fix this by adding the missing kvfree().">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-40286" target="_blank">CVE-2025-40286</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-12-06 16:15:56 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">N/A</span></p>
                    <p><span class="feed-label">CVSS Score:</span> N/A</p>
                    <p>In the Linux kernel, the following vulnerability has been resolved:

smb/server: fix possible memory leak in smb2_read()

Memory leak occurs when ksmbd_vfs_read() fails.
Fix this by adding the missing kvfree().</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-40285" data-description="in the linux kernel, the following vulnerability has been resolved:

smb/server: fix possible refcount leak in smb2_sess_setup()

reference count of ksmbd_session will leak when session need reconnect.
fix this by adding the missing ksmbd_user_session_put().">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-40285" target="_blank">CVE-2025-40285</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-12-06 16:15:56 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">N/A</span></p>
                    <p><span class="feed-label">CVSS Score:</span> N/A</p>
                    <p>In the Linux kernel, the following vulnerability has been resolved:

smb/server: fix possible refcount leak in smb2_sess_setup()

Reference count of ksmbd_session will leak when session need reconnect.
Fix this by adding the missing ksmbd_user_session_put().</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-40284" data-description="in the linux kernel, the following vulnerability has been resolved:

bluetooth: mgmt: cancel mesh send timer when hdev removed

mesh_send_done timer is not canceled when hdev is removed, which causes
crash if the timer triggers after hdev is gone.

cancel the timer when mgmt removes the hdev, like other mgmt timers.

should fix the bug: sporadically seen by bluez test bot
(in "mesh - send cancel - 1" test).

log:
------
bug: kasan: slab-use-after-free in run_timer_softirq+0x76b/0x7d0
...
freed by task 36:
 kasan_save_stack+0x24/0x50
 kasan_save_track+0x14/0x30
 __kasan_save_free_info+0x3a/0x60
 __kasan_slab_free+0x43/0x70
 kfree+0x103/0x500
 device_release+0x9a/0x210
 kobject_put+0x100/0x1e0
 vhci_release+0x18b/0x240
------">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-40284" target="_blank">CVE-2025-40284</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-12-06 16:15:56 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">N/A</span></p>
                    <p><span class="feed-label">CVSS Score:</span> N/A</p>
                    <p>In the Linux kernel, the following vulnerability has been resolved:

Bluetooth: MGMT: cancel mesh send timer when hdev removed

mesh_send_done timer is not canceled when hdev is removed, which causes
crash if the timer triggers after hdev is gone.

Cancel the timer when MGMT removes the hdev, like other MGMT timers.

Should fix the BUG: sporadically seen by BlueZ test bot
(in "Mesh - Send cancel - 1" test).

Log:
------
BUG: KASAN: slab-use-after-free in run_timer_softirq+0x76b/0x7d0
...
Freed by task 36:
 kasan_save_stack+0x24/0x50
 kasan_save_track+0x14/0x30
 __kasan_save_free_info+0x3a/0x60
 __kasan_slab_free+0x43/0x70
 kfree+0x103/0x500
 device_release+0x9a/0x210
 kobject_put+0x100/0x1e0
 vhci_release+0x18b/0x240
------</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-40283" data-description="in the linux kernel, the following vulnerability has been resolved:

bluetooth: btusb: reorder cleanup in btusb_disconnect to avoid uaf

there is a kasan: slab-use-after-free read in btusb_disconnect().
calling "usb_driver_release_interface(&btusb_driver, data->intf)" will
free the btusb data associated with the interface. the same data is
then used later in the function, hence the uaf.

fix by moving the accesses to btusb data to before the data is free'd.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-40283" target="_blank">CVE-2025-40283</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-12-06 16:15:56 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">N/A</span></p>
                    <p><span class="feed-label">CVSS Score:</span> N/A</p>
                    <p>In the Linux kernel, the following vulnerability has been resolved:

Bluetooth: btusb: reorder cleanup in btusb_disconnect to avoid UAF

There is a KASAN: slab-use-after-free read in btusb_disconnect().
Calling "usb_driver_release_interface(&btusb_driver, data->intf)" will
free the btusb data associated with the interface. The same data is
then used later in the function, hence the UAF.

Fix by moving the accesses to btusb data to before the data is free'd.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-40282" data-description="in the linux kernel, the following vulnerability has been resolved:

bluetooth: 6lowpan: reset link-local header on ipv6 recv path

bluetooth 6lowpan.c netdev has header_ops, so it must set link-local
header for rx skb, otherwise things crash, eg. with af_packet sock_raw

add missing skb_reset_mac_header() for uncompressed ipv6 rx path.

for the compressed one, it is done in lowpan_header_decompress().

log: (bluez 6lowpan-tester client recv raw - success)
------
kernel bug at net/core/skbuff.c:212!
call trace:
<irq>
...
packet_rcv (net/packet/af_packet.c:2152)
...
<task>
__local_bh_enable_ip (kernel/softirq.c:407)
netif_rx (net/core/dev.c:5648)
chan_recv_cb (net/bluetooth/6lowpan.c:294 net/bluetooth/6lowpan.c:359)
------">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-40282" target="_blank">CVE-2025-40282</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-12-06 16:15:56 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">N/A</span></p>
                    <p><span class="feed-label">CVSS Score:</span> N/A</p>
                    <p>In the Linux kernel, the following vulnerability has been resolved:

Bluetooth: 6lowpan: reset link-local header on ipv6 recv path

Bluetooth 6lowpan.c netdev has header_ops, so it must set link-local
header for RX skb, otherwise things crash, eg. with AF_PACKET SOCK_RAW

Add missing skb_reset_mac_header() for uncompressed ipv6 RX path.

For the compressed one, it is done in lowpan_header_decompress().

Log: (BlueZ 6lowpan-tester Client Recv Raw - Success)
------
kernel BUG at net/core/skbuff.c:212!
Call Trace:
<IRQ>
...
packet_rcv (net/packet/af_packet.c:2152)
...
<TASK>
__local_bh_enable_ip (kernel/softirq.c:407)
netif_rx (net/core/dev.c:5648)
chan_recv_cb (net/bluetooth/6lowpan.c:294 net/bluetooth/6lowpan.c:359)
------</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-40281" data-description="in the linux kernel, the following vulnerability has been resolved:

sctp: prevent possible shift-out-of-bounds in sctp_transport_update_rto

syzbot reported a possible shift-out-of-bounds [1]

blamed commit added rto_alpha_max and rto_beta_max set to 1000.

it is unclear if some sctp users are setting very large rto_alpha
and/or rto_beta.

in order to prevent user regression, perform the test at run time.

also add read_once() annotations as sysctl values can change under us.

[1]

ubsan: shift-out-of-bounds in net/sctp/transport.c:509:41
shift exponent 64 is too large for 32-bit type 'unsigned int'
cpu: 0 uid: 0 pid: 16704 comm: syz.2.2320 not tainted syzkaller #0 preempt(full)
hardware name: google google compute engine/google compute engine, bios google 10/02/2025
call trace:
 <task>
  __dump_stack lib/dump_stack.c:94 [inline]
  dump_stack_lvl+0x16c/0x1f0 lib/dump_stack.c:120
  ubsan_epilogue lib/ubsan.c:233 [inline]
  __ubsan_handle_shift_out_of_bounds+0x27f/0x420 lib/ubsan.c:494
  sctp_transport_update_rto.cold+0x1c/0x34b net/sctp/transport.c:509
  sctp_check_transmitted+0x11c4/0x1c30 net/sctp/outqueue.c:1502
  sctp_outq_sack+0x4ef/0x1b20 net/sctp/outqueue.c:1338
  sctp_cmd_process_sack net/sctp/sm_sideeffect.c:840 [inline]
  sctp_cmd_interpreter net/sctp/sm_sideeffect.c:1372 [inline]">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-40281" target="_blank">CVE-2025-40281</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-12-06 16:15:56 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">N/A</span></p>
                    <p><span class="feed-label">CVSS Score:</span> N/A</p>
                    <p>In the Linux kernel, the following vulnerability has been resolved:

sctp: prevent possible shift-out-of-bounds in sctp_transport_update_rto

syzbot reported a possible shift-out-of-bounds [1]

Blamed commit added rto_alpha_max and rto_beta_max set to 1000.

It is unclear if some sctp users are setting very large rto_alpha
and/or rto_beta.

In order to prevent user regression, perform the test at run time.

Also add READ_ONCE() annotations as sysctl values can change under us.

[1]

UBSAN: shift-out-of-bounds in net/sctp/transport.c:509:41
shift exponent 64 is too large for 32-bit type 'unsigned int'
CPU: 0 UID: 0 PID: 16704 Comm: syz.2.2320 Not tainted syzkaller #0 PREEMPT(full)
Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 10/02/2025
Call Trace:
 <TASK>
  __dump_stack lib/dump_stack.c:94 [inline]
  dump_stack_lvl+0x16c/0x1f0 lib/dump_stack.c:120
  ubsan_epilogue lib/ubsan.c:233 [inline]
  __ubsan_handle_shift_out_of_bounds+0x27f/0x420 lib/ubsan.c:494
  sctp_transport_update_rto.cold+0x1c/0x34b net/sctp/transport.c:509
  sctp_check_transmitted+0x11c4/0x1c30 net/sctp/outqueue.c:1502
  sctp_outq_sack+0x4ef/0x1b20 net/sctp/outqueue.c:1338
  sctp_cmd_process_sack net/sctp/sm_sideeffect.c:840 [inline]
  sctp_cmd_interpreter net/sctp/sm_sideeffect.c:1372 [inline]</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-40280" data-description="in the linux kernel, the following vulnerability has been resolved:

tipc: fix use-after-free in tipc_mon_reinit_self().

syzbot reported use-after-free of tipc_net(net)->monitors[]
in tipc_mon_reinit_self(). [0]

the array is protected by rtnl, but tipc_mon_reinit_self()
iterates over it without rtnl.

tipc_mon_reinit_self() is called from tipc_net_finalize(),
which is always under rtnl except for tipc_net_finalize_work().

let's hold rtnl in tipc_net_finalize_work().

[0]:
bug: kasan: slab-use-after-free in __raw_spin_lock_irqsave include/linux/spinlock_api_smp.h:110 [inline]
bug: kasan: slab-use-after-free in _raw_spin_lock_irqsave+0xa7/0xf0 kernel/locking/spinlock.c:162
read of size 1 at addr ffff88805eae1030 by task kworker/0:7/5989

cpu: 0 uid: 0 pid: 5989 comm: kworker/0:7 not tainted syzkaller #0 preempt_{rt,(full)}
hardware name: google google compute engine/google compute engine, bios google 08/18/2025
workqueue: events tipc_net_finalize_work
call trace:
 <task>
 dump_stack_lvl+0x189/0x250 lib/dump_stack.c:120
 print_address_description mm/kasan/report.c:378 [inline]
 print_report+0xca/0x240 mm/kasan/report.c:482
 kasan_report+0x118/0x150 mm/kasan/report.c:595
 __kasan_check_byte+0x2a/0x40 mm/kasan/common.c:568
 kasan_check_byte include/linux/kasan.h:399 [inline]
 lock_acquire+0x8d/0x360 kernel/locking/lockdep.c:5842
 __raw_spin_lock_irqsave include/linux/spinlock_api_smp.h:110 [inline]
 _raw_spin_lock_irqsave+0xa7/0xf0 kernel/locking/spinlock.c:162
 rtlock_slowlock kernel/locking/rtmutex.c:1894 [inline]
 rwbase_rtmutex_lock_state kernel/locking/spinlock_rt.c:160 [inline]
 rwbase_write_lock+0xd3/0x7e0 kernel/locking/rwbase_rt.c:244
 rt_write_lock+0x76/0x110 kernel/locking/spinlock_rt.c:243
 write_lock_bh include/linux/rwlock_rt.h:99 [inline]
 tipc_mon_reinit_self+0x79/0x430 net/tipc/monitor.c:718
 tipc_net_finalize+0x115/0x190 net/tipc/net.c:140
 process_one_work kernel/workqueue.c:3236 [inline]
 process_scheduled_works+0xade/0x17b0 kernel/workqueue.c:3319
 worker_thread+0x8a0/0xda0 kernel/workqueue.c:3400
 kthread+0x70e/0x8a0 kernel/kthread.c:463
 ret_from_fork+0x439/0x7d0 arch/x86/kernel/process.c:148
 ret_from_fork_asm+0x1a/0x30 arch/x86/entry/entry_64.s:245
 </task>

allocated by task 6089:
 kasan_save_stack mm/kasan/common.c:47 [inline]
 kasan_save_track+0x3e/0x80 mm/kasan/common.c:68
 poison_kmalloc_redzone mm/kasan/common.c:388 [inline]
 __kasan_kmalloc+0x93/0xb0 mm/kasan/common.c:405
 kasan_kmalloc include/linux/kasan.h:260 [inline]
 __kmalloc_cache_noprof+0x1a8/0x320 mm/slub.c:4407
 kmalloc_noprof include/linux/slab.h:905 [inline]
 kzalloc_noprof include/linux/slab.h:1039 [inline]
 tipc_mon_create+0xc3/0x4d0 net/tipc/monitor.c:657
 tipc_enable_bearer net/tipc/bearer.c:357 [inline]
 __tipc_nl_bearer_enable+0xe16/0x13f0 net/tipc/bearer.c:1047
 __tipc_nl_compat_doit net/tipc/netlink_compat.c:371 [inline]
 tipc_nl_compat_doit+0x3bc/0x5f0 net/tipc/netlink_compat.c:393
 tipc_nl_compat_handle net/tipc/netlink_compat.c:-1 [inline]
 tipc_nl_compat_recv+0x83c/0xbe0 net/tipc/netlink_compat.c:1321
 genl_family_rcv_msg_doit+0x215/0x300 net/netlink/genetlink.c:1115
 genl_family_rcv_msg net/netlink/genetlink.c:1195 [inline]
 genl_rcv_msg+0x60e/0x790 net/netlink/genetlink.c:1210
 netlink_rcv_skb+0x208/0x470 net/netlink/af_netlink.c:2552
 genl_rcv+0x28/0x40 net/netlink/genetlink.c:1219
 netlink_unicast_kernel net/netlink/af_netlink.c:1320 [inline]
 netlink_unicast+0x846/0xa10 net/netlink/af_netlink.c:1346
 netlink_sendmsg+0x805/0xb30 net/netlink/af_netlink.c:1896
 sock_sendmsg_nosec net/socket.c:714 [inline]
 __sock_sendmsg+0x21c/0x270 net/socket.c:729
 ____sys_sendmsg+0x508/0x820 net/socket.c:2614
 ___sys_sendmsg+0x21f/0x2a0 net/socket.c:2668
 __sys_sendmsg net/socket.c:2700 [inline]
 __do_sys_sendmsg net/socket.c:2705 [inline]
 __se_sys_sendmsg net/socket.c:2703 [inline]
 __x64_sys_sendmsg+0x1a1/0x260 net/socket.c:2703
 do_syscall_x64 arch/x86/entry/syscall_64.c:63 [inline]
 do_syscall_64+0xfa/0x3b0 arch/
---truncated---">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-40280" target="_blank">CVE-2025-40280</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-12-06 16:15:55 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">N/A</span></p>
                    <p><span class="feed-label">CVSS Score:</span> N/A</p>
                    <p>In the Linux kernel, the following vulnerability has been resolved:

tipc: Fix use-after-free in tipc_mon_reinit_self().

syzbot reported use-after-free of tipc_net(net)->monitors[]
in tipc_mon_reinit_self(). [0]

The array is protected by RTNL, but tipc_mon_reinit_self()
iterates over it without RTNL.

tipc_mon_reinit_self() is called from tipc_net_finalize(),
which is always under RTNL except for tipc_net_finalize_work().

Let's hold RTNL in tipc_net_finalize_work().

[0]:
BUG: KASAN: slab-use-after-free in __raw_spin_lock_irqsave include/linux/spinlock_api_smp.h:110 [inline]
BUG: KASAN: slab-use-after-free in _raw_spin_lock_irqsave+0xa7/0xf0 kernel/locking/spinlock.c:162
Read of size 1 at addr ffff88805eae1030 by task kworker/0:7/5989

CPU: 0 UID: 0 PID: 5989 Comm: kworker/0:7 Not tainted syzkaller #0 PREEMPT_{RT,(full)}
Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 08/18/2025
Workqueue: events tipc_net_finalize_work
Call Trace:
 <TASK>
 dump_stack_lvl+0x189/0x250 lib/dump_stack.c:120
 print_address_description mm/kasan/report.c:378 [inline]
 print_report+0xca/0x240 mm/kasan/report.c:482
 kasan_report+0x118/0x150 mm/kasan/report.c:595
 __kasan_check_byte+0x2a/0x40 mm/kasan/common.c:568
 kasan_check_byte include/linux/kasan.h:399 [inline]
 lock_acquire+0x8d/0x360 kernel/locking/lockdep.c:5842
 __raw_spin_lock_irqsave include/linux/spinlock_api_smp.h:110 [inline]
 _raw_spin_lock_irqsave+0xa7/0xf0 kernel/locking/spinlock.c:162
 rtlock_slowlock kernel/locking/rtmutex.c:1894 [inline]
 rwbase_rtmutex_lock_state kernel/locking/spinlock_rt.c:160 [inline]
 rwbase_write_lock+0xd3/0x7e0 kernel/locking/rwbase_rt.c:244
 rt_write_lock+0x76/0x110 kernel/locking/spinlock_rt.c:243
 write_lock_bh include/linux/rwlock_rt.h:99 [inline]
 tipc_mon_reinit_self+0x79/0x430 net/tipc/monitor.c:718
 tipc_net_finalize+0x115/0x190 net/tipc/net.c:140
 process_one_work kernel/workqueue.c:3236 [inline]
 process_scheduled_works+0xade/0x17b0 kernel/workqueue.c:3319
 worker_thread+0x8a0/0xda0 kernel/workqueue.c:3400
 kthread+0x70e/0x8a0 kernel/kthread.c:463
 ret_from_fork+0x439/0x7d0 arch/x86/kernel/process.c:148
 ret_from_fork_asm+0x1a/0x30 arch/x86/entry/entry_64.S:245
 </TASK>

Allocated by task 6089:
 kasan_save_stack mm/kasan/common.c:47 [inline]
 kasan_save_track+0x3e/0x80 mm/kasan/common.c:68
 poison_kmalloc_redzone mm/kasan/common.c:388 [inline]
 __kasan_kmalloc+0x93/0xb0 mm/kasan/common.c:405
 kasan_kmalloc include/linux/kasan.h:260 [inline]
 __kmalloc_cache_noprof+0x1a8/0x320 mm/slub.c:4407
 kmalloc_noprof include/linux/slab.h:905 [inline]
 kzalloc_noprof include/linux/slab.h:1039 [inline]
 tipc_mon_create+0xc3/0x4d0 net/tipc/monitor.c:657
 tipc_enable_bearer net/tipc/bearer.c:357 [inline]
 __tipc_nl_bearer_enable+0xe16/0x13f0 net/tipc/bearer.c:1047
 __tipc_nl_compat_doit net/tipc/netlink_compat.c:371 [inline]
 tipc_nl_compat_doit+0x3bc/0x5f0 net/tipc/netlink_compat.c:393
 tipc_nl_compat_handle net/tipc/netlink_compat.c:-1 [inline]
 tipc_nl_compat_recv+0x83c/0xbe0 net/tipc/netlink_compat.c:1321
 genl_family_rcv_msg_doit+0x215/0x300 net/netlink/genetlink.c:1115
 genl_family_rcv_msg net/netlink/genetlink.c:1195 [inline]
 genl_rcv_msg+0x60e/0x790 net/netlink/genetlink.c:1210
 netlink_rcv_skb+0x208/0x470 net/netlink/af_netlink.c:2552
 genl_rcv+0x28/0x40 net/netlink/genetlink.c:1219
 netlink_unicast_kernel net/netlink/af_netlink.c:1320 [inline]
 netlink_unicast+0x846/0xa10 net/netlink/af_netlink.c:1346
 netlink_sendmsg+0x805/0xb30 net/netlink/af_netlink.c:1896
 sock_sendmsg_nosec net/socket.c:714 [inline]
 __sock_sendmsg+0x21c/0x270 net/socket.c:729
 ____sys_sendmsg+0x508/0x820 net/socket.c:2614
 ___sys_sendmsg+0x21f/0x2a0 net/socket.c:2668
 __sys_sendmsg net/socket.c:2700 [inline]
 __do_sys_sendmsg net/socket.c:2705 [inline]
 __se_sys_sendmsg net/socket.c:2703 [inline]
 __x64_sys_sendmsg+0x1a1/0x260 net/socket.c:2703
 do_syscall_x64 arch/x86/entry/syscall_64.c:63 [inline]
 do_syscall_64+0xfa/0x3b0 arch/
---truncated---</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-40279" data-description="in the linux kernel, the following vulnerability has been resolved:

net: sched: act_connmark: initialize struct tc_ife to fix kernel leak

in tcf_connmark_dump(), the variable 'opt' was partially initialized using a
designatied initializer. while the padding bytes are reamined
uninitialized. nla_put() copies the entire structure into a
netlink message, these uninitialized bytes leaked to userspace.

initialize the structure with memset before assigning its fields
to ensure all members and padding are cleared prior to beign copied.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-40279" target="_blank">CVE-2025-40279</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-12-06 16:15:55 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">N/A</span></p>
                    <p><span class="feed-label">CVSS Score:</span> N/A</p>
                    <p>In the Linux kernel, the following vulnerability has been resolved:

net: sched: act_connmark: initialize struct tc_ife to fix kernel leak

In tcf_connmark_dump(), the variable 'opt' was partially initialized using a
designatied initializer. While the padding bytes are reamined
uninitialized. nla_put() copies the entire structure into a
netlink message, these uninitialized bytes leaked to userspace.

Initialize the structure with memset before assigning its fields
to ensure all members and padding are cleared prior to beign copied.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-40278" data-description="in the linux kernel, the following vulnerability has been resolved:

net: sched: act_ife: initialize struct tc_ife to fix kmsan kernel-infoleak

fix a kmsan kernel-infoleak detected  by the syzbot .

[net?] kmsan: kernel-infoleak in __skb_datagram_iter

in tcf_ife_dump(), the variable 'opt' was partially initialized using a
designatied initializer. while the padding bytes are reamined
uninitialized. nla_put() copies the entire structure into a
netlink message, these uninitialized bytes leaked to userspace.

initialize the structure with memset before assigning its fields
to ensure all members and padding are cleared prior to beign copied.

this change silences the kmsan report and prevents potential information
leaks from the kernel memory.

this fix has been tested and validated by syzbot. this patch closes the
bug reported at the following syzkaller link and ensures no infoleak.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-40278" target="_blank">CVE-2025-40278</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-12-06 16:15:55 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">N/A</span></p>
                    <p><span class="feed-label">CVSS Score:</span> N/A</p>
                    <p>In the Linux kernel, the following vulnerability has been resolved:

net: sched: act_ife: initialize struct tc_ife to fix KMSAN kernel-infoleak

Fix a KMSAN kernel-infoleak detected  by the syzbot .

[net?] KMSAN: kernel-infoleak in __skb_datagram_iter

In tcf_ife_dump(), the variable 'opt' was partially initialized using a
designatied initializer. While the padding bytes are reamined
uninitialized. nla_put() copies the entire structure into a
netlink message, these uninitialized bytes leaked to userspace.

Initialize the structure with memset before assigning its fields
to ensure all members and padding are cleared prior to beign copied.

This change silences the KMSAN report and prevents potential information
leaks from the kernel memory.

This fix has been tested and validated by syzbot. This patch closes the
bug reported at the following syzkaller link and ensures no infoleak.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-40277" data-description="in the linux kernel, the following vulnerability has been resolved:

drm/vmwgfx: validate command header size against svga_cmd_max_datasize

this data originates from userspace and is used in buffer offset
calculations which could potentially overflow causing an out-of-bounds
access.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-40277" target="_blank">CVE-2025-40277</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-12-06 16:15:55 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">N/A</span></p>
                    <p><span class="feed-label">CVSS Score:</span> N/A</p>
                    <p>In the Linux kernel, the following vulnerability has been resolved:

drm/vmwgfx: Validate command header size against SVGA_CMD_MAX_DATASIZE

This data originates from userspace and is used in buffer offset
calculations which could potentially overflow causing an out-of-bounds
access.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-40276" data-description="in the linux kernel, the following vulnerability has been resolved:

drm/panthor: flush shmem writes before mapping buffers cpu-uncached

the shmem layer zeroes out the new pages using cached mappings, and if
we don't cpu-flush we might leave dirty cachelines behind, leading to
potential data leaks and/or asynchronous buffer corruption when dirty
cachelines are evicted.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-40276" target="_blank">CVE-2025-40276</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-12-06 16:15:55 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">N/A</span></p>
                    <p><span class="feed-label">CVSS Score:</span> N/A</p>
                    <p>In the Linux kernel, the following vulnerability has been resolved:

drm/panthor: Flush shmem writes before mapping buffers CPU-uncached

The shmem layer zeroes out the new pages using cached mappings, and if
we don't CPU-flush we might leave dirty cachelines behind, leading to
potential data leaks and/or asynchronous buffer corruption when dirty
cachelines are evicted.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-40275" data-description="in the linux kernel, the following vulnerability has been resolved:

alsa: usb-audio: fix null pointer dereference in snd_usb_mixer_controls_badd

in snd_usb_create_streams(), for uac version 3 devices, the interface
association descriptor (iad) is retrieved via usb_ifnum_to_if(). if this
call fails, a fallback routine attempts to obtain the iad from the next
interface and sets a badd profile. however, snd_usb_mixer_controls_badd()
assumes that the iad retrieved from usb_ifnum_to_if() is always valid,
without performing a null check. this can lead to a null pointer
dereference when usb_ifnum_to_if() fails to find the interface descriptor.

this patch adds a null pointer check after calling usb_ifnum_to_if() in
snd_usb_mixer_controls_badd() to prevent the dereference.

this issue was discovered by syzkaller, which triggered the bug by sending
a crafted usb device descriptor.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-40275" target="_blank">CVE-2025-40275</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-12-06 16:15:55 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">N/A</span></p>
                    <p><span class="feed-label">CVSS Score:</span> N/A</p>
                    <p>In the Linux kernel, the following vulnerability has been resolved:

ALSA: usb-audio: Fix NULL pointer dereference in snd_usb_mixer_controls_badd

In snd_usb_create_streams(), for UAC version 3 devices, the Interface
Association Descriptor (IAD) is retrieved via usb_ifnum_to_if(). If this
call fails, a fallback routine attempts to obtain the IAD from the next
interface and sets a BADD profile. However, snd_usb_mixer_controls_badd()
assumes that the IAD retrieved from usb_ifnum_to_if() is always valid,
without performing a NULL check. This can lead to a NULL pointer
dereference when usb_ifnum_to_if() fails to find the interface descriptor.

This patch adds a NULL pointer check after calling usb_ifnum_to_if() in
snd_usb_mixer_controls_badd() to prevent the dereference.

This issue was discovered by syzkaller, which triggered the bug by sending
a crafted USB device descriptor.</p>
                </div>
        
            </div>
        </div>

        <footer class="footer">
            <p>© 2025 dotne1 - Cybersecurity Portfolio</p>
        </footer>

        <script>
            function searchCVEs() {
                const input = document.getElementById('searchInput').value.toLowerCase();
                const cveEntries = document.getElementsByClassName('cve-entry');
                for (let i = 0; i < cveEntries.length; i++) {
                    const cveId = cveEntries[i].getAttribute('data-cve-id').toLowerCase();
                    const description = cveEntries[i].getAttribute('data-description');
                    if (cveId.includes(input) || description.includes(input)) {
                        cveEntries[i].style.display = '';
                    } else {
                        cveEntries[i].style.display = 'none';
                    }
                }
            }
        </script>
    </body>
    </html>
    