
    <!DOCTYPE html>
    <html lang="en">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <meta name="description" content="Security alerts and cybersecurity news feeds">
        <meta name="keywords" content="cybersecurity news, security alerts, vulnerability feeds, threat intelligence">
        <meta name="author" content="dotne1">
        <meta property="og:title" content="Security Feeds - dotne1's Cybersecurity Portfolio">
        <meta property="og:description" content="Stay updated with the latest cybersecurity news and alerts">
        <meta property="og:type" content="website">
        <title>Security Feeds - dotne1's Cybersecurity Portfolio</title>
        <link rel="stylesheet" href="styles.css">
        <link rel="icon" type="image/x-icon" href="/favicon.ico">
    </head>
    <body>
        <nav class="navbar">
            <div class="nav-links">
                <a href="index.html" class="nav-link">Home</a>
                <a href="about-me.html" class="nav-link">About Me</a>
                <a href="projects.html" class="nav-link">Projects</a>
                <a href="resume.html" class="nav-link">Resume</a>
                <a href="feeds.html" class="nav-link">Feeds</a>
            </div>
        </nav>

        <div class="container" role="main">
            <h1 class="main-header">Security Feeds</h1>
            <div class="search-bar">
                <input type="text" id="searchInput" placeholder="Search CVEs..." onkeyup="searchCVEs()">
            </div>
            <div class="feed-preview" id="cveFeed">
                <div class="feed-header">Latest Vulnerabilities</div>
    
                <div class="cve-entry" data-cve-id="CVE-2025-8160" data-description="a vulnerability classified as critical has been found in tenda ac20 up to 16.03.08.12. affected is an unknown function of the file /goform/setsystimecfg of the component httpd. the manipulation of the argument timezone leads to buffer overflow. it is possible to launch the attack remotely. the exploit has been disclosed to the public and may be used.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-8160" target="_blank">CVE-2025-8160</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-07-25 10:15:30 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-online">HIGH</span></p>
                    <p><span class="feed-label">CVSS Score:</span> 8.8</p>
                    <p>A vulnerability classified as critical has been found in Tenda AC20 up to 16.03.08.12. Affected is an unknown function of the file /goform/SetSysTimeCfg of the component httpd. The manipulation of the argument timeZone leads to buffer overflow. It is possible to launch the attack remotely. The exploit has been disclosed to the public and may be used.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-8159" data-description="a vulnerability was found in d-link dir-513 1.0. it has been rated as critical. this issue affects the function formlanguagechange of the file /goform/formlanguagechange of the component http post request handler. the manipulation of the argument curtime leads to stack-based buffer overflow. the attack may be initiated remotely. the exploit has been disclosed to the public and may be used. this vulnerability only affects products that are no longer supported by the maintainer.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-8159" target="_blank">CVE-2025-8159</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-07-25 10:15:30 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-online">HIGH</span></p>
                    <p><span class="feed-label">CVSS Score:</span> 8.8</p>
                    <p>A vulnerability was found in D-Link DIR-513 1.0. It has been rated as critical. This issue affects the function formLanguageChange of the file /goform/formLanguageChange of the component HTTP POST Request Handler. The manipulation of the argument curTime leads to stack-based buffer overflow. The attack may be initiated remotely. The exploit has been disclosed to the public and may be used. This vulnerability only affects products that are no longer supported by the maintainer.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-52360" data-description="a cross-site scripting (xss) vulnerability exists in the opac search feature of koha library management system v24.05. unsanitized input entered in the search field is reflected in the search history interface, leading to the execution of arbitrary javascript in the browser context when the user interacts with the interface.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-52360" target="_blank">CVE-2025-52360</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-07-25 10:15:29 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-online">HIGH</span></p>
                    <p><span class="feed-label">CVSS Score:</span> 8.8</p>
                    <p>A Cross-Site Scripting (XSS) vulnerability exists in the OPAC search feature of Koha Library Management System v24.05. Unsanitized input entered in the search field is reflected in the search history interface, leading to the execution of arbitrary JavaScript in the browser context when the user interacts with the interface.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-45467" data-description="unitree go1 <= go1_2022_05_11 is vulnerable to insecure permissions as the firmware update functionality (via wi-fi/ethernet) implements an insecure verification mechanism that solely relies on md5 checksums for firmware integrity validation.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-45467" target="_blank">CVE-2025-45467</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-07-25 10:15:29 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">N/A</span></p>
                    <p><span class="feed-label">CVSS Score:</span> N/A</p>
                    <p>Unitree Go1 <= Go1_2022_05_11 is vulnerable to Insecure Permissions as the firmware update functionality (via Wi-Fi/Ethernet) implements an insecure verification mechanism that solely relies on MD5 checksums for firmware integrity validation.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-44608" data-description="cloudclassroom-php project v1.0 was discovered to contain a sql injection vulnerability via the viewid parameter.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-44608" target="_blank">CVE-2025-44608</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-07-25 10:15:29 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">N/A</span></p>
                    <p><span class="feed-label">CVSS Score:</span> N/A</p>
                    <p>CloudClassroom-PHP Project v1.0 was discovered to contain a SQL injection vulnerability via the viewid parameter.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-38436" data-description="in the linux kernel, the following vulnerability has been resolved:

drm/scheduler: signal scheduled fence when kill job

when an entity from application b is killed, drm_sched_entity_kill()
removes all jobs belonging to that entity through
drm_sched_entity_kill_jobs_work(). if application a's job depends on a
scheduled fence from application b's job, and that fence is not properly
signaled during the killing process, application a's dependency cannot be
cleared.

this leads to application a hanging indefinitely while waiting for a
dependency that will never be resolved. fix this issue by ensuring that
scheduled fences are properly signaled when an entity is killed, allowing
dependent applications to continue execution.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-38436" target="_blank">CVE-2025-38436</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-07-25 10:15:29 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">N/A</span></p>
                    <p><span class="feed-label">CVSS Score:</span> N/A</p>
                    <p>In the Linux kernel, the following vulnerability has been resolved:

drm/scheduler: signal scheduled fence when kill job

When an entity from application B is killed, drm_sched_entity_kill()
removes all jobs belonging to that entity through
drm_sched_entity_kill_jobs_work(). If application A's job depends on a
scheduled fence from application B's job, and that fence is not properly
signaled during the killing process, application A's dependency cannot be
cleared.

This leads to application A hanging indefinitely while waiting for a
dependency that will never be resolved. Fix this issue by ensuring that
scheduled fences are properly signaled when an entity is killed, allowing
dependent applications to continue execution.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-38435" data-description="in the linux kernel, the following vulnerability has been resolved:

riscv: vector: fix context save/restore with xtheadvector

previously only v0-v7 were correctly saved/restored,
and the context of v8-v31 are damanged.
correctly save/restore v8-v31 to avoid breaking userspace.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-38435" target="_blank">CVE-2025-38435</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-07-25 10:15:28 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">N/A</span></p>
                    <p><span class="feed-label">CVSS Score:</span> N/A</p>
                    <p>In the Linux kernel, the following vulnerability has been resolved:

riscv: vector: Fix context save/restore with xtheadvector

Previously only v0-v7 were correctly saved/restored,
and the context of v8-v31 are damanged.
Correctly save/restore v8-v31 to avoid breaking userspace.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-38434" data-description="in the linux kernel, the following vulnerability has been resolved:

revert "riscv: define task_size_max for __access_ok()"

this reverts commit ad5643cf2f69 ("riscv: define task_size_max for
__access_ok()").

this commit changes task_size_max to be long_max to optimize access_ok(),
because the previous task_size_max (default to task_size) requires some
computation.

the reasoning was that all user addresses are less than long_max, and all
kernel addresses are greater than long_max. therefore access_ok() can
filter kernel addresses.

addresses between task_size and long_max are not valid user addresses, but
access_ok() let them pass. that was thought to be okay, because they are
not valid addresses at hardware level.

unfortunately, one case is missed: get_user_pages_fast() happily accepts
addresses between task_size and long_max. futex(), for instance, uses
get_user_pages_fast(). this causes the problem reported by robert [1].

therefore, revert this commit. task_size_max is changed to the default:
task_size.

this unfortunately reduces performance, because task_size is more expensive
to compute compared to long_max. but correctness first, we can think about
optimization later, if required.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-38434" target="_blank">CVE-2025-38434</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-07-25 10:15:28 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">N/A</span></p>
                    <p><span class="feed-label">CVSS Score:</span> N/A</p>
                    <p>In the Linux kernel, the following vulnerability has been resolved:

Revert "riscv: Define TASK_SIZE_MAX for __access_ok()"

This reverts commit ad5643cf2f69 ("riscv: Define TASK_SIZE_MAX for
__access_ok()").

This commit changes TASK_SIZE_MAX to be LONG_MAX to optimize access_ok(),
because the previous TASK_SIZE_MAX (default to TASK_SIZE) requires some
computation.

The reasoning was that all user addresses are less than LONG_MAX, and all
kernel addresses are greater than LONG_MAX. Therefore access_ok() can
filter kernel addresses.

Addresses between TASK_SIZE and LONG_MAX are not valid user addresses, but
access_ok() let them pass. That was thought to be okay, because they are
not valid addresses at hardware level.

Unfortunately, one case is missed: get_user_pages_fast() happily accepts
addresses between TASK_SIZE and LONG_MAX. futex(), for instance, uses
get_user_pages_fast(). This causes the problem reported by Robert [1].

Therefore, revert this commit. TASK_SIZE_MAX is changed to the default:
TASK_SIZE.

This unfortunately reduces performance, because TASK_SIZE is more expensive
to compute compared to LONG_MAX. But correctness first, we can think about
optimization later, if required.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-38433" data-description="in the linux kernel, the following vulnerability has been resolved:

riscv: fix runtime constant support for nommu kernels

the `__runtime_fixup_32` function does not handle the case where `val` is
zero correctly (as might occur when patching a nommu kernel and referring
to a physical address below the 4gib boundary whose upper 32 bits are all
zero) because nothing in the existing logic prevents the code from taking
the `else` branch of both nop-checks and emitting two `nop` instructions.

this leaves random garbage in the register that is supposed to receive the
upper 32 bits of the pointer instead of zero that when combined with the
value for the lower 32 bits yields an invalid pointer and causes a kernel
panic when that pointer is eventually accessed.

the author clearly considered the fact that if the `lui` is converted into
a `nop` that the second instruction needs to be adjusted to become an `li`
instead of an `addi`, hence introducing the `addi_insn_mask` variable, but
didn't follow that logic through fully to the case where the `else` branch
executes. to fix it just adjust the logic to ensure that the second `else`
branch is not taken if the first instruction will be patched to a `nop`.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-38433" target="_blank">CVE-2025-38433</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-07-25 10:15:28 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">N/A</span></p>
                    <p><span class="feed-label">CVSS Score:</span> N/A</p>
                    <p>In the Linux kernel, the following vulnerability has been resolved:

riscv: fix runtime constant support for nommu kernels

the `__runtime_fixup_32` function does not handle the case where `val` is
zero correctly (as might occur when patching a nommu kernel and referring
to a physical address below the 4GiB boundary whose upper 32 bits are all
zero) because nothing in the existing logic prevents the code from taking
the `else` branch of both nop-checks and emitting two `nop` instructions.

This leaves random garbage in the register that is supposed to receive the
upper 32 bits of the pointer instead of zero that when combined with the
value for the lower 32 bits yields an invalid pointer and causes a kernel
panic when that pointer is eventually accessed.

The author clearly considered the fact that if the `lui` is converted into
a `nop` that the second instruction needs to be adjusted to become an `li`
instead of an `addi`, hence introducing the `addi_insn_mask` variable, but
didn't follow that logic through fully to the case where the `else` branch
executes. To fix it just adjust the logic to ensure that the second `else`
branch is not taken if the first instruction will be patched to a `nop`.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-38432" data-description="in the linux kernel, the following vulnerability has been resolved:

net: netpoll: initialize udp checksum field before checksumming

commit f1fce08e63fe ("netpoll: eliminate redundant assignment") removed
the initialization of the udp checksum, which was wrong and broke
netpoll ipv6 transmission due to bad checksumming.

udph->check needs to be set before calling csum_ipv6_magic().">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-38432" target="_blank">CVE-2025-38432</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-07-25 10:15:28 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">N/A</span></p>
                    <p><span class="feed-label">CVSS Score:</span> N/A</p>
                    <p>In the Linux kernel, the following vulnerability has been resolved:

net: netpoll: Initialize UDP checksum field before checksumming

commit f1fce08e63fe ("netpoll: Eliminate redundant assignment") removed
the initialization of the UDP checksum, which was wrong and broke
netpoll IPv6 transmission due to bad checksumming.

udph->check needs to be set before calling csum_ipv6_magic().</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-38431" data-description="in the linux kernel, the following vulnerability has been resolved:

smb: client: fix regression with native smb symlinks

some users and customers reported that their backup/copy tools started
to fail when the directory being copied contained symlink targets that
the client couldn't parse - even when those symlinks weren't followed.

fix this by allowing lstat(2) and readlink(2) to succeed even when the
client can't resolve the symlink target, restoring old behavior.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-38431" target="_blank">CVE-2025-38431</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-07-25 10:15:28 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">N/A</span></p>
                    <p><span class="feed-label">CVSS Score:</span> N/A</p>
                    <p>In the Linux kernel, the following vulnerability has been resolved:

smb: client: fix regression with native SMB symlinks

Some users and customers reported that their backup/copy tools started
to fail when the directory being copied contained symlink targets that
the client couldn't parse - even when those symlinks weren't followed.

Fix this by allowing lstat(2) and readlink(2) to succeed even when the
client can't resolve the symlink target, restoring old behavior.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-38430" data-description="in the linux kernel, the following vulnerability has been resolved:

nfsd: nfsd4_spo_must_allow() must check this is a v4 compound request

if the request being processed is not a v4 compound request, then
examining the cstate can have undefined results.

this patch adds a check that the rpc procedure being executed
(rq_procinfo) is the nfsproc4_compound procedure.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-38430" target="_blank">CVE-2025-38430</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-07-25 10:15:27 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">N/A</span></p>
                    <p><span class="feed-label">CVSS Score:</span> N/A</p>
                    <p>In the Linux kernel, the following vulnerability has been resolved:

nfsd: nfsd4_spo_must_allow() must check this is a v4 compound request

If the request being processed is not a v4 compound request, then
examining the cstate can have undefined results.

This patch adds a check that the rpc procedure being executed
(rq_procinfo) is the NFSPROC4_COMPOUND procedure.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-38429" data-description="in the linux kernel, the following vulnerability has been resolved:

bus: mhi: ep: update read pointer only after buffer is written

inside mhi_ep_ring_add_element, the read pointer (rd_offset) is updated
before the buffer is written, potentially causing race conditions where
the host sees an updated read pointer before the buffer is actually
written. updating rd_offset prematurely can lead to the host accessing
an uninitialized or incomplete element, resulting in data corruption.

invoke the buffer write before updating rd_offset to ensure the element
is fully written before signaling its availability.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-38429" target="_blank">CVE-2025-38429</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-07-25 10:15:27 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">N/A</span></p>
                    <p><span class="feed-label">CVSS Score:</span> N/A</p>
                    <p>In the Linux kernel, the following vulnerability has been resolved:

bus: mhi: ep: Update read pointer only after buffer is written

Inside mhi_ep_ring_add_element, the read pointer (rd_offset) is updated
before the buffer is written, potentially causing race conditions where
the host sees an updated read pointer before the buffer is actually
written. Updating rd_offset prematurely can lead to the host accessing
an uninitialized or incomplete element, resulting in data corruption.

Invoke the buffer write before updating rd_offset to ensure the element
is fully written before signaling its availability.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-38428" data-description="in the linux kernel, the following vulnerability has been resolved:

input: ims-pcu - check record size in ims_pcu_flash_firmware()

the "len" variable comes from the firmware and we generally do
trust firmware, but it's always better to double check.  if the "len"
is too large it could result in memory corruption when we do
"memcpy(fragment->data, rec->data, len);"">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-38428" target="_blank">CVE-2025-38428</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-07-25 10:15:27 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">N/A</span></p>
                    <p><span class="feed-label">CVSS Score:</span> N/A</p>
                    <p>In the Linux kernel, the following vulnerability has been resolved:

Input: ims-pcu - check record size in ims_pcu_flash_firmware()

The "len" variable comes from the firmware and we generally do
trust firmware, but it's always better to double check.  If the "len"
is too large it could result in memory corruption when we do
"memcpy(fragment->data, rec->data, len);"</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-38427" data-description="in the linux kernel, the following vulnerability has been resolved:

video: screen_info: relocate framebuffers behind pci bridges

apply pci host-bridge window offsets to screen_info framebuffers. fixes
invalid access to i/o memory.

resources behind a pci host bridge can be relocated by a certain offset
in the kernel's cpu address range used for i/o. the framebuffer memory
range stored in screen_info refers to the cpu addresses as seen during
boot (where the offset is 0). during boot up, firmware may assign a
different memory offset to the pci host bridge and thereby relocating
the framebuffer address of the pci graphics device as seen by the kernel.
the information in screen_info must be updated as well.

the helper pcibios_bus_to_resource() performs the relocation of the
screen_info's framebuffer resource (given in pci bus addresses). the
result matches the i/o-memory resource of the pci graphics device (given
in cpu addresses). as before, we store away the information necessary to
later update the information in screen_info itself.

commit 78aa89d1dfba ("firmware/sysfb: update screen_info for relocated
efi framebuffers") added the code for updating screen_info. it is based
on similar functionality that pre-existed in efifb. efifb uses a pointer
to the pci resource, while the newer code does a memcpy of the region.
hence efifb sees any updates to the pci resource and avoids the issue.

v3:
- only use struct pci_bus_region for pci bus addresses (bjorn)
- clarify address semantics in commit messages and comments (bjorn)
v2:
- fixed tags (takashi, ivan)
- updated information on efifb">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-38427" target="_blank">CVE-2025-38427</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-07-25 10:15:27 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">N/A</span></p>
                    <p><span class="feed-label">CVSS Score:</span> N/A</p>
                    <p>In the Linux kernel, the following vulnerability has been resolved:

video: screen_info: Relocate framebuffers behind PCI bridges

Apply PCI host-bridge window offsets to screen_info framebuffers. Fixes
invalid access to I/O memory.

Resources behind a PCI host bridge can be relocated by a certain offset
in the kernel's CPU address range used for I/O. The framebuffer memory
range stored in screen_info refers to the CPU addresses as seen during
boot (where the offset is 0). During boot up, firmware may assign a
different memory offset to the PCI host bridge and thereby relocating
the framebuffer address of the PCI graphics device as seen by the kernel.
The information in screen_info must be updated as well.

The helper pcibios_bus_to_resource() performs the relocation of the
screen_info's framebuffer resource (given in PCI bus addresses). The
result matches the I/O-memory resource of the PCI graphics device (given
in CPU addresses). As before, we store away the information necessary to
later update the information in screen_info itself.

Commit 78aa89d1dfba ("firmware/sysfb: Update screen_info for relocated
EFI framebuffers") added the code for updating screen_info. It is based
on similar functionality that pre-existed in efifb. Efifb uses a pointer
to the PCI resource, while the newer code does a memcpy of the region.
Hence efifb sees any updates to the PCI resource and avoids the issue.

v3:
- Only use struct pci_bus_region for PCI bus addresses (Bjorn)
- Clarify address semantics in commit messages and comments (Bjorn)
v2:
- Fixed tags (Takashi, Ivan)
- Updated information on efifb</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-38426" data-description="in the linux kernel, the following vulnerability has been resolved:

drm/amdgpu: add basic validation for ras header

if ras header read from eeprom is corrupted, it could result in trying
to allocate huge memory for reading the records. add some validation to
header fields.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-38426" target="_blank">CVE-2025-38426</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-07-25 10:15:27 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">N/A</span></p>
                    <p><span class="feed-label">CVSS Score:</span> N/A</p>
                    <p>In the Linux kernel, the following vulnerability has been resolved:

drm/amdgpu: Add basic validation for RAS header

If RAS header read from EEPROM is corrupted, it could result in trying
to allocate huge memory for reading the records. Add some validation to
header fields.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-38425" data-description="in the linux kernel, the following vulnerability has been resolved:

i2c: tegra: check msg length in smbus block read

for smbus block read, do not continue to read if the message length
passed from the device is '0' or greater than the maximum allowed bytes.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-38425" target="_blank">CVE-2025-38425</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-07-25 10:15:27 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">N/A</span></p>
                    <p><span class="feed-label">CVSS Score:</span> N/A</p>
                    <p>In the Linux kernel, the following vulnerability has been resolved:

i2c: tegra: check msg length in SMBUS block read

For SMBUS block read, do not continue to read if the message length
passed from the device is '0' or greater than the maximum allowed bytes.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-38424" data-description="in the linux kernel, the following vulnerability has been resolved:

perf: fix sample vs do_exit()

baisheng gao reported an arm64 crash, which mark decoded as being a
synchronous external abort -- most likely due to trying to access
mmio in bad ways.

the crash further shows perf trying to do a user stack sample while in
exit_mmap()'s tlb_finish_mmu() -- i.e. while tearing down the address
space it is trying to access.

it turns out that we stop perf after we tear down the userspace mm; a
receipie for disaster, since perf likes to access userspace for
various reasons.

flip this order by moving up where we stop perf in do_exit().

additionally, harden perf_sample_callchain and perf_sample_stack_user
to abort when the current task does not have an mm (exit_mm() makes
sure to set current->mm = null; before commencing with the actual
teardown). such that cpu wide events don't trip on this same problem.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-38424" target="_blank">CVE-2025-38424</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-07-25 10:15:27 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">N/A</span></p>
                    <p><span class="feed-label">CVSS Score:</span> N/A</p>
                    <p>In the Linux kernel, the following vulnerability has been resolved:

perf: Fix sample vs do_exit()

Baisheng Gao reported an ARM64 crash, which Mark decoded as being a
synchronous external abort -- most likely due to trying to access
MMIO in bad ways.

The crash further shows perf trying to do a user stack sample while in
exit_mmap()'s tlb_finish_mmu() -- i.e. while tearing down the address
space it is trying to access.

It turns out that we stop perf after we tear down the userspace mm; a
receipie for disaster, since perf likes to access userspace for
various reasons.

Flip this order by moving up where we stop perf in do_exit().

Additionally, harden PERF_SAMPLE_CALLCHAIN and PERF_SAMPLE_STACK_USER
to abort when the current task does not have an mm (exit_mm() makes
sure to set current->mm = NULL; before commencing with the actual
teardown). Such that CPU wide events don't trip on this same problem.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-38423" data-description="in the linux kernel, the following vulnerability has been resolved:

asoc: codecs: wcd9375: fix double free of regulator supplies

driver gets regulator supplies in probe path with
devm_regulator_bulk_get(), so should not call regulator_bulk_free() in
error and remove paths to avoid double free.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-38423" target="_blank">CVE-2025-38423</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-07-25 10:15:27 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">N/A</span></p>
                    <p><span class="feed-label">CVSS Score:</span> N/A</p>
                    <p>In the Linux kernel, the following vulnerability has been resolved:

ASoC: codecs: wcd9375: Fix double free of regulator supplies

Driver gets regulator supplies in probe path with
devm_regulator_bulk_get(), so should not call regulator_bulk_free() in
error and remove paths to avoid double free.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-38422" data-description="in the linux kernel, the following vulnerability has been resolved:

net: lan743x: modify the eeprom and otp size for pci1xxxx devices

maximum otp and eeprom size for hearthstone pci1xxxx devices are 8 kb
and 64 kb respectively. adjust max size definitions and return correct
eeprom length based on device. also prevent out-of-bound read/write.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-38422" target="_blank">CVE-2025-38422</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-07-25 10:15:27 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">N/A</span></p>
                    <p><span class="feed-label">CVSS Score:</span> N/A</p>
                    <p>In the Linux kernel, the following vulnerability has been resolved:

net: lan743x: Modify the EEPROM and OTP size for PCI1xxxx devices

Maximum OTP and EEPROM size for hearthstone PCI1xxxx devices are 8 Kb
and 64 Kb respectively. Adjust max size definitions and return correct
EEPROM length based on device. Also prevent out-of-bound read/write.</p>
                </div>
        
            </div>
        </div>

        <footer class="footer">
            <p>© 2025 dotne1 - Cybersecurity Portfolio</p>
        </footer>

        <script>
            function searchCVEs() {
                const input = document.getElementById('searchInput').value.toLowerCase();
                const cveEntries = document.getElementsByClassName('cve-entry');
                for (let i = 0; i < cveEntries.length; i++) {
                    const cveId = cveEntries[i].getAttribute('data-cve-id').toLowerCase();
                    const description = cveEntries[i].getAttribute('data-description');
                    if (cveId.includes(input) || description.includes(input)) {
                        cveEntries[i].style.display = '';
                    } else {
                        cveEntries[i].style.display = 'none';
                    }
                }
            }
        </script>
    </body>
    </html>
    