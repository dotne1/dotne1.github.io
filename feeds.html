
    <!DOCTYPE html>
    <html lang="en">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <meta name="description" content="Security alerts and cybersecurity news feeds">
        <meta name="keywords" content="cybersecurity news, security alerts, vulnerability feeds, threat intelligence">
        <meta name="author" content="dotne1">
        <meta property="og:title" content="Security Feeds - dotne1's Cybersecurity Portfolio">
        <meta property="og:description" content="Stay updated with the latest cybersecurity news and alerts">
        <meta property="og:type" content="website">
        <title>Security Feeds - dotne1's Cybersecurity Portfolio</title>
        <link rel="stylesheet" href="styles.css">
        <link rel="icon" type="image/x-icon" href="/favicon.ico">
    </head>
    <body>
        <nav class="navbar">
            <div class="nav-links">
                <a href="index.html" class="nav-link">Home</a>
                <a href="about-me.html" class="nav-link">About Me</a>
                <a href="projects.html" class="nav-link">Projects</a>
                <a href="resume.html" class="nav-link">Resume</a>
                <a href="feeds.html" class="nav-link">Feeds</a>
            </div>
        </nav>

        <div class="container" role="main">
            <h1 class="main-header">Security Feeds</h1>
            <div class="search-bar">
                <input type="text" id="searchInput" placeholder="Search CVEs..." onkeyup="searchCVEs()">
            </div>
            <div class="feed-preview" id="cveFeed">
                <div class="feed-header">Latest Vulnerabilities</div>
    
                <div class="cve-entry" data-cve-id="CVE-2025-53791" data-description="improper access control in microsoft edge (chromium-based) allows an unauthorized attacker to bypass a security feature over a network.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-53791" target="_blank">CVE-2025-53791</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-09-05 16:15:38 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">MEDIUM</span></p>
                    <p><span class="feed-label">CVSS Score:</span> 4.7</p>
                    <p>Improper access control in Microsoft Edge (Chromium-based) allows an unauthorized attacker to bypass a security feature over a network.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-10061" data-description="an authorized user can cause a crash in the mongodb server through a specially crafted $group query. this vulnerability is related to the incorrect handling of certain accumulator functions when additional parameters are specified within the $group operation. this vulnerability could lead to denial of service if triggered repeatedly. this issue affects mongodb server v6.0 versions prior to 6.0.25, mongodb server v7.0 versions prior to 7.0.22, mongodb server v8.0 versions prior to 8.0.12 and mongodb server v8.1 versions prior to 8.1.2">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-10061" target="_blank">CVE-2025-10061</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-09-05 16:15:35 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">MEDIUM</span></p>
                    <p><span class="feed-label">CVSS Score:</span> 6.5</p>
                    <p>An authorized user can cause a crash in the MongoDB Server through a specially crafted $group query. This vulnerability is related to the incorrect handling of certain accumulator functions when additional parameters are specified within the $group operation. This vulnerability could lead to denial of service if triggered repeatedly. This issue affects MongoDB Server v6.0 versions prior to 6.0.25, MongoDB Server v7.0 versions prior to 7.0.22, MongoDB Server v8.0 versions prior to 8.0.12 and MongoDB Server v8.1 versions prior to 8.1.2</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-10060" data-description="mongodb server may allow upsert operations retried within a transaction to violate unique index constraints, potentially causing an invariant failure and server crash during commit. this issue may be triggered by improper writeunitofwork state management.  this issue affects mongodb server v6.0 versions prior to 6.0.25, mongodb server v7.0 versions prior to 7.0.22 and mongodb server v8.0 versions prior to 8.0.12">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-10060" target="_blank">CVE-2025-10060</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-09-05 16:15:34 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">MEDIUM</span></p>
                    <p><span class="feed-label">CVSS Score:</span> 6.5</p>
                    <p>MongoDB Server may allow upsert operations retried within a transaction to violate unique index constraints, potentially causing an invariant failure and server crash during commit. This issue may be triggered by improper WriteUnitOfWork state management.  This issue affects MongoDB Server v6.0 versions prior to 6.0.25, MongoDB Server v7.0 versions prior to 7.0.22 and MongoDB Server v8.0 versions prior to 8.0.12</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-10059" data-description="an improper setting of the lsid field on any sharded query can cause a crash in mongodb routers. this issue occurs when a generic argument (lsid) is provided in a case when it is not applicable. this affects mongodb server v6.0 versions prior to 6.0.x, mongodb server v7.0 versions prior to 7.0.18 and mongodb server v8.0 versions prior to 8.0.6.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-10059" target="_blank">CVE-2025-10059</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-09-05 16:15:34 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">MEDIUM</span></p>
                    <p><span class="feed-label">CVSS Score:</span> 6.5</p>
                    <p>An improper setting of the lsid field on any sharded query can cause a crash in MongoDB routers. This issue occurs when a generic argument (lsid) is provided in a case when it is not applicable. This affects MongoDB Server v6.0 versions prior to 6.0.x, MongoDB Server v7.0 versions prior to 7.0.18 and MongoDB Server v8.0 versions prior to 8.0.6.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-9566" data-description="there's a vulnerability in podman where an attacker may use the kube play command to overwrite host files when the kube file container a secrete or a configmap volume mount and such volume contains a symbolic link to a host file path. in a successful attack, the attacker can only control the target file to be overwritten but not the content to be written into the file.

binary-affected: podman
upstream-version-introduced: v4.0.0
upstream-version-fixed: v5.6.1">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-9566" target="_blank">CVE-2025-9566</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-09-05 15:15:36 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-online">HIGH</span></p>
                    <p><span class="feed-label">CVSS Score:</span> 8.1</p>
                    <p>There's a vulnerability in podman where an attacker may use the kube play command to overwrite host files when the kube file container a Secrete or a ConfigMap volume mount and such volume contains a symbolic link to a host file path. In a successful attack, the attacker can only control the target file to be overwritten but not the content to be written into the file.

Binary-Affected: podman
Upstream-version-introduced: v4.0.0
Upstream-version-fixed: v5.6.1</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-10044" data-description="a flaw was found in keycloak. keycloak’s account console and other pages accept arbitrary text in the error_description query parameter. this text is directly rendered in error pages without validation or sanitization. while html encoding prevents xss, an attacker can craft urls with misleading messages (e.g., fake support phone numbers or urls), which are displayed within the trusted keycloak ui. this creates a phishing vector, potentially tricking users into contacting malicious actors.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-10044" target="_blank">CVE-2025-10044</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-09-05 15:15:34 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">MEDIUM</span></p>
                    <p><span class="feed-label">CVSS Score:</span> 4.3</p>
                    <p>A flaw was found in Keycloak. Keycloak’s account console and other pages accept arbitrary text in the error_description query parameter. This text is directly rendered in error pages without validation or sanitization. While HTML encoding prevents XSS, an attacker can craft URLs with misleading messages (e.g., fake support phone numbers or URLs), which are displayed within the trusted Keycloak UI. This creates a phishing vector, potentially tricking users into contacting malicious actors.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-10043" data-description="a path traversal validation flaw exists in keycloak’s vault key handling on windows. the previous fix for cve-2024-10492 did not account for the windows file separator (\). as a result, a high-privilege administrator could probe for the existence of files outside the expected realm context through crafted vault secret lookups. this is a platform-specific variant/incomplete fix of cve-2024-10492.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-10043" target="_blank">CVE-2025-10043</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-09-05 15:15:34 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">LOW</span></p>
                    <p><span class="feed-label">CVSS Score:</span> 2.7</p>
                    <p>A path traversal validation flaw exists in Keycloak’s vault key handling on Windows. The previous fix for CVE-2024-10492 did not account for the Windows file separator (\). As a result, a high-privilege administrator could probe for the existence of files outside the expected realm context through crafted vault secret lookups. This is a platform-specific variant/incomplete fix of CVE-2024-10492.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-10026" data-description="a vulnerability was found in itsourcecode pos point of sale system 1.0. affected by this vulnerability is an unknown functionality of the file /inventory/main/vendors/datatables/unit_testing/templates/-complex_header.php. the manipulation of the argument scripts results in cross site scripting. it is possible to launch the attack remotely. the exploit has been made public and could be used.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-10026" target="_blank">CVE-2025-10026</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-09-05 15:15:33 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">LOW</span></p>
                    <p><span class="feed-label">CVSS Score:</span> 3.5</p>
                    <p>A vulnerability was found in itsourcecode POS Point of Sale System 1.0. Affected by this vulnerability is an unknown functionality of the file /inventory/main/vendors/datatables/unit_testing/templates/-complex_header.php. The manipulation of the argument scripts results in cross site scripting. It is possible to launch the attack remotely. The exploit has been made public and could be used.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-10025" data-description="a vulnerability has been found in phpgurukul online course registration 3.1. affected is an unknown function of the file /admin/semester.php. the manipulation of the argument semester leads to sql injection. it is possible to initiate the attack remotely. the exploit has been disclosed to the public and may be used.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-10025" target="_blank">CVE-2025-10025</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-09-05 15:15:33 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-online">HIGH</span></p>
                    <p><span class="feed-label">CVSS Score:</span> 7.3</p>
                    <p>A vulnerability has been found in PHPGurukul Online Course Registration 3.1. Affected is an unknown function of the file /admin/semester.php. The manipulation of the argument semester leads to sql injection. It is possible to initiate the attack remotely. The exploit has been disclosed to the public and may be used.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-9057" data-description="the biagiotti core plugin for wordpress is vulnerable to stored cross-site scripting via shortcodes in versions up to, and including, 2.1.3 due to insufficient input sanitization and output escaping on user supplied attributes. this makes it possible for authenticated attackers with contributor-level and above permissions to inject arbitrary web scripts in pages that will execute whenever a user accesses an injected page.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-9057" target="_blank">CVE-2025-9057</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-09-05 14:15:33 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">MEDIUM</span></p>
                    <p><span class="feed-label">CVSS Score:</span> 6.4</p>
                    <p>The Biagiotti Core plugin for WordPress is vulnerable to Stored Cross-Site Scripting via shortcodes in versions up to, and including, 2.1.3 due to insufficient input sanitization and output escaping on user supplied attributes. This makes it possible for authenticated attackers with contributor-level and above permissions to inject arbitrary web scripts in pages that will execute whenever a user accesses an injected page.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-9709" data-description="on-chip debug and test interface with improper access control and improper protection against electromagnetic fault injection (em-fi) in nordic semiconductor nrf52810 allow attacker to perform em fault injection and bypass approtect at runtime, requiring the least amount of modification to the hardware system possible.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-9709" target="_blank">CVE-2025-9709</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-09-05 13:15:50 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">N/A</span></p>
                    <p><span class="feed-label">CVSS Score:</span> N/A</p>
                    <p>On-Chip Debug and Test Interface With Improper Access Control and Improper Protection against Electromagnetic Fault Injection (EM-FI) in Nordic Semiconductor nRF52810 allow attacker to perform EM Fault Injection and bypass APPROTECT at runtime, requiring the least amount of modification to the hardware system possible.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-39726" data-description="in the linux kernel, the following vulnerability has been resolved:

s390/ism: fix concurrency management in ism_cmd()

the s390x ism device data sheet clearly states that only one
request-response sequence is allowable per ism function at any point in
time.  unfortunately as of today the s390/ism driver in linux does not
honor that requirement. this patch aims to rectify that.

this problem was discovered based on aliaksei's bug report which states
that for certain workloads the ism functions end up entering error state
(with pec 2 as seen from the logs) after a while and as a consequence
connections handled by the respective function break, and for future
connection requests the ism device is not considered -- given it is in a
dysfunctional state. during further debugging pec 3a was observed as
well.

a kernel message like
[ 1211.244319] zpci: 061a:00:00.0: event 0x2 reports an error for pci function 0x61a
is a reliable indicator of the stated function entering error state
with pec 2. let me also point out that a kernel message like
[ 1211.244325] zpci: 061a:00:00.0: the ism driver bound to the device does not support error recovery
is a reliable indicator that the ism function won't be auto-recovered
because the ism driver currently lacks support for it.

on a technical level, without this synchronization, commands (inputs to
the fw) may be partially or fully overwritten (corrupted) by another cpu
trying to issue commands on the same function. there is hard evidence that
this can lead to dmb token values being used as dmb iovas, leading to
pec 2 pci events indicating invalid dma. but this is only one of the
failure modes imaginable. in theory even completely losing one command
and executing another one twice and then trying to interpret the outputs
as if the command we intended to execute was actually executed and not
the other one is also possible.  frankly, i don't feel confident about
providing an exhaustive list of possible consequences.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-39726" target="_blank">CVE-2025-39726</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-09-05 13:15:50 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">N/A</span></p>
                    <p><span class="feed-label">CVSS Score:</span> N/A</p>
                    <p>In the Linux kernel, the following vulnerability has been resolved:

s390/ism: fix concurrency management in ism_cmd()

The s390x ISM device data sheet clearly states that only one
request-response sequence is allowable per ISM function at any point in
time.  Unfortunately as of today the s390/ism driver in Linux does not
honor that requirement. This patch aims to rectify that.

This problem was discovered based on Aliaksei's bug report which states
that for certain workloads the ISM functions end up entering error state
(with PEC 2 as seen from the logs) after a while and as a consequence
connections handled by the respective function break, and for future
connection requests the ISM device is not considered -- given it is in a
dysfunctional state. During further debugging PEC 3A was observed as
well.

A kernel message like
[ 1211.244319] zpci: 061a:00:00.0: Event 0x2 reports an error for PCI function 0x61a
is a reliable indicator of the stated function entering error state
with PEC 2. Let me also point out that a kernel message like
[ 1211.244325] zpci: 061a:00:00.0: The ism driver bound to the device does not support error recovery
is a reliable indicator that the ISM function won't be auto-recovered
because the ISM driver currently lacks support for it.

On a technical level, without this synchronization, commands (inputs to
the FW) may be partially or fully overwritten (corrupted) by another CPU
trying to issue commands on the same function. There is hard evidence that
this can lead to DMB token values being used as DMB IOVAs, leading to
PEC 2 PCI events indicating invalid DMA. But this is only one of the
failure modes imaginable. In theory even completely losing one command
and executing another one twice and then trying to interpret the outputs
as if the command we intended to execute was actually executed and not
the other one is also possible.  Frankly, I don't feel confident about
providing an exhaustive list of possible consequences.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-39725" data-description="in the linux kernel, the following vulnerability has been resolved:

mm/vmscan: fix hwpoisoned large folio handling in shrink_folio_list

in shrink_folio_list(), the hwpoisoned folio may be large folio, which
can't be handled by unmap_poisoned_folio().  for thp, try_to_unmap_one()
must be passed with ttu_split_huge_pmd to split huge pmd first and then
retry.  without ttu_split_huge_pmd, we will trigger null-ptr deref of
pvmw.pte.  even we passed ttu_split_huge_pmd, we will trigger a
warn_on_once due to the page isn't in swapcache.

since uce is rare in real world, and race with reclaimation is more rare,
just skipping the hwpoisoned large folio is enough.  memory_failure() will
handle it if the uce is triggered again.

this happens when memory reclaim for large folio races with
memory_failure(), and will lead to kernel panic.  the race is as
follows:

cpu0      cpu1
 shrink_folio_list memory_failure
  testsetpagehwpoison
  unmap_poisoned_folio
  --> trigger bug_on due to
  unmap_poisoned_folio couldn't
   handle large folio

[tujinjiang@huawei.com: add comment to unmap_poisoned_folio()]">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-39725" target="_blank">CVE-2025-39725</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-09-05 13:15:50 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">N/A</span></p>
                    <p><span class="feed-label">CVSS Score:</span> N/A</p>
                    <p>In the Linux kernel, the following vulnerability has been resolved:

mm/vmscan: fix hwpoisoned large folio handling in shrink_folio_list

In shrink_folio_list(), the hwpoisoned folio may be large folio, which
can't be handled by unmap_poisoned_folio().  For THP, try_to_unmap_one()
must be passed with TTU_SPLIT_HUGE_PMD to split huge PMD first and then
retry.  Without TTU_SPLIT_HUGE_PMD, we will trigger null-ptr deref of
pvmw.pte.  Even we passed TTU_SPLIT_HUGE_PMD, we will trigger a
WARN_ON_ONCE due to the page isn't in swapcache.

Since UCE is rare in real world, and race with reclaimation is more rare,
just skipping the hwpoisoned large folio is enough.  memory_failure() will
handle it if the UCE is triggered again.

This happens when memory reclaim for large folio races with
memory_failure(), and will lead to kernel panic.  The race is as
follows:

cpu0      cpu1
 shrink_folio_list memory_failure
  TestSetPageHWPoison
  unmap_poisoned_folio
  --> trigger BUG_ON due to
  unmap_poisoned_folio couldn't
   handle large folio

[tujinjiang@huawei.com: add comment to unmap_poisoned_folio()]</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-39724" data-description="in the linux kernel, the following vulnerability has been resolved:

serial: 8250: fix panic due to pslverr

when the pslverr_resp_en parameter is set to 1, the device generates
an error response if an attempt is made to read an empty rbr (receive
buffer register) while the fifo is enabled.

in serial8250_do_startup(), calling serial_port_out(port, uart_lcr,
uart_lcr_wlen8) triggers dw8250_check_lcr(), which invokes
dw8250_force_idle() and serial8250_clear_and_reinit_fifos(). the latter
function enables the fifo via serial_out(p, uart_fcr, p->fcr).
execution proceeds to the serial_port_in(port, uart_rx).
this satisfies the pslverr trigger condition.

when another cpu (e.g., using printk()) is accessing the uart (uart
is busy), the current cpu fails the check (value & ~uart_lcr_spar) ==
(lcr & ~uart_lcr_spar) in dw8250_check_lcr(), causing it to enter
dw8250_force_idle().

put serial_port_out(port, uart_lcr, uart_lcr_wlen8) under the port->lock
to fix this issue.

panic backtrace:
[    0.442336] oops - unknown exception [#1]
[    0.442343] epc : dw8250_serial_in32+0x1e/0x4a
[    0.442351]  ra : serial8250_do_startup+0x2c8/0x88e
...
[    0.442416] console_on_rootfs+0x26/0x70">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-39724" target="_blank">CVE-2025-39724</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-09-05 13:15:50 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">N/A</span></p>
                    <p><span class="feed-label">CVSS Score:</span> N/A</p>
                    <p>In the Linux kernel, the following vulnerability has been resolved:

serial: 8250: fix panic due to PSLVERR

When the PSLVERR_RESP_EN parameter is set to 1, the device generates
an error response if an attempt is made to read an empty RBR (Receive
Buffer Register) while the FIFO is enabled.

In serial8250_do_startup(), calling serial_port_out(port, UART_LCR,
UART_LCR_WLEN8) triggers dw8250_check_lcr(), which invokes
dw8250_force_idle() and serial8250_clear_and_reinit_fifos(). The latter
function enables the FIFO via serial_out(p, UART_FCR, p->fcr).
Execution proceeds to the serial_port_in(port, UART_RX).
This satisfies the PSLVERR trigger condition.

When another CPU (e.g., using printk()) is accessing the UART (UART
is busy), the current CPU fails the check (value & ~UART_LCR_SPAR) ==
(lcr & ~UART_LCR_SPAR) in dw8250_check_lcr(), causing it to enter
dw8250_force_idle().

Put serial_port_out(port, UART_LCR, UART_LCR_WLEN8) under the port->lock
to fix this issue.

Panic backtrace:
[    0.442336] Oops - unknown exception [#1]
[    0.442343] epc : dw8250_serial_in32+0x1e/0x4a
[    0.442351]  ra : serial8250_do_startup+0x2c8/0x88e
...
[    0.442416] console_on_rootfs+0x26/0x70</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-39723" data-description="in the linux kernel, the following vulnerability has been resolved:

netfs: fix unbuffered write error handling

if all the subrequests in an unbuffered write stream fail, the subrequest
collector doesn't update the stream->transferred value and it retains its
initial long_max value.  unfortunately, if all active streams fail, then we
take the smallest value of { long_max, long_max, ... } as the value to set
in wreq->transferred - which is then returned from ->write_iter().

long_max was chosen as the initial value so that all the streams can be
quickly assessed by taking the smallest value of all stream->transferred -
but this only works if we've set any of them.

fix this by adding a flag to indicate whether the value in
stream->transferred is valid and checking that when we integrate the
values.  stream->transferred can then be initialised to zero.

this was found by running the generic/750 xfstest against cifs with
cache=none.  it splices data to the target file.  once (if) it has used up
all the available scratch space, the writes start failing with enospc.
this causes ->write_iter() to fail.  however, it was returning
wreq->transferred, i.e. long_max, rather than an error (because it thought
the amount transferred was non-zero) and iter_file_splice_write() would
then try to clean up that amount of pipe bufferage - leading to an oops
when it overran.  the kernel log showed:

    cifs: vfs: send error in write = -28

followed by:

    bug: kernel null pointer dereference, address: 0000000000000008

with:

    rip: 0010:iter_file_splice_write+0x3a4/0x520
    do_splice+0x197/0x4e0

or:

    rip: 0010:pipe_buf_release (include/linux/pipe_fs_i.h:282)
    iter_file_splice_write (fs/splice.c:755)

also put a warning check into splice to announce if ->write_iter() returned
that it had written more than it was asked to.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-39723" target="_blank">CVE-2025-39723</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-09-05 13:15:50 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">N/A</span></p>
                    <p><span class="feed-label">CVSS Score:</span> N/A</p>
                    <p>In the Linux kernel, the following vulnerability has been resolved:

netfs: Fix unbuffered write error handling

If all the subrequests in an unbuffered write stream fail, the subrequest
collector doesn't update the stream->transferred value and it retains its
initial LONG_MAX value.  Unfortunately, if all active streams fail, then we
take the smallest value of { LONG_MAX, LONG_MAX, ... } as the value to set
in wreq->transferred - which is then returned from ->write_iter().

LONG_MAX was chosen as the initial value so that all the streams can be
quickly assessed by taking the smallest value of all stream->transferred -
but this only works if we've set any of them.

Fix this by adding a flag to indicate whether the value in
stream->transferred is valid and checking that when we integrate the
values.  stream->transferred can then be initialised to zero.

This was found by running the generic/750 xfstest against cifs with
cache=none.  It splices data to the target file.  Once (if) it has used up
all the available scratch space, the writes start failing with ENOSPC.
This causes ->write_iter() to fail.  However, it was returning
wreq->transferred, i.e. LONG_MAX, rather than an error (because it thought
the amount transferred was non-zero) and iter_file_splice_write() would
then try to clean up that amount of pipe bufferage - leading to an oops
when it overran.  The kernel log showed:

    CIFS: VFS: Send error in write = -28

followed by:

    BUG: kernel NULL pointer dereference, address: 0000000000000008

with:

    RIP: 0010:iter_file_splice_write+0x3a4/0x520
    do_splice+0x197/0x4e0

or:

    RIP: 0010:pipe_buf_release (include/linux/pipe_fs_i.h:282)
    iter_file_splice_write (fs/splice.c:755)

Also put a warning check into splice to announce if ->write_iter() returned
that it had written more than it was asked to.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-39722" data-description="in the linux kernel, the following vulnerability has been resolved:

crypto: caam - prevent crash on suspend with imx8qm / imx8ulp

since the caam on these socs is managed by another arm core, called the
seco (security controller) on imx8qm and secure enclave on imx8ulp, which
also reserves access to register page 0 suspend operations cannot touch
this page.

this is similar to when running optee, where optee will reserve page 0.

track this situation using a new state variable no_page0, reflecting if
page 0 is reserved elsewhere, either by other management cores in soc or
by optee.

replace the optee_en check in suspend/resume with the new check.

optee_en cannot go away as it's needed elsewhere to gate optee specific
situations.

fixes the following splat at suspend:

    internal error: synchronous external abort: 0000000096000010 [#1] smp
    hardware name: freescale i.mx8qxp acu6c (dt)
    pstate: 60400005 (nzcv daif +pan -uao -tco -dit -ssbs btype=--)
    pc : readl+0x0/0x18
    lr : rd_reg32+0x18/0x3c
    sp : ffffffc08192ba20
    x29: ffffffc08192ba20 x28: ffffff8025190000 x27: 0000000000000000
    x26: ffffffc0808ae808 x25: ffffffc080922338 x24: ffffff8020e89090
    x23: 0000000000000000 x22: ffffffc080922000 x21: ffffff8020e89010
    x20: ffffffc080387ef8 x19: ffffff8020e89010 x18: 000000005d8000d5
    x17: 0000000030f35963 x16: 000000008f785f3f x15: 000000003b8ef57c
    x14: 00000000c418aef8 x13: 00000000f5fea526 x12: 0000000000000001
    x11: 0000000000000002 x10: 0000000000000001 x9 : 0000000000000000
    x8 : ffffff8025190870 x7 : ffffff8021726880 x6 : 0000000000000002
    x5 : ffffff80217268f0 x4 : ffffff8021726880 x3 : ffffffc081200000
    x2 : 0000000000000001 x1 : ffffff8020e89010 x0 : ffffffc081200004
    call trace:
     readl+0x0/0x18
     caam_ctrl_suspend+0x30/0xdc
     dpm_run_callback.constprop.0+0x24/0x5c
     device_suspend+0x170/0x2e8
     dpm_suspend+0xa0/0x104
     dpm_suspend_start+0x48/0x50
     suspend_devices_and_enter+0x7c/0x45c
     pm_suspend+0x148/0x160
     state_store+0xb4/0xf8
     kobj_attr_store+0x14/0x24
     sysfs_kf_write+0x38/0x48
     kernfs_fop_write_iter+0xb4/0x178
     vfs_write+0x118/0x178
     ksys_write+0x6c/0xd0
     __arm64_sys_write+0x14/0x1c
     invoke_syscall.constprop.0+0x64/0xb0
     do_el0_svc+0x90/0xb0
     el0_svc+0x18/0x44
     el0t_64_sync_handler+0x88/0x124
     el0t_64_sync+0x150/0x154
    code: 88dffc21 88dffc21 5ac00800 d65f03c0 (b9400000)">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-39722" target="_blank">CVE-2025-39722</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-09-05 13:15:49 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">N/A</span></p>
                    <p><span class="feed-label">CVSS Score:</span> N/A</p>
                    <p>In the Linux kernel, the following vulnerability has been resolved:

crypto: caam - Prevent crash on suspend with iMX8QM / iMX8ULP

Since the CAAM on these SoCs is managed by another ARM core, called the
SECO (Security Controller) on iMX8QM and Secure Enclave on iMX8ULP, which
also reserves access to register page 0 suspend operations cannot touch
this page.

This is similar to when running OPTEE, where OPTEE will reserve page 0.

Track this situation using a new state variable no_page0, reflecting if
page 0 is reserved elsewhere, either by other management cores in SoC or
by OPTEE.

Replace the optee_en check in suspend/resume with the new check.

optee_en cannot go away as it's needed elsewhere to gate OPTEE specific
situations.

Fixes the following splat at suspend:

    Internal error: synchronous external abort: 0000000096000010 [#1] SMP
    Hardware name: Freescale i.MX8QXP ACU6C (DT)
    pstate: 60400005 (nZCv daif +PAN -UAO -TCO -DIT -SSBS BTYPE=--)
    pc : readl+0x0/0x18
    lr : rd_reg32+0x18/0x3c
    sp : ffffffc08192ba20
    x29: ffffffc08192ba20 x28: ffffff8025190000 x27: 0000000000000000
    x26: ffffffc0808ae808 x25: ffffffc080922338 x24: ffffff8020e89090
    x23: 0000000000000000 x22: ffffffc080922000 x21: ffffff8020e89010
    x20: ffffffc080387ef8 x19: ffffff8020e89010 x18: 000000005d8000d5
    x17: 0000000030f35963 x16: 000000008f785f3f x15: 000000003b8ef57c
    x14: 00000000c418aef8 x13: 00000000f5fea526 x12: 0000000000000001
    x11: 0000000000000002 x10: 0000000000000001 x9 : 0000000000000000
    x8 : ffffff8025190870 x7 : ffffff8021726880 x6 : 0000000000000002
    x5 : ffffff80217268f0 x4 : ffffff8021726880 x3 : ffffffc081200000
    x2 : 0000000000000001 x1 : ffffff8020e89010 x0 : ffffffc081200004
    Call trace:
     readl+0x0/0x18
     caam_ctrl_suspend+0x30/0xdc
     dpm_run_callback.constprop.0+0x24/0x5c
     device_suspend+0x170/0x2e8
     dpm_suspend+0xa0/0x104
     dpm_suspend_start+0x48/0x50
     suspend_devices_and_enter+0x7c/0x45c
     pm_suspend+0x148/0x160
     state_store+0xb4/0xf8
     kobj_attr_store+0x14/0x24
     sysfs_kf_write+0x38/0x48
     kernfs_fop_write_iter+0xb4/0x178
     vfs_write+0x118/0x178
     ksys_write+0x6c/0xd0
     __arm64_sys_write+0x14/0x1c
     invoke_syscall.constprop.0+0x64/0xb0
     do_el0_svc+0x90/0xb0
     el0_svc+0x18/0x44
     el0t_64_sync_handler+0x88/0x124
     el0t_64_sync+0x150/0x154
    Code: 88dffc21 88dffc21 5ac00800 d65f03c0 (b9400000)</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-39721" data-description="in the linux kernel, the following vulnerability has been resolved:

crypto: qat - flush misc workqueue during device shutdown

repeated loading and unloading of a device specific qat driver, for
example qat_4xxx, in a tight loop can lead to a crash due to a
use-after-free scenario. this occurs when a power management (pm)
interrupt triggers just before the device-specific driver (e.g.,
qat_4xxx.ko) is unloaded, while the core driver (intel_qat.ko) remains
loaded.

since the driver uses a shared workqueue (`qat_misc_wq`) across all
devices and owned by intel_qat.ko, a deferred routine from the
device-specific driver may still be pending in the queue. if this
routine executes after the driver is unloaded, it can dereference freed
memory, resulting in a page fault and kernel crash like the following:

    bug: unable to handle page fault for address: ffa000002e50a01c
    #pf: supervisor read access in kernel mode
    rip: 0010:pm_bh_handler+0x1d2/0x250 [intel_qat]
    call trace:
      pm_bh_handler+0x1d2/0x250 [intel_qat]
      process_one_work+0x171/0x340
      worker_thread+0x277/0x3a0
      kthread+0xf0/0x120
      ret_from_fork+0x2d/0x50

to prevent this, flush the misc workqueue during device shutdown to
ensure that all pending work items are completed before the driver is
unloaded.

note: this approach may slightly increase shutdown latency if the
workqueue contains jobs from other devices, but it ensures correctness
and stability.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-39721" target="_blank">CVE-2025-39721</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-09-05 13:15:49 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">N/A</span></p>
                    <p><span class="feed-label">CVSS Score:</span> N/A</p>
                    <p>In the Linux kernel, the following vulnerability has been resolved:

crypto: qat - flush misc workqueue during device shutdown

Repeated loading and unloading of a device specific QAT driver, for
example qat_4xxx, in a tight loop can lead to a crash due to a
use-after-free scenario. This occurs when a power management (PM)
interrupt triggers just before the device-specific driver (e.g.,
qat_4xxx.ko) is unloaded, while the core driver (intel_qat.ko) remains
loaded.

Since the driver uses a shared workqueue (`qat_misc_wq`) across all
devices and owned by intel_qat.ko, a deferred routine from the
device-specific driver may still be pending in the queue. If this
routine executes after the driver is unloaded, it can dereference freed
memory, resulting in a page fault and kernel crash like the following:

    BUG: unable to handle page fault for address: ffa000002e50a01c
    #PF: supervisor read access in kernel mode
    RIP: 0010:pm_bh_handler+0x1d2/0x250 [intel_qat]
    Call Trace:
      pm_bh_handler+0x1d2/0x250 [intel_qat]
      process_one_work+0x171/0x340
      worker_thread+0x277/0x3a0
      kthread+0xf0/0x120
      ret_from_fork+0x2d/0x50

To prevent this, flush the misc workqueue during device shutdown to
ensure that all pending work items are completed before the driver is
unloaded.

Note: This approach may slightly increase shutdown latency if the
workqueue contains jobs from other devices, but it ensures correctness
and stability.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-39720" data-description="in the linux kernel, the following vulnerability has been resolved:

ksmbd: fix refcount leak causing resource not released

when ksmbd_conn_releasing(opinfo->conn) returns true,the refcount was not
decremented properly, causing a refcount leak that prevents the count from
reaching zero and the memory from being released.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-39720" target="_blank">CVE-2025-39720</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-09-05 13:15:49 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">N/A</span></p>
                    <p><span class="feed-label">CVSS Score:</span> N/A</p>
                    <p>In the Linux kernel, the following vulnerability has been resolved:

ksmbd: fix refcount leak causing resource not released

When ksmbd_conn_releasing(opinfo->conn) returns true,the refcount was not
decremented properly, causing a refcount leak that prevents the count from
reaching zero and the memory from being released.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-39719" data-description="in the linux kernel, the following vulnerability has been resolved:

iio: imu: bno055: fix oob access of hw_xlate array

fix a potential out-of-bounds array access of the hw_xlate array in
bno055.c.

in bno055_get_regmask(), hw_xlate was iterated over the length of the
vals array instead of the length of the hw_xlate array. in the case of
bno055_gyr_scale, the vals array is larger than the hw_xlate array,
so this could result in an out-of-bounds access. in practice, this
shouldn't happen though because a match should always be found which
breaks out of the for loop before it iterates beyond the end of the
hw_xlate array.

by adding a new hw_xlate_len field to the bno055_sysfs_attr, we can be
sure we are iterating over the correct length.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-39719" target="_blank">CVE-2025-39719</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-09-05 13:15:49 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">N/A</span></p>
                    <p><span class="feed-label">CVSS Score:</span> N/A</p>
                    <p>In the Linux kernel, the following vulnerability has been resolved:

iio: imu: bno055: fix OOB access of hw_xlate array

Fix a potential out-of-bounds array access of the hw_xlate array in
bno055.c.

In bno055_get_regmask(), hw_xlate was iterated over the length of the
vals array instead of the length of the hw_xlate array. In the case of
bno055_gyr_scale, the vals array is larger than the hw_xlate array,
so this could result in an out-of-bounds access. In practice, this
shouldn't happen though because a match should always be found which
breaks out of the for loop before it iterates beyond the end of the
hw_xlate array.

By adding a new hw_xlate_len field to the bno055_sysfs_attr, we can be
sure we are iterating over the correct length.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-39718" data-description="in the linux kernel, the following vulnerability has been resolved:

vsock/virtio: validate length in packet header before skb_put()

when receiving a vsock packet in the guest, only the virtqueue buffer
size is validated prior to virtio_vsock_skb_rx_put(). unfortunately,
virtio_vsock_skb_rx_put() uses the length from the packet header as the
length argument to skb_put(), potentially resulting in skb overflow if
the host has gone wonky.

validate the length as advertised by the packet header before calling
virtio_vsock_skb_rx_put().">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-39718" target="_blank">CVE-2025-39718</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-09-05 13:15:49 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">N/A</span></p>
                    <p><span class="feed-label">CVSS Score:</span> N/A</p>
                    <p>In the Linux kernel, the following vulnerability has been resolved:

vsock/virtio: Validate length in packet header before skb_put()

When receiving a vsock packet in the guest, only the virtqueue buffer
size is validated prior to virtio_vsock_skb_rx_put(). Unfortunately,
virtio_vsock_skb_rx_put() uses the length from the packet header as the
length argument to skb_put(), potentially resulting in SKB overflow if
the host has gone wonky.

Validate the length as advertised by the packet header before calling
virtio_vsock_skb_rx_put().</p>
                </div>
        
            </div>
        </div>

        <footer class="footer">
            <p>© 2025 dotne1 - Cybersecurity Portfolio</p>
        </footer>

        <script>
            function searchCVEs() {
                const input = document.getElementById('searchInput').value.toLowerCase();
                const cveEntries = document.getElementsByClassName('cve-entry');
                for (let i = 0; i < cveEntries.length; i++) {
                    const cveId = cveEntries[i].getAttribute('data-cve-id').toLowerCase();
                    const description = cveEntries[i].getAttribute('data-description');
                    if (cveId.includes(input) || description.includes(input)) {
                        cveEntries[i].style.display = '';
                    } else {
                        cveEntries[i].style.display = 'none';
                    }
                }
            }
        </script>
    </body>
    </html>
    