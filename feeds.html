
    <!DOCTYPE html>
    <html lang="en">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <meta name="description" content="Security alerts and cybersecurity news feeds">
        <meta name="keywords" content="cybersecurity news, security alerts, vulnerability feeds, threat intelligence">
        <meta name="author" content="dotne1">
        <meta property="og:title" content="Security Feeds - dotne1's Cybersecurity Portfolio">
        <meta property="og:description" content="Stay updated with the latest cybersecurity news and alerts">
        <meta property="og:type" content="website">
        <title>Security Feeds - dotne1's Cybersecurity Portfolio</title>
        <link rel="stylesheet" href="styles.css">
        <link rel="icon" type="image/x-icon" href="/favicon.ico">
    </head>
    <body>
        <nav class="navbar">
            <div class="nav-links">
                <a href="index.html" class="nav-link">Home</a>
                <a href="about-me.html" class="nav-link">About Me</a>
                <a href="projects.html" class="nav-link">Projects</a>
                <a href="resume.html" class="nav-link">Resume</a>
                <a href="feeds.html" class="nav-link">Feeds</a>
            </div>
        </nav>

        <div class="container" role="main">
            <h1 class="main-header">Security Feeds</h1>
            <div class="search-bar">
                <input type="text" id="searchInput" placeholder="Search CVEs..." onkeyup="searchCVEs()">
            </div>
            <div class="feed-preview" id="cveFeed">
                <div class="feed-header">Latest Vulnerabilities</div>
    
                <div class="cve-entry" data-cve-id="CVE-2025-61789" data-description="icinga db web provides a graphical interface for icinga monitoring. before 1.1.4 and 1.2.3, an authorized user with access to icinga db web, can use a custom variable in a filter that is either protected by icingadb/protect/variables or hidden by icingadb/denylist/variables, to guess values assigned to it. versions 1.1.4 and 1.2.3 respond with an error if such a custom variable is used.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-61789" target="_blank">CVE-2025-61789</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-10-16 12:15:34 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">MEDIUM</span></p>
                    <p><span class="feed-label">CVSS Score:</span> 5.3</p>
                    <p>Icinga DB Web provides a graphical interface for Icinga monitoring. Before 1.1.4 and 1.2.3, an authorized user with access to Icinga DB Web, can use a custom variable in a filter that is either protected by icingadb/protect/variables or hidden by icingadb/denylist/variables, to guess values assigned to it. Versions 1.1.4 and 1.2.3 respond with an error if such a custom variable is used.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-58051" data-description="nextcloud tables allows you to create your own tables with individual columns. prior 0.7.6, 0.8.8, and 0.9.5, when importing a table, a user was able to specify files on the server and when their format is supported by the used phpspreadsheet library they would be included and their content leaked to the user. it is recommended that the nextcloud tables app is upgraded to 0.7.6, 0.8.8 or 0.9.5.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-58051" target="_blank">CVE-2025-58051</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-10-16 12:15:34 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">MEDIUM</span></p>
                    <p><span class="feed-label">CVSS Score:</span> 6.5</p>
                    <p>Nextcloud Tables allows you to create your own tables with individual columns. Prior 0.7.6, 0.8.8, and 0.9.5, when importing a table, a user was able to specify files on the server and when their format is supported by the used PhpSpreadsheet library they would be included and their content leaked to the user. It is recommended that the Nextcloud Tables app is upgraded to 0.7.6, 0.8.8 or 0.9.5.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-56700" data-description="boolean sql injection vulnerability in the web app of base digitale group spa product centrax open psim version 6.1 allows a low level priviliged user that has access to the platform, to execute arbitrary sql commands via the datafine parameter.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-56700" target="_blank">CVE-2025-56700</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-10-16 12:15:34 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">N/A</span></p>
                    <p><span class="feed-label">CVSS Score:</span> N/A</p>
                    <p>Boolean SQL injection vulnerability in the web app of Base Digitale Group spa product Centrax Open PSIM version 6.1 allows a low level priviliged user that has access to the platform, to execute arbitrary SQL commands via the datafine parameter.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-56699" data-description="sql injection vulnerability in the cmd component of base digitale group spa product centrax open psim version 6.1 allows an unauthenticated user to execute arbitrary sql commands via the sender parameter.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-56699" target="_blank">CVE-2025-56699</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-10-16 12:15:34 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">N/A</span></p>
                    <p><span class="feed-label">CVSS Score:</span> N/A</p>
                    <p>SQL injection vulnerability in the cmd component of Base Digitale Group spa product Centrax Open PSIM version 6.1 allows an unauthenticated user to execute arbitrary SQL commands via the sender parameter.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-53092" data-description="strapi is an open source headless content management system. strapi versions prior to 5.20.0 contain a cors misconfiguration vulnerability in default installations. by default, strapi reflects the value of the origin header back in the access-control-allow-origin response header without proper validation or whitelisting. this allows an attacker-controlled site to send credentialed requests to the strapi backend. an attacker can exploit this by hosting a malicious site on a different origin (e.g., different port) and sending requests with credentials to the strapi api. the vulnerability is fixed in version 5.20.0. no known workarounds exist.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-53092" target="_blank">CVE-2025-53092</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-10-16 12:15:33 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">MEDIUM</span></p>
                    <p><span class="feed-label">CVSS Score:</span> 6.5</p>
                    <p>Strapi is an open source headless content management system. Strapi versions prior to 5.20.0 contain a CORS misconfiguration vulnerability in default installations. By default, Strapi reflects the value of the Origin header back in the Access-Control-Allow-Origin response header without proper validation or whitelisting. This allows an attacker-controlled site to send credentialed requests to the Strapi backend. An attacker can exploit this by hosting a malicious site on a different origin (e.g., different port) and sending requests with credentials to the Strapi API. The vulnerability is fixed in version 5.20.0. No known workarounds exist.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-36128" data-description="ibm mq 9.1, 9.2, 9.3, 9.4 lts and 9.3, 9.4 cd is vulnerable to a denial of service, caused by improper enforcement of the timeout on individual read operations. by conducting slowloris-type attacks, a remote attacker could exploit this vulnerability to cause a denial of service.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-36128" target="_blank">CVE-2025-36128</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-10-16 12:15:33 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-online">HIGH</span></p>
                    <p><span class="feed-label">CVSS Score:</span> 7.5</p>
                    <p>IBM MQ 9.1, 9.2, 9.3, 9.4 LTS and 9.3, 9.4 CD is vulnerable to a denial of service, caused by improper enforcement of the timeout on individual read operations. By conducting slowloris-type attacks, a remote attacker could exploit this vulnerability to cause a denial of service.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-25298" data-description="strapi is an open source headless cms. the @strapi/core package before version 5.10.3 does not enforce a maximum password length when using bcryptjs for password hashing. bcryptjs ignores any bytes beyond 72, so passwords longer than 72 bytes are silently truncated. a user can create an account with a password exceeding 72 bytes and later authenticate with only the first 72 bytes. this reduces the effective entropy of overlong passwords and may mislead users who believe characters beyond 72 bytes are required, creating a low likelihood of unintended authentication if an attacker can obtain or guess the truncated portion. long over‑length inputs can also impose unnecessary processing overhead. the issue is fixed in version 5.10.3. no known workarounds exist.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-25298" target="_blank">CVE-2025-25298</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-10-16 12:15:33 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">N/A</span></p>
                    <p><span class="feed-label">CVSS Score:</span> N/A</p>
                    <p>Strapi is an open source headless CMS. The @strapi/core package before version 5.10.3 does not enforce a maximum password length when using bcryptjs for password hashing. Bcryptjs ignores any bytes beyond 72, so passwords longer than 72 bytes are silently truncated. A user can create an account with a password exceeding 72 bytes and later authenticate with only the first 72 bytes. This reduces the effective entropy of overlong passwords and may mislead users who believe characters beyond 72 bytes are required, creating a low likelihood of unintended authentication if an attacker can obtain or guess the truncated portion. Long over‑length inputs can also impose unnecessary processing overhead. The issue is fixed in version 5.10.3. No known workarounds exist.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-11854" data-description="rejected reason: ** reject ** do not use this candidate number. consultids: cve-2025-22381. reason: this candidate is a reservation duplicate of cve-2025-22381. notes: all cve users should reference cve-2025-22381 instead of this candidate. all references and descriptions in this candidate have been removed to prevent accidental usage.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-11854" target="_blank">CVE-2025-11854</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-10-16 12:15:32 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">N/A</span></p>
                    <p><span class="feed-label">CVSS Score:</span> N/A</p>
                    <p>Rejected reason: ** REJECT ** DO NOT USE THIS CANDIDATE NUMBER. ConsultIDs: CVE-2025-22381. Reason: This candidate is a reservation duplicate of CVE-2025-22381. Notes: All CVE users should reference CVE-2025-22381 instead of this candidate. All references and descriptions in this candidate have been removed to prevent accidental usage.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-9559" data-description="pega platform versions 8.7.5 to infinity 24.2.2 are affected by a insecure direct object reference issue in a user interface component that can only be used to read data.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-9559" target="_blank">CVE-2025-9559</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-10-16 11:15:40 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">MEDIUM</span></p>
                    <p><span class="feed-label">CVSS Score:</span> 6.5</p>
                    <p>Pega Platform versions 8.7.5 to Infinity 24.2.2 are affected by a Insecure Direct Object Reference issue in a user interface component that can only be used to read data.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-62496" data-description="a vulnerability exists in the quickjs engine's bigint string parsing logic (js_bigint_from_string) when attempting to create a bigint from a string with an excessively large number of digits.

the function calculates the necessary number of bits (n_bits) required to store the bigint using the formula:

$$\text{n\_bits} = (\text{n\_digits} \times 27 + 7) / 8 \quad (\text{for radix 10})$$

  *  for large input strings (e.g., $79,536,432$ digits or more for base 10), the intermediate calculation $(\text{n\_digits} \times 27 + 7)$ exceeds the maximum value of a standard signed 32-bit integer, resulting in an integer overflow.


  *  the resulting n_bits value becomes unexpectedly small or even negative due to this wrap-around.


  *  this flawed n_bits is then used to compute n_limbs, the number of memory "limbs" needed for the bigint object. since n_bits is too small, the calculated n_limbs is also significantly underestimated.


  *  the function proceeds to allocate a jsbigint object using this underestimated n_limbs.


  *  when the function later attempts to write the actual bigint data into the allocated object, the small buffer size is quickly exceeded, leading to a heap out-of-bounds write as data is written past the end of the allocated r->tab array.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-62496" target="_blank">CVE-2025-62496</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-10-16 11:15:40 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">N/A</span></p>
                    <p><span class="feed-label">CVSS Score:</span> N/A</p>
                    <p>A vulnerability exists in the QuickJS engine's BigInt string parsing logic (js_bigint_from_string) when attempting to create a BigInt from a string with an excessively large number of digits.

The function calculates the necessary number of bits (n_bits) required to store the BigInt using the formula:

$$\text{n\_bits} = (\text{n\_digits} \times 27 + 7) / 8 \quad (\text{for radix 10})$$

  *  For large input strings (e.g., $79,536,432$ digits or more for base 10), the intermediate calculation $(\text{n\_digits} \times 27 + 7)$ exceeds the maximum value of a standard signed 32-bit integer, resulting in an Integer Overflow.


  *  The resulting n_bits value becomes unexpectedly small or even negative due to this wrap-around.


  *  This flawed n_bits is then used to compute n_limbs, the number of memory "limbs" needed for the BigInt object. Since n_bits is too small, the calculated n_limbs is also significantly underestimated.


  *  The function proceeds to allocate a JSBigInt object using this underestimated n_limbs.


  *  When the function later attempts to write the actual BigInt data into the allocated object, the small buffer size is quickly exceeded, leading to a Heap Out-of-Bounds Write as data is written past the end of the allocated r->tab array.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-62495" data-description="an integer overflow vulnerability exists in the quickjs regular expression engine (libregexp) due to an inconsistent representation of the bytecode buffer size.

  *  the regular expression bytecode is stored in a dynbuf structure, which correctly uses a $\text{size}\_\text{t}$ (an unsigned type, typically 64-bit) for its size member.


  *  however, several functions, such as re_emit_op_u32 and other internal parsing routines, incorrectly cast or store this dynbuf $\text{size}\_\text{t}$ value into a signed int (typically 32-bit).


  *  when a large or complex regular expression (such as those generated by a recursive pattern in a proof-of-concept) causes the bytecode size to exceed $2^{31}$ bytes (the maximum positive value for a signed 32-bit integer), the size value wraps around, resulting in a negative integer when stored in the int variable (integer overflow).


  *  this negative value is subsequently used in offset calculations. for example, within functions like re_parse_disjunction, the negative size is used to compute an offset (pos) for patching a jump instruction.


  *  this negative offset is then incorrectly added to the buffer pointer (s->byte\_code.buf + pos), leading to an out-of-bounds write on the first line of the snippet below:

put_u32(s->byte_code.buf + pos, len);">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-62495" target="_blank">CVE-2025-62495</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-10-16 11:15:40 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">N/A</span></p>
                    <p><span class="feed-label">CVSS Score:</span> N/A</p>
                    <p>An integer overflow vulnerability exists in the QuickJS regular expression engine (libregexp) due to an inconsistent representation of the bytecode buffer size.

  *  The regular expression bytecode is stored in a DynBuf structure, which correctly uses a $\text{size}\_\text{t}$ (an unsigned type, typically 64-bit) for its size member.


  *  However, several functions, such as re_emit_op_u32 and other internal parsing routines, incorrectly cast or store this DynBuf $\text{size}\_\text{t}$ value into a signed int (typically 32-bit).


  *  When a large or complex regular expression (such as those generated by a recursive pattern in a Proof-of-Concept) causes the bytecode size to exceed $2^{31}$ bytes (the maximum positive value for a signed 32-bit integer), the size value wraps around, resulting in a negative integer when stored in the int variable (Integer Overflow).


  *  This negative value is subsequently used in offset calculations. For example, within functions like re_parse_disjunction, the negative size is used to compute an offset (pos) for patching a jump instruction.


  *  This negative offset is then incorrectly added to the buffer pointer (s->byte\_code.buf + pos), leading to an out-of-bounds write on the first line of the snippet below:

put_u32(s->byte_code.buf + pos, len);</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-62494" data-description="a type confusion vulnerability exists in the handling of the string addition (+) operation within the quickjs engine.

  *  the code first checks if the left-hand operand is a string.


  *  it then attempts to convert the right-hand operand to a primitive value using js_toprimitivefree. this conversion can trigger a callback (e.g., tostring or valueof).


  *  during this callback, an attacker can modify the type of the left-hand operand in memory, changing it from a string to a different type (e.g., an object or an array).


  *  the code then proceeds to call js_concatstringinplace, which still treats the modified left-hand value as a string.


this mismatch between the assumed type (string) and the actual type allows an attacker to control the data structure being processed by the concatenation logic, resulting in a type confusion condition. this can lead to out-of-bounds memory access, potentially resulting in memory corruption and arbitrary code execution in the context of the quickjs runtime.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-62494" target="_blank">CVE-2025-62494</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-10-16 11:15:39 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">N/A</span></p>
                    <p><span class="feed-label">CVSS Score:</span> N/A</p>
                    <p>A type confusion vulnerability exists in the handling of the string addition (+) operation within the QuickJS engine.

  *  The code first checks if the left-hand operand is a string.


  *  It then attempts to convert the right-hand operand to a primitive value using JS_ToPrimitiveFree. This conversion can trigger a callback (e.g., toString or valueOf).


  *  During this callback, an attacker can modify the type of the left-hand operand in memory, changing it from a string to a different type (e.g., an object or an array).


  *  The code then proceeds to call JS_ConcatStringInPlace, which still treats the modified left-hand value as a string.


This mismatch between the assumed type (string) and the actual type allows an attacker to control the data structure being processed by the concatenation logic, resulting in a type confusion condition. This can lead to out-of-bounds memory access, potentially resulting in memory corruption and arbitrary code execution in the context of the QuickJS runtime.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-62493" data-description="a vulnerability exists in the quickjs engine's bigint string conversion logic (js_bigint_to_string1) due to an incorrect calculation of the required number of digits, which in turn leads to reading memory past the allocated bigint structure.

  *  the function determines the number of characters (n_digits) needed for the string representation by calculating:

$$ \\ \text{n\_digits} = (\text{n\_bits} + \text{log2\_radix} - 1) / \text{log2\_radix}$$

$$$$this formula is off-by-one in certain edge cases when calculating the necessary memory limbs. for instance, a 127-bit bigint using radix 32 (where $\text{log2\_radix}=5$) is calculated to need $\text{n\_digits}=26$.


  *  the maximum number of bits actually stored is $\text{n\_bits}=127$, which requires only two 64-bit limbs ($\text{js\_limb\_bits}=64$).


  *  the conversion loop iterates $\text{n\_digits}=26$ times, attempting to read 5 bits in each iteration, totaling $26 \times 5 = 130$ bits.


  *  in the final iterations of the loop, the code attempts to read data that spans two limbs:

c



c = (r->tab[pos] >> shift) | (r->tab[pos + 1] << (js_limb_bits - shift));









  *  since the bigint was only allocated two limbs, the read operation for r->tab[pos + 1] becomes an out-of-bounds read when pos points to the last valid limb (e.g., $pos=1$).


this vulnerability allows an attacker to cause the engine to read and process data from the memory immediately following the bigint buffer. this can lead to information disclosure of sensitive data stored on the heap adjacent to the bigint object.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-62493" target="_blank">CVE-2025-62493</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-10-16 11:15:39 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">N/A</span></p>
                    <p><span class="feed-label">CVSS Score:</span> N/A</p>
                    <p>A vulnerability exists in the QuickJS engine's BigInt string conversion logic (js_bigint_to_string1) due to an incorrect calculation of the required number of digits, which in turn leads to reading memory past the allocated BigInt structure.

  *  The function determines the number of characters (n_digits) needed for the string representation by calculating:

$$ \\ \text{n\_digits} = (\text{n\_bits} + \text{log2\_radix} - 1) / \text{log2\_radix}$$

$$$$This formula is off-by-one in certain edge cases when calculating the necessary memory limbs. For instance, a 127-bit BigInt using radix 32 (where $\text{log2\_radix}=5$) is calculated to need $\text{n\_digits}=26$.


  *  The maximum number of bits actually stored is $\text{n\_bits}=127$, which requires only two 64-bit limbs ($\text{JS\_LIMB\_BITS}=64$).


  *  The conversion loop iterates $\text{n\_digits}=26$ times, attempting to read 5 bits in each iteration, totaling $26 \times 5 = 130$ bits.


  *  In the final iterations of the loop, the code attempts to read data that spans two limbs:

C



c = (r->tab[pos] >> shift) | (r->tab[pos + 1] << (JS_LIMB_BITS - shift));









  *  Since the BigInt was only allocated two limbs, the read operation for r->tab[pos + 1] becomes an Out-of-Bounds Read when pos points to the last valid limb (e.g., $pos=1$).


This vulnerability allows an attacker to cause the engine to read and process data from the memory immediately following the BigInt buffer. This can lead to Information Disclosure of sensitive data stored on the heap adjacent to the BigInt object.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-62492" data-description="a vulnerability stemming from floating-point arithmetic precision errors exists in the quickjs engine's implementation of typedarray.prototype.indexof() when a negative fromindex argument is supplied.

  *  the fromindex argument (read as a double variable, $d$) is used to calculate the starting position for the search.


  *  if d is negative, the index is calculated relative to the end of the array by adding the array's length (len) to d:



$$d_{new} = d + \text{len}$$


  *  due to the inherent limitations of floating-point arithmetic, if the negative value $d$ is extremely small (e.g., $-1 \times 10^{-20}$), the addition $d + \text{len}$ can result in a loss of precision, yielding an outcome that is exactly equal to $\text{len}$.


  *  the result is then converted to an integer index $k$: $k = \text{len}$.


  *  the search function proceeds to read array elements starting from index $k$. since valid indices are $0$ to $\text{len}-1$, starting the read at index $\text{len}$ is one element past the end of the array.


this allows an attacker to cause an out-of-bounds read of one element immediately following the buffer. while the scope of this read is small (one element), it can potentially lead to information disclosure of adjacent memory contents, depending on the execution environment.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-62492" target="_blank">CVE-2025-62492</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-10-16 11:15:39 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">N/A</span></p>
                    <p><span class="feed-label">CVSS Score:</span> N/A</p>
                    <p>A vulnerability stemming from floating-point arithmetic precision errors exists in the QuickJS engine's implementation of TypedArray.prototype.indexOf() when a negative fromIndex argument is supplied.

  *  The fromIndex argument (read as a double variable, $d$) is used to calculate the starting position for the search.


  *  If d is negative, the index is calculated relative to the end of the array by adding the array's length (len) to d:



$$d_{new} = d + \text{len}$$


  *  Due to the inherent limitations of floating-point arithmetic, if the negative value $d$ is extremely small (e.g., $-1 \times 10^{-20}$), the addition $d + \text{len}$ can result in a loss of precision, yielding an outcome that is exactly equal to $\text{len}$.


  *  The result is then converted to an integer index $k$: $k = \text{len}$.


  *  The search function proceeds to read array elements starting from index $k$. Since valid indices are $0$ to $\text{len}-1$, starting the read at index $\text{len}$ is one element past the end of the array.


This allows an attacker to cause an Out-of-Bounds Read of one element immediately following the buffer. While the scope of this read is small (one element), it can potentially lead to Information Disclosure of adjacent memory contents, depending on the execution environment.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-62491" data-description="a use-after-free (uaf) vulnerability exists in the quickjs engine's standard library when iterating over the global list of unhandled rejected promises (ts->rejected_promise_list).

  *  the function js_std_promise_rejection_check attempts to iterate over the rejected_promise_list to report unhandled rejections using a standard list loop.


  *  the reason for a promise rejection is processed inside the loop, including calling js_std_dump_error1(ctx, rp->reason).


  *  if the promise rejection reason is an error object that defines a custom property getter (e.g., via object.defineproperty), this getter is executed during the error dumping process.


  *  the malicious custom getter can execute javascript code that calls catch() on the same rejected promise being processed.


  *  calling catch() internally triggers js_std_promise_rejection_tracker, which then removes and frees the current promise entry (jsrejectedpromiseentry) from the rejected_promise_list.


  *  since the list iteration continues using the now-freed memory pointer (el), the subsequent loop access results in a use-after-free condition.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-62491" target="_blank">CVE-2025-62491</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-10-16 11:15:39 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">N/A</span></p>
                    <p><span class="feed-label">CVSS Score:</span> N/A</p>
                    <p>A Use-After-Free (UAF) vulnerability exists in the QuickJS engine's standard library when iterating over the global list of unhandled rejected promises (ts->rejected_promise_list).

  *  The function js_std_promise_rejection_check attempts to iterate over the rejected_promise_list to report unhandled rejections using a standard list loop.


  *  The reason for a promise rejection is processed inside the loop, including calling js_std_dump_error1(ctx, rp->reason).


  *  If the promise rejection reason is an Error object that defines a custom property getter (e.g., via Object.defineProperty), this getter is executed during the error dumping process.


  *  The malicious custom getter can execute JavaScript code that calls catch() on the same rejected promise being processed.


  *  Calling catch() internally triggers js_std_promise_rejection_tracker, which then removes and frees the current promise entry (JSRejectedPromiseEntry) from the rejected_promise_list.


  *  Since the list iteration continues using the now-freed memory pointer (el), the subsequent loop access results in a Use-After-Free condition.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-62490" data-description="in quickjs, in js_print_object, when printing an array, the function first fetches the array length and then loops over it. the issue is, printing a value is not side-effect free. an attacker-defined callback could run during js_print_value, during which the array could get resized and len1 become out of bounds. this results in a use-after-free.a second instance occurs in the same function during printing of a map or set objects. the code iterates over ms->records list, but once again, elements could be removed from the list during js_print_value call.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-62490" target="_blank">CVE-2025-62490</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-10-16 11:15:39 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">N/A</span></p>
                    <p><span class="feed-label">CVSS Score:</span> N/A</p>
                    <p>In quickjs, in js_print_object, when printing an array, the function first fetches the array length and then loops over it. The issue is, printing a value is not side-effect free. An attacker-defined callback could run during js_print_value, during which the array could get resized and len1 become out of bounds. This results in a use-after-free.A second instance occurs in the same function during printing of a map or set objects. The code iterates over ms->records list, but once again, elements could be removed from the list during js_print_value call.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-55035" data-description="mattermost desktop app versions <=5.13.0 fail to manage modals in the mattermost desktop app that stops a user with a server that uses basic authentication from accessing their server which allows an attacker that provides a malicious server to the user to deny use of the desktop app via having the user configure the malicious server and forcing a modal popup that cannot be closed.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-55035" target="_blank">CVE-2025-55035</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-10-16 11:15:38 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">MEDIUM</span></p>
                    <p><span class="feed-label">CVSS Score:</span> 6.1</p>
                    <p>Mattermost Desktop App versions <=5.13.0 fail to manage modals in the Mattermost Desktop App that stops a user with a server that uses basic authentication from accessing their server which allows an attacker that provides a malicious server to the user to deny use of the Desktop App via having the user configure the malicious server and forcing a modal popup that cannot be closed.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-11851" data-description="a vulnerability has been found in apeman id71 en75.8.53.20. the affected element is an unknown function of the file /set_alias.cgi. such manipulation of the argument alias leads to cross site scripting. the attack can be executed remotely. the exploit has been disclosed to the public and may be used. the vendor was contacted early about this disclosure but did not respond in any way.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-11851" target="_blank">CVE-2025-11851</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-10-16 11:15:37 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">LOW</span></p>
                    <p><span class="feed-label">CVSS Score:</span> 3.5</p>
                    <p>A vulnerability has been found in Apeman ID71 EN75.8.53.20. The affected element is an unknown function of the file /set_alias.cgi. Such manipulation of the argument alias leads to cross site scripting. The attack can be executed remotely. The exploit has been disclosed to the public and may be used. The vendor was contacted early about this disclosure but did not respond in any way.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-11842" data-description="a security vulnerability has been detected in shazwazza smidge up to 4.5.1. the impacted element is an unknown function of the component bundle handler. the manipulation of the argument version leads to path traversal. remote exploitation of the attack is possible. upgrading to version 4.6.0 is sufficient to resolve this issue. it is recommended to upgrade the affected component.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-11842" target="_blank">CVE-2025-11842</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-10-16 11:15:37 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">MEDIUM</span></p>
                    <p><span class="feed-label">CVSS Score:</span> 6.3</p>
                    <p>A security vulnerability has been detected in Shazwazza Smidge up to 4.5.1. The impacted element is an unknown function of the component Bundle Handler. The manipulation of the argument Version leads to path traversal. Remote exploitation of the attack is possible. Upgrading to version 4.6.0 is sufficient to resolve this issue. It is recommended to upgrade the affected component.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-11840" data-description="a weakness has been identified in gnu binutils 2.45. the affected element is the function vfinfo of the file ldmisc.c. executing manipulation can lead to out-of-bounds read. the attack can only be executed locally. the exploit has been made available to the public and could be exploited. this patch is called 16357. it is best practice to apply a patch to resolve this issue.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-11840" target="_blank">CVE-2025-11840</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-10-16 11:15:37 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">LOW</span></p>
                    <p><span class="feed-label">CVSS Score:</span> 3.3</p>
                    <p>A weakness has been identified in GNU Binutils 2.45. The affected element is the function vfinfo of the file ldmisc.c. Executing manipulation can lead to out-of-bounds read. The attack can only be executed locally. The exploit has been made available to the public and could be exploited. This patch is called 16357. It is best practice to apply a patch to resolve this issue.</p>
                </div>
        
            </div>
        </div>

        <footer class="footer">
            <p>© 2025 dotne1 - Cybersecurity Portfolio</p>
        </footer>

        <script>
            function searchCVEs() {
                const input = document.getElementById('searchInput').value.toLowerCase();
                const cveEntries = document.getElementsByClassName('cve-entry');
                for (let i = 0; i < cveEntries.length; i++) {
                    const cveId = cveEntries[i].getAttribute('data-cve-id').toLowerCase();
                    const description = cveEntries[i].getAttribute('data-description');
                    if (cveId.includes(input) || description.includes(input)) {
                        cveEntries[i].style.display = '';
                    } else {
                        cveEntries[i].style.display = 'none';
                    }
                }
            }
        </script>
    </body>
    </html>
    