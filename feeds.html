
    <!DOCTYPE html>
    <html lang="en">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <meta name="description" content="Security alerts and cybersecurity news feeds">
        <meta name="keywords" content="cybersecurity news, security alerts, vulnerability feeds, threat intelligence">
        <meta name="author" content="dotne1">
        <meta property="og:title" content="Security Feeds - dotne1's Cybersecurity Portfolio">
        <meta property="og:description" content="Stay updated with the latest cybersecurity news and alerts">
        <meta property="og:type" content="website">
        <title>Security Feeds - dotne1's Cybersecurity Portfolio</title>
        <link rel="stylesheet" href="styles.css">
        <link rel="icon" type="image/x-icon" href="/favicon.ico">
    </head>
    <body>
        <nav class="navbar">
            <div class="nav-links">
                <a href="index.html" class="nav-link">Home</a>
                <a href="about-me.html" class="nav-link">About Me</a>
                <a href="projects.html" class="nav-link">Projects</a>
                <a href="resume.html" class="nav-link">Resume</a>
                <a href="feeds.html" class="nav-link">Feeds</a>
            </div>
        </nav>

        <div class="container" role="main">
            <h1 class="main-header">Security Feeds</h1>
            <div class="search-bar">
                <input type="text" id="searchInput" placeholder="Search CVEs..." onkeyup="searchCVEs()">
            </div>
            <div class="feed-preview" id="cveFeed">
                <div class="feed-header">Latest Vulnerabilities</div>
    
                <div class="cve-entry" data-cve-id="CVE-2026-24875" data-description="integer overflow or wraparound vulnerability in yoyofr modizer.this issue affects modizer: before 4.1.1.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2026-24875" target="_blank">CVE-2026-24875</a></h2>
                    <p><span class="feed-label">Published:</span> 2026-01-27 10:16:37 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-online">HIGH</span></p>
                    <p><span class="feed-label">CVSS Score:</span> 7.8</p>
                    <p>Integer Overflow or Wraparound vulnerability in yoyofr modizer.This issue affects modizer: before 4.1.1.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2026-24874" data-description="access of resource using incompatible type ('type confusion') vulnerability in themrdemonized xray-monolith.this issue affects xray-monolith: before 2025.12.30.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2026-24874" target="_blank">CVE-2026-24874</a></h2>
                    <p><span class="feed-label">Published:</span> 2026-01-27 10:16:36 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-online">CRITICAL</span></p>
                    <p><span class="feed-label">CVSS Score:</span> 9.1</p>
                    <p>Access of Resource Using Incompatible Type ('Type Confusion') vulnerability in themrdemonized xray-monolith.This issue affects xray-monolith: before 2025.12.30.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2026-24873" data-description="out-of-bounds read vulnerability in rinnegatamante lpp-vita.this issue affects lpp-vita: before lpp-vita r6.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2026-24873" target="_blank">CVE-2026-24873</a></h2>
                    <p><span class="feed-label">Published:</span> 2026-01-27 10:16:36 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-online">HIGH</span></p>
                    <p><span class="feed-label">CVSS Score:</span> 7.8</p>
                    <p>Out-of-bounds Read vulnerability in Rinnegatamante lpp-vita.This issue affects lpp-vita: before lpp-vita r6.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2026-24872" data-description="improper pointer arithmetic

 vulnerability in projectskyfire skyfire_548.this issue affects skyfire_548: before 5.4.8-stable5.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2026-24872" target="_blank">CVE-2026-24872</a></h2>
                    <p><span class="feed-label">Published:</span> 2026-01-27 10:16:36 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-online">CRITICAL</span></p>
                    <p><span class="feed-label">CVSS Score:</span> 9.8</p>
                    <p>improper pointer arithmetic

 vulnerability in ProjectSkyfire SkyFire_548.This issue affects SkyFire_548: before 5.4.8-stable5.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2026-24871" data-description="improper control of generation of code ('code injection') vulnerability in pilgrimage233 minecraft-rcon-manage.this issue affects minecraft-rcon-manage: before 3.0.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2026-24871" target="_blank">CVE-2026-24871</a></h2>
                    <p><span class="feed-label">Published:</span> 2026-01-27 10:16:36 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">N/A</span></p>
                    <p><span class="feed-label">CVSS Score:</span> N/A</p>
                    <p>Improper Control of Generation of Code ('Code Injection') vulnerability in pilgrimage233 Minecraft-Rcon-Manage.This issue affects Minecraft-Rcon-Manage: before 3.0.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2026-24870" data-description="exposure of sensitive information to an unauthorized actor vulnerability in ixray-team ixray-1.6-stcop.this issue affects ixray-1.6-stcop: before 1.3.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2026-24870" target="_blank">CVE-2026-24870</a></h2>
                    <p><span class="feed-label">Published:</span> 2026-01-27 10:16:36 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">LOW</span></p>
                    <p><span class="feed-label">CVSS Score:</span> 3.7</p>
                    <p>Exposure of Sensitive Information to an Unauthorized Actor vulnerability in ixray-team ixray-1.6-stcop.This issue affects ixray-1.6-stcop: before 1.3.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2026-24869" data-description="use-after-free in the layout: scrolling and overflow component. this vulnerability affects firefox < 147.0.2.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2026-24869" target="_blank">CVE-2026-24869</a></h2>
                    <p><span class="feed-label">Published:</span> 2026-01-27 10:16:36 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">N/A</span></p>
                    <p><span class="feed-label">CVSS Score:</span> N/A</p>
                    <p>Use-after-free in the Layout: Scrolling and Overflow component. This vulnerability affects Firefox < 147.0.2.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2026-24868" data-description="mitigation bypass in the privacy: anti-tracking component. this vulnerability affects firefox < 147.0.2.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2026-24868" target="_blank">CVE-2026-24868</a></h2>
                    <p><span class="feed-label">Published:</span> 2026-01-27 10:16:36 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">N/A</span></p>
                    <p><span class="feed-label">CVSS Score:</span> N/A</p>
                    <p>Mitigation bypass in the Privacy: Anti-Tracking component. This vulnerability affects Firefox < 147.0.2.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2026-24832" data-description="out-of-bounds write vulnerability in ixray-team ixray-1.6-stcop.this issue affects ixray-1.6-stcop: before 1.3.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2026-24832" target="_blank">CVE-2026-24832</a></h2>
                    <p><span class="feed-label">Published:</span> 2026-01-27 10:16:36 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-online">CRITICAL</span></p>
                    <p><span class="feed-label">CVSS Score:</span> 9.8</p>
                    <p>Out-of-bounds Write vulnerability in ixray-team ixray-1.6-stcop.This issue affects ixray-1.6-stcop: before 1.3.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2026-24831" data-description="loop with unreachable exit condition ('infinite loop') vulnerability in ixray-team ixray-1.6-stcop.this issue affects ixray-1.6-stcop: before 1.3.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2026-24831" target="_blank">CVE-2026-24831</a></h2>
                    <p><span class="feed-label">Published:</span> 2026-01-27 10:16:35 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-online">HIGH</span></p>
                    <p><span class="feed-label">CVSS Score:</span> 7.5</p>
                    <p>Loop with Unreachable Exit Condition ('Infinite Loop') vulnerability in ixray-team ixray-1.6-stcop.This issue affects ixray-1.6-stcop: before 1.3.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2026-22796" data-description="issue summary: a type confusion vulnerability exists in the signature
verification of signed pkcs#7 data where an asn1_type union member is
accessed without first validating the type, causing an invalid or null
pointer dereference when processing malformed pkcs#7 data.

impact summary: an application performing signature verification of pkcs#7
data or calling directly the pkcs7_digest_from_attributes() function can be
caused to dereference an invalid or null pointer when reading, resulting in
a denial of service.

the function pkcs7_digest_from_attributes() accesses the message digest attribute
value without validating its type. when the type is not v_asn1_octet_string,
this results in accessing invalid memory through the asn1_type union, causing
a crash.

exploiting this vulnerability requires an attacker to provide a malformed
signed pkcs#7 to an application that verifies it. the impact of the
exploit is just a denial of service, the pkcs7 api is legacy and applications
should be using the cms api instead. for these reasons the issue was
assessed as low severity.

the fips modules in 3.5, 3.4, 3.3 and 3.0 are not affected by this issue,
as the pkcs#7 parsing implementation is outside the openssl fips module
boundary.

openssl 3.6, 3.5, 3.4, 3.3, 3.0, 1.1.1 and 1.0.2 are vulnerable to this issue.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2026-22796" target="_blank">CVE-2026-22796</a></h2>
                    <p><span class="feed-label">Published:</span> 2026-01-27 10:16:35 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">N/A</span></p>
                    <p><span class="feed-label">CVSS Score:</span> N/A</p>
                    <p>Issue summary: A type confusion vulnerability exists in the signature
verification of signed PKCS#7 data where an ASN1_TYPE union member is
accessed without first validating the type, causing an invalid or NULL
pointer dereference when processing malformed PKCS#7 data.

Impact summary: An application performing signature verification of PKCS#7
data or calling directly the PKCS7_digest_from_attributes() function can be
caused to dereference an invalid or NULL pointer when reading, resulting in
a Denial of Service.

The function PKCS7_digest_from_attributes() accesses the message digest attribute
value without validating its type. When the type is not V_ASN1_OCTET_STRING,
this results in accessing invalid memory through the ASN1_TYPE union, causing
a crash.

Exploiting this vulnerability requires an attacker to provide a malformed
signed PKCS#7 to an application that verifies it. The impact of the
exploit is just a Denial of Service, the PKCS7 API is legacy and applications
should be using the CMS API instead. For these reasons the issue was
assessed as Low severity.

The FIPS modules in 3.5, 3.4, 3.3 and 3.0 are not affected by this issue,
as the PKCS#7 parsing implementation is outside the OpenSSL FIPS module
boundary.

OpenSSL 3.6, 3.5, 3.4, 3.3, 3.0, 1.1.1 and 1.0.2 are vulnerable to this issue.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2026-22795" data-description="issue summary: an invalid or null pointer dereference can happen in
an application processing a malformed pkcs#12 file.

impact summary: an application processing a malformed pkcs#12 file can be
caused to dereference an invalid or null pointer on memory read, resulting
in a denial of service.

a type confusion vulnerability exists in pkcs#12 parsing code where
an asn1_type union member is accessed without first validating the type,
causing an invalid pointer read.

the location is constrained to a 1-byte address space, meaning any
attempted pointer manipulation can only target addresses between 0x00 and 0xff.
this range corresponds to the zero page, which is unmapped on most modern
operating systems and will reliably result in a crash, leading only to a
denial of service. exploiting this issue also requires a user or application
to process a maliciously crafted pkcs#12 file. it is uncommon to accept
untrusted pkcs#12 files in applications as they are usually used to store
private keys which are trusted by definition. for these reasons, the issue
was assessed as low severity.

the fips modules in 3.5, 3.4, 3.3 and 3.0 are not affected by this issue,
as the pkcs12 implementation is outside the openssl fips module boundary.

openssl 3.6, 3.5, 3.4, 3.3, 3.0 and 1.1.1 are vulnerable to this issue.

openssl 1.0.2 is not affected by this issue.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2026-22795" target="_blank">CVE-2026-22795</a></h2>
                    <p><span class="feed-label">Published:</span> 2026-01-27 10:16:35 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">N/A</span></p>
                    <p><span class="feed-label">CVSS Score:</span> N/A</p>
                    <p>Issue summary: An invalid or NULL pointer dereference can happen in
an application processing a malformed PKCS#12 file.

Impact summary: An application processing a malformed PKCS#12 file can be
caused to dereference an invalid or NULL pointer on memory read, resulting
in a Denial of Service.

A type confusion vulnerability exists in PKCS#12 parsing code where
an ASN1_TYPE union member is accessed without first validating the type,
causing an invalid pointer read.

The location is constrained to a 1-byte address space, meaning any
attempted pointer manipulation can only target addresses between 0x00 and 0xFF.
This range corresponds to the zero page, which is unmapped on most modern
operating systems and will reliably result in a crash, leading only to a
Denial of Service. Exploiting this issue also requires a user or application
to process a maliciously crafted PKCS#12 file. It is uncommon to accept
untrusted PKCS#12 files in applications as they are usually used to store
private keys which are trusted by definition. For these reasons, the issue
was assessed as Low severity.

The FIPS modules in 3.5, 3.4, 3.3 and 3.0 are not affected by this issue,
as the PKCS12 implementation is outside the OpenSSL FIPS module boundary.

OpenSSL 3.6, 3.5, 3.4, 3.3, 3.0 and 1.1.1 are vulnerable to this issue.

OpenSSL 1.0.2 is not affected by this issue.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2026-0648" data-description="the vulnerability stems from an incorrect error-checking logic in the createcounter() function (in threadx/utility/rtos_compatibility_layers/osek/tx_osek.c) when handling the return value of osek_get_counter(). specifically, the current code checks if cntr_id equals 0u to determine failure, but @osek_get_counter() actually returns e_os_sys_stack (defined as 12u) when it fails. this mismatch causes the error branch to never execute even when the counter pool is exhausted.

as a result, when the counter pool is depleted, the code proceeds to cast the error code (12u) to a pointer (osek_counter *), creating a wild pointer. subsequent writes to members of this pointer lead to writes to illegal memory addresses (e.g., 0x0000000c), which can trigger immediate hardfaults or silent memory corruption.

this vulnerability poses significant risks, including potential denial-of-service attacks (via repeated calls to exhaust the counter pool) and unauthorized memory access.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2026-0648" target="_blank">CVE-2026-0648</a></h2>
                    <p><span class="feed-label">Published:</span> 2026-01-27 10:16:35 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-online">HIGH</span></p>
                    <p><span class="feed-label">CVSS Score:</span> 7.8</p>
                    <p>The vulnerability stems from an incorrect error-checking logic in the CreateCounter() function (in threadx/utility/rtos_compatibility_layers/OSEK/tx_osek.c) when handling the return value of osek_get_counter(). Specifically, the current code checks if cntr_id equals 0u to determine failure, but @osek_get_counter() actually returns E_OS_SYS_STACK (defined as 12U) when it fails. This mismatch causes the error branch to never execute even when the counter pool is exhausted.

As a result, when the counter pool is depleted, the code proceeds to cast the error code (12U) to a pointer (OSEK_COUNTER *), creating a wild pointer. Subsequent writes to members of this pointer lead to writes to illegal memory addresses (e.g., 0x0000000C), which can trigger immediate HardFaults or silent memory corruption.

This vulnerability poses significant risks, including potential denial-of-service attacks (via repeated calls to exhaust the counter pool) and unauthorized memory access.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-69565" data-description="code-projects mobile shop management system 1.0 is vulnerable to file upload in /exaddproduct.php.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-69565" target="_blank">CVE-2025-69565</a></h2>
                    <p><span class="feed-label">Published:</span> 2026-01-27 10:16:34 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">N/A</span></p>
                    <p><span class="feed-label">CVSS Score:</span> N/A</p>
                    <p>code-projects Mobile Shop Management System 1.0 is vulnerable to File Upload in /ExAddProduct.php.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-69421" data-description="issue summary: processing a malformed pkcs#12 file can trigger a null pointer
dereference in the pkcs12_item_decrypt_d2i_ex() function.

impact summary: a null pointer dereference can trigger a crash which leads to
denial of service for an application processing pkcs#12 files.

the pkcs12_item_decrypt_d2i_ex() function does not check whether the oct
parameter is null before dereferencing it. when called from
pkcs12_unpack_p7encdata() with a malformed pkcs#12 file, this parameter can
be null, causing a crash. the vulnerability is limited to denial of service
and cannot be escalated to achieve code execution or memory disclosure.

exploiting this issue requires an attacker to provide a malformed pkcs#12 file
to an application that processes it. for that reason the issue was assessed as
low severity according to our security policy.

the fips modules in 3.6, 3.5, 3.4, 3.3 and 3.0 are not affected by this issue,
as the pkcs#12 implementation is outside the openssl fips module boundary.

openssl 3.6, 3.5, 3.4, 3.3, 3.0, 1.1.1 and 1.0.2 are vulnerable to this issue.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-69421" target="_blank">CVE-2025-69421</a></h2>
                    <p><span class="feed-label">Published:</span> 2026-01-27 10:16:34 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">N/A</span></p>
                    <p><span class="feed-label">CVSS Score:</span> N/A</p>
                    <p>Issue summary: Processing a malformed PKCS#12 file can trigger a NULL pointer
dereference in the PKCS12_item_decrypt_d2i_ex() function.

Impact summary: A NULL pointer dereference can trigger a crash which leads to
Denial of Service for an application processing PKCS#12 files.

The PKCS12_item_decrypt_d2i_ex() function does not check whether the oct
parameter is NULL before dereferencing it. When called from
PKCS12_unpack_p7encdata() with a malformed PKCS#12 file, this parameter can
be NULL, causing a crash. The vulnerability is limited to Denial of Service
and cannot be escalated to achieve code execution or memory disclosure.

Exploiting this issue requires an attacker to provide a malformed PKCS#12 file
to an application that processes it. For that reason the issue was assessed as
Low severity according to our Security Policy.

The FIPS modules in 3.6, 3.5, 3.4, 3.3 and 3.0 are not affected by this issue,
as the PKCS#12 implementation is outside the OpenSSL FIPS module boundary.

OpenSSL 3.6, 3.5, 3.4, 3.3, 3.0, 1.1.1 and 1.0.2 are vulnerable to this issue.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-69420" data-description="issue summary: a type confusion vulnerability exists in the timestamp response
verification code where an asn1_type union member is accessed without first
validating the type, causing an invalid or null pointer dereference when
processing a malformed timestamp response file.

impact summary: an application calling ts_resp_verify_response() with a
malformed timestamp response can be caused to dereference an invalid or
null pointer when reading, resulting in a denial of service.

the functions ossl_ess_get_signing_cert() and ossl_ess_get_signing_cert_v2()
access the signing cert attribute value without validating its type.
when the type is not v_asn1_sequence, this results in accessing invalid memory
through the asn1_type union, causing a crash.

exploiting this vulnerability requires an attacker to provide a malformed
timestamp response to an application that verifies timestamp responses. the
timestamp protocol (rfc 3161) is not widely used and the impact of the
exploit is just a denial of service. for these reasons the issue was
assessed as low severity.

the fips modules in 3.5, 3.4, 3.3 and 3.0 are not affected by this issue,
as the timestamp response implementation is outside the openssl fips module
boundary.

openssl 3.6, 3.5, 3.4, 3.3, 3.0 and 1.1.1 are vulnerable to this issue.

openssl 1.0.2 is not affected by this issue.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-69420" target="_blank">CVE-2025-69420</a></h2>
                    <p><span class="feed-label">Published:</span> 2026-01-27 10:16:34 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">N/A</span></p>
                    <p><span class="feed-label">CVSS Score:</span> N/A</p>
                    <p>Issue summary: A type confusion vulnerability exists in the TimeStamp Response
verification code where an ASN1_TYPE union member is accessed without first
validating the type, causing an invalid or NULL pointer dereference when
processing a malformed TimeStamp Response file.

Impact summary: An application calling TS_RESP_verify_response() with a
malformed TimeStamp Response can be caused to dereference an invalid or
NULL pointer when reading, resulting in a Denial of Service.

The functions ossl_ess_get_signing_cert() and ossl_ess_get_signing_cert_v2()
access the signing cert attribute value without validating its type.
When the type is not V_ASN1_SEQUENCE, this results in accessing invalid memory
through the ASN1_TYPE union, causing a crash.

Exploiting this vulnerability requires an attacker to provide a malformed
TimeStamp Response to an application that verifies timestamp responses. The
TimeStamp protocol (RFC 3161) is not widely used and the impact of the
exploit is just a Denial of Service. For these reasons the issue was
assessed as Low severity.

The FIPS modules in 3.5, 3.4, 3.3 and 3.0 are not affected by this issue,
as the TimeStamp Response implementation is outside the OpenSSL FIPS module
boundary.

OpenSSL 3.6, 3.5, 3.4, 3.3, 3.0 and 1.1.1 are vulnerable to this issue.

OpenSSL 1.0.2 is not affected by this issue.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-69419" data-description="issue summary: calling pkcs12_get_friendlyname() function on a maliciously
crafted pkcs#12 file with a bmpstring (utf-16be) friendly name containing
non-ascii bmp code point can trigger a one byte write before the allocated
buffer.

impact summary: the out-of-bounds write can cause a memory corruption
which can have various consequences including a denial of service.

the openssl_uni2utf8() function performs a two-pass conversion of a pkcs#12
bmpstring (utf-16be) to utf-8. in the second pass, when emitting utf-8 bytes,
the helper function bmp_to_utf8() incorrectly forwards the remaining utf-16
source byte count as the destination buffer capacity to utf8_putc(). for bmp
code points above u+07ff, utf-8 requires three bytes, but the forwarded
capacity can be just two bytes. utf8_putc() then returns -1, and this negative
value is added to the output length without validation, causing the
length to become negative. the subsequent trailing nul byte is then written
at a negative offset, causing write outside of heap allocated buffer.

the vulnerability is reachable via the public pkcs12_get_friendlyname() api
when parsing attacker-controlled pkcs#12 files. while pkcs12_parse() uses a
different code path that avoids this issue, pkcs12_get_friendlyname() directly
invokes the vulnerable function. exploitation requires an attacker to provide
a malicious pkcs#12 file to be parsed by the application and the attacker
can just trigger a one zero byte write before the allocated buffer.
for that reason the issue was assessed as low severity according to our
security policy.

the fips modules in 3.6, 3.5, 3.4, 3.3 and 3.0 are not affected by this issue,
as the pkcs#12 implementation is outside the openssl fips module boundary.

openssl 3.6, 3.5, 3.4, 3.3, 3.0 and 1.1.1 are vulnerable to this issue.

openssl 1.0.2 is not affected by this issue.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-69419" target="_blank">CVE-2025-69419</a></h2>
                    <p><span class="feed-label">Published:</span> 2026-01-27 10:16:34 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">N/A</span></p>
                    <p><span class="feed-label">CVSS Score:</span> N/A</p>
                    <p>Issue summary: Calling PKCS12_get_friendlyname() function on a maliciously
crafted PKCS#12 file with a BMPString (UTF-16BE) friendly name containing
non-ASCII BMP code point can trigger a one byte write before the allocated
buffer.

Impact summary: The out-of-bounds write can cause a memory corruption
which can have various consequences including a Denial of Service.

The OPENSSL_uni2utf8() function performs a two-pass conversion of a PKCS#12
BMPString (UTF-16BE) to UTF-8. In the second pass, when emitting UTF-8 bytes,
the helper function bmp_to_utf8() incorrectly forwards the remaining UTF-16
source byte count as the destination buffer capacity to UTF8_putc(). For BMP
code points above U+07FF, UTF-8 requires three bytes, but the forwarded
capacity can be just two bytes. UTF8_putc() then returns -1, and this negative
value is added to the output length without validation, causing the
length to become negative. The subsequent trailing NUL byte is then written
at a negative offset, causing write outside of heap allocated buffer.

The vulnerability is reachable via the public PKCS12_get_friendlyname() API
when parsing attacker-controlled PKCS#12 files. While PKCS12_parse() uses a
different code path that avoids this issue, PKCS12_get_friendlyname() directly
invokes the vulnerable function. Exploitation requires an attacker to provide
a malicious PKCS#12 file to be parsed by the application and the attacker
can just trigger a one zero byte write before the allocated buffer.
For that reason the issue was assessed as Low severity according to our
Security Policy.

The FIPS modules in 3.6, 3.5, 3.4, 3.3 and 3.0 are not affected by this issue,
as the PKCS#12 implementation is outside the OpenSSL FIPS module boundary.

OpenSSL 3.6, 3.5, 3.4, 3.3, 3.0 and 1.1.1 are vulnerable to this issue.

OpenSSL 1.0.2 is not affected by this issue.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-69418" data-description="issue summary: when using the low-level ocb api directly with aes-ni or<br>other hardware-accelerated code paths, inputs whose length is not a multiple<br>of 16 bytes can leave the final partial block unencrypted and unauthenticated.<br><br>impact summary: the trailing 1-15 bytes of a message may be exposed in<br>cleartext on encryption and are not covered by the authentication tag,<br>allowing an attacker to read or tamper with those bytes without detection.<br><br>the low-level ocb encrypt and decrypt routines in the hardware-accelerated<br>stream path process full 16-byte blocks but do not advance the input/output<br>pointers. the subsequent tail-handling code then operates on the original<br>base pointers, effectively reprocessing the beginning of the buffer while<br>leaving the actual trailing bytes unprocessed. the authentication checksum<br>also excludes the true tail bytes.<br><br>however, typical openssl consumers using evp are not affected because the<br>higher-level evp and provider ocb implementations split inputs so that full<br>blocks and trailing partial blocks are processed in separate calls, avoiding<br>the problematic code path. additionally, tls does not use ocb ciphersuites.<br>the vulnerability only affects applications that call the low-level<br>crypto_ocb128_encrypt() or crypto_ocb128_decrypt() functions directly with<br>non-block-aligned lengths in a single call on hardware-accelerated builds.<br>for these reasons the issue was assessed as low severity.<br><br>the fips modules in 3.6, 3.5, 3.4, 3.3, 3.2, 3.1 and 3.0 are not affected<br>by this issue, as ocb mode is not a fips-approved algorithm.<br><br>openssl 3.6, 3.5, 3.4, 3.3, 3.0 and 1.1.1 are vulnerable to this issue.<br><br>openssl 1.0.2 is not affected by this issue.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-69418" target="_blank">CVE-2025-69418</a></h2>
                    <p><span class="feed-label">Published:</span> 2026-01-27 10:16:33 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">N/A</span></p>
                    <p><span class="feed-label">CVSS Score:</span> N/A</p>
                    <p>Issue summary: When using the low-level OCB API directly with AES-NI or<br>other hardware-accelerated code paths, inputs whose length is not a multiple<br>of 16 bytes can leave the final partial block unencrypted and unauthenticated.<br><br>Impact summary: The trailing 1-15 bytes of a message may be exposed in<br>cleartext on encryption and are not covered by the authentication tag,<br>allowing an attacker to read or tamper with those bytes without detection.<br><br>The low-level OCB encrypt and decrypt routines in the hardware-accelerated<br>stream path process full 16-byte blocks but do not advance the input/output<br>pointers. The subsequent tail-handling code then operates on the original<br>base pointers, effectively reprocessing the beginning of the buffer while<br>leaving the actual trailing bytes unprocessed. The authentication checksum<br>also excludes the true tail bytes.<br><br>However, typical OpenSSL consumers using EVP are not affected because the<br>higher-level EVP and provider OCB implementations split inputs so that full<br>blocks and trailing partial blocks are processed in separate calls, avoiding<br>the problematic code path. Additionally, TLS does not use OCB ciphersuites.<br>The vulnerability only affects applications that call the low-level<br>CRYPTO_ocb128_encrypt() or CRYPTO_ocb128_decrypt() functions directly with<br>non-block-aligned lengths in a single call on hardware-accelerated builds.<br>For these reasons the issue was assessed as Low severity.<br><br>The FIPS modules in 3.6, 3.5, 3.4, 3.3, 3.2, 3.1 and 3.0 are not affected<br>by this issue, as OCB mode is not a FIPS-approved algorithm.<br><br>OpenSSL 3.6, 3.5, 3.4, 3.3, 3.0 and 1.1.1 are vulnerable to this issue.<br><br>OpenSSL 1.0.2 is not affected by this issue.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-68670" data-description="xrdp is an open source rdp server. xrdp before v0.10.5 contains an unauthenticated stack-based buffer overflow vulnerability. the issue stems from improper bounds checking when processing user domain information during the connection sequence. if exploited, the vulnerability could allow remote attackers to execute arbitrary code on the target system. the vulnerability allows an attacker to overwrite the stack buffer and the return address, which could theoretically be used to redirect the execution flow. the impact of this vulnerability is lessened if a compiler flag has been used to build the xrdp executable with stack canary protection. if this is the case, a second vulnerability would need to be used to leak the stack canary value. upgrade to version 0.10.5 to receive a patch. additionally, do not rely on stack canary protection on production systems.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-68670" target="_blank">CVE-2025-68670</a></h2>
                    <p><span class="feed-label">Published:</span> 2026-01-27 10:16:16 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-online">CRITICAL</span></p>
                    <p><span class="feed-label">CVSS Score:</span> 9.1</p>
                    <p>xrdp is an open source RDP server. xrdp before v0.10.5 contains an unauthenticated stack-based buffer overflow vulnerability. The issue stems from improper bounds checking when processing user domain information during the connection sequence. If exploited, the vulnerability could allow remote attackers to execute arbitrary code on the target system. The vulnerability allows an attacker to overwrite the stack buffer and the return address, which could theoretically be used to redirect the execution flow. The impact of this vulnerability is lessened if a compiler flag has been used to build the xrdp executable with stack canary protection. If this is the case, a second vulnerability would need to be used to leak the stack canary value. Upgrade to version 0.10.5 to receive a patch. Additionally, do not rely on stack canary protection on production systems.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-68160" data-description="issue summary: writing large, newline-free data into a bio chain using the
line-buffering filter where the next bio performs short writes can trigger
a heap-based out-of-bounds write.

impact summary: this out-of-bounds write can cause memory corruption which
typically results in a crash, leading to denial of service for an application.

the line-buffering bio filter (bio_f_linebuffer) is not used by default in
tls/ssl data paths. in openssl command-line applications, it is typically
only pushed onto stdout/stderr on vms systems. third-party applications that
explicitly use this filter with a bio chain that can short-write and that
write large, newline-free data influenced by an attacker would be affected.
however, the circumstances where this could happen are unlikely to be under
attacker control, and bio_f_linebuffer is unlikely to be handling non-curated
data controlled by an attacker. for that reason the issue was assessed as
low severity.

the fips modules in 3.6, 3.5, 3.4, 3.3 and 3.0 are not affected by this issue,
as the bio implementation is outside the openssl fips module boundary.

openssl 3.6, 3.5, 3.4, 3.3, 3.0, 1.1.1 and 1.0.2 are vulnerable to this issue.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-68160" target="_blank">CVE-2025-68160</a></h2>
                    <p><span class="feed-label">Published:</span> 2026-01-27 10:16:15 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">N/A</span></p>
                    <p><span class="feed-label">CVSS Score:</span> N/A</p>
                    <p>Issue summary: Writing large, newline-free data into a BIO chain using the
line-buffering filter where the next BIO performs short writes can trigger
a heap-based out-of-bounds write.

Impact summary: This out-of-bounds write can cause memory corruption which
typically results in a crash, leading to Denial of Service for an application.

The line-buffering BIO filter (BIO_f_linebuffer) is not used by default in
TLS/SSL data paths. In OpenSSL command-line applications, it is typically
only pushed onto stdout/stderr on VMS systems. Third-party applications that
explicitly use this filter with a BIO chain that can short-write and that
write large, newline-free data influenced by an attacker would be affected.
However, the circumstances where this could happen are unlikely to be under
attacker control, and BIO_f_linebuffer is unlikely to be handling non-curated
data controlled by an attacker. For that reason the issue was assessed as
Low severity.

The FIPS modules in 3.6, 3.5, 3.4, 3.3 and 3.0 are not affected by this issue,
as the BIO implementation is outside the OpenSSL FIPS module boundary.

OpenSSL 3.6, 3.5, 3.4, 3.3, 3.0, 1.1.1 and 1.0.2 are vulnerable to this issue.</p>
                </div>
        
            </div>
        </div>

        <footer class="footer">
            <p>© 2025 dotne1 - Cybersecurity Portfolio</p>
        </footer>

        <script>
            function searchCVEs() {
                const input = document.getElementById('searchInput').value.toLowerCase();
                const cveEntries = document.getElementsByClassName('cve-entry');
                for (let i = 0; i < cveEntries.length; i++) {
                    const cveId = cveEntries[i].getAttribute('data-cve-id').toLowerCase();
                    const description = cveEntries[i].getAttribute('data-description');
                    if (cveId.includes(input) || description.includes(input)) {
                        cveEntries[i].style.display = '';
                    } else {
                        cveEntries[i].style.display = 'none';
                    }
                }
            }
        </script>
    </body>
    </html>
    