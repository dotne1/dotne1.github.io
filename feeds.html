
    <!DOCTYPE html>
    <html lang="en">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <meta name="description" content="Security alerts and cybersecurity news feeds">
        <meta name="keywords" content="cybersecurity news, security alerts, vulnerability feeds, threat intelligence">
        <meta name="author" content="dotne1">
        <meta property="og:title" content="Security Feeds - dotne1's Cybersecurity Portfolio">
        <meta property="og:description" content="Stay updated with the latest cybersecurity news and alerts">
        <meta property="og:type" content="website">
        <title>Security Feeds - dotne1's Cybersecurity Portfolio</title>
        <link rel="stylesheet" href="styles.css">
        <link rel="icon" type="image/x-icon" href="/favicon.ico">
    </head>
    <body>
        <nav class="navbar">
            <div class="nav-links">
                <a href="index.html" class="nav-link">Home</a>
                <a href="about-me.html" class="nav-link">About Me</a>
                <a href="projects.html" class="nav-link">Projects</a>
                <a href="resume.html" class="nav-link">Resume</a>
                <a href="feeds.html" class="nav-link">Feeds</a>
            </div>
        </nav>

        <div class="container" role="main">
            <h1 class="main-header">Security Feeds</h1>
            <div class="search-bar">
                <input type="text" id="searchInput" placeholder="Search CVEs..." onkeyup="searchCVEs()">
            </div>
            <div class="feed-preview" id="cveFeed">
                <div class="feed-header">Latest Vulnerabilities</div>
    
                <div class="cve-entry" data-cve-id="CVE-2026-22211" data-description="tinyos versions up to and including 2.1.2 contain a global buffer overflow vulnerability in the printfuart formatted output implementation used within the zigbee / ieee 802.15.4 networking stack. the implementation formats output into a fixed-size global buffer and concatenates strings for %s format specifiers using strcat() without verifying remaining buffer capacity. when printfuart is invoked with a caller-controlled string longer than the available space, the unbounded sprintf/strcat sequence writes past the end of debugbuf, resulting in global memory corruption. this can cause denial of service, unintended behavior, or information disclosure via corrupted adjacent global state or uart output.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2026-22211" target="_blank">CVE-2026-22211</a></h2>
                    <p><span class="feed-label">Published:</span> 2026-01-14 10:15:56 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">N/A</span></p>
                    <p><span class="feed-label">CVSS Score:</span> N/A</p>
                    <p>TinyOS versions up to and including 2.1.2 contain a global buffer overflow vulnerability in the printfUART formatted output implementation used within the ZigBee / IEEE 802.15.4 networking stack. The implementation formats output into a fixed-size global buffer and concatenates strings for %s format specifiers using strcat() without verifying remaining buffer capacity. When printfUART is invoked with a caller-controlled string longer than the available space, the unbounded sprintf/strcat sequence writes past the end of debugbuf, resulting in global memory corruption. This can cause denial of service, unintended behavior, or information disclosure via corrupted adjacent global state or UART output.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-67399" data-description="an issue in airth smart home aqi monitor bootloader v.1.005 allows a physically proximate attacker to obtain sensitive information via the uart port of the bk7231n controller (wi-fi and ble module) on the device is open to access">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-67399" target="_blank">CVE-2025-67399</a></h2>
                    <p><span class="feed-label">Published:</span> 2026-01-14 10:15:56 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">N/A</span></p>
                    <p><span class="feed-label">CVSS Score:</span> N/A</p>
                    <p>An issue in AIRTH SMART HOME AQI MONITOR Bootloader v.1.005 allows a physically proximate attacker to obtain sensitive information via the UART port of the BK7231N controller (Wi-Fi and BLE module) on the device is open to access</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-14242" data-description="a flaw was found in vsftpd. this vulnerability allows a denial of service (dos) via an integer overflow in the ls command parameter parsing, triggered by a remote, authenticated attacker sending a crafted stat command with a specific byte sequence.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-14242" target="_blank">CVE-2025-14242</a></h2>
                    <p><span class="feed-label">Published:</span> 2026-01-14 10:15:55 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">MEDIUM</span></p>
                    <p><span class="feed-label">CVSS Score:</span> 6.5</p>
                    <p>A flaw was found in vsftpd. This vulnerability allows a denial of service (DoS) via an integer overflow in the ls command parameter parsing, triggered by a remote, authenticated attacker sending a crafted STAT command with a specific byte sequence.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2026-22820" data-description="outray opensource ngrok alternative. prior to 0.1.5, a toctou race condition vulnerability allows a user to exceed the set number of active tunnels in their subscription plan. this vulnerability is fixed in 0.1.5.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2026-22820" target="_blank">CVE-2026-22820</a></h2>
                    <p><span class="feed-label">Published:</span> 2026-01-14 09:16:05 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">N/A</span></p>
                    <p><span class="feed-label">CVSS Score:</span> N/A</p>
                    <p>Outray openSource ngrok alternative. Prior to 0.1.5, a TOCTOU race condition vulnerability allows a user to exceed the set number of active tunnels in their subscription plan. This vulnerability is fixed in 0.1.5.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2026-22240" data-description="the vulnerability exists in bluvoyix due to an improper password storage implementation and subsequent exposure via unauthenticated apis. an unauthenticated remote attacker could exploit this vulnerability by sending specially crafted http requests to the vulnerable users api to retrieve the plaintext passwords of all user users. successful exploitation of this vulnerability could allow the attacker to gain full access to customers' data and completely compromise the targeted platform by logging in using an exposed admin email address and password.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2026-22240" target="_blank">CVE-2026-22240</a></h2>
                    <p><span class="feed-label">Published:</span> 2026-01-14 09:16:05 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">N/A</span></p>
                    <p><span class="feed-label">CVSS Score:</span> N/A</p>
                    <p>The vulnerability exists in BLUVOYIX due to an improper password storage implementation and subsequent exposure via unauthenticated APIs. An unauthenticated remote attacker could exploit this vulnerability by sending specially crafted HTTP requests to the vulnerable users API to retrieve the plaintext passwords of all user users. Successful exploitation of this vulnerability could allow the attacker to gain full access to customers' data and completely compromise the targeted platform by logging in using an exposed admin email address and password.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2026-22239" data-description="the vulnerability exists in bluvoyix due to design flaws in the email sending api. an unauthenticated remote attacker could exploit this vulnerability by sending specially crafted http requests to the vulnerable email sending api. successful exploitation of this vulnerability could allow the attacker to send unsolicited emails to anyone on behalf of the company.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2026-22239" target="_blank">CVE-2026-22239</a></h2>
                    <p><span class="feed-label">Published:</span> 2026-01-14 09:16:05 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">N/A</span></p>
                    <p><span class="feed-label">CVSS Score:</span> N/A</p>
                    <p>The vulnerability exists in BLUVOYIX due to design flaws in the email sending API. An unauthenticated remote attacker could exploit this vulnerability by sending specially crafted HTTP requests to the vulnerable email sending API. Successful exploitation of this vulnerability could allow the attacker to send unsolicited emails to anyone on behalf of the company.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2026-22238" data-description="the vulnerability exists in bluvoyix due to improper authentication in the bluvoyix admin apis. an unauthenticated remote attacker could exploit this vulnerability by sending specially crafted http requests to the vulnerable admin api to create a new user with admin privileges. successful exploitation of this vulnerability could allow the attacker to gain full access to customers' data and completely compromise the targeted platform by logging in to the newly-created admin user.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2026-22238" target="_blank">CVE-2026-22238</a></h2>
                    <p><span class="feed-label">Published:</span> 2026-01-14 09:16:05 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">N/A</span></p>
                    <p><span class="feed-label">CVSS Score:</span> N/A</p>
                    <p>The vulnerability exists in BLUVOYIX due to improper authentication in the BLUVOYIX admin APIs. An unauthenticated remote attacker could exploit this vulnerability by sending specially crafted HTTP requests to the vulnerable admin API to create a new user with admin privileges. Successful exploitation of this vulnerability could allow the attacker to gain full access to customers' data and completely compromise the targeted platform by logging in to the newly-created admin user.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2026-22237" data-description="the vulnerability exists in bluvoyix due to the exposure of sensitive internal api documentation. an unauthenticated remote attacker could exploit this vulnerability by sending specially crafted http requests to the apis exposed by the documentation. successful exploitation of this vulnerability could allow the attacker to cause damage to the targeted platform by abusing internal functionality.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2026-22237" target="_blank">CVE-2026-22237</a></h2>
                    <p><span class="feed-label">Published:</span> 2026-01-14 09:16:04 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">N/A</span></p>
                    <p><span class="feed-label">CVSS Score:</span> N/A</p>
                    <p>The vulnerability exists in BLUVOYIX due to the exposure of sensitive internal API documentation. An unauthenticated remote attacker could exploit this vulnerability by sending specially crafted HTTP requests to the APIs exposed by the documentation. Successful exploitation of this vulnerability could allow the attacker to cause damage to the targeted platform by abusing internal functionality.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2026-22236" data-description="the vulnerability exists in bluvoyix due to improper authentication in the bluvoyix backend apis. an unauthenticated remote attacker could exploit this vulnerability by sending specially crafted http requests to the vulnerable apis. successful exploitation of this vulnerability could allow the attacker to gain full access to customers' data and completely compromise the targeted platform.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2026-22236" target="_blank">CVE-2026-22236</a></h2>
                    <p><span class="feed-label">Published:</span> 2026-01-14 09:16:04 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">N/A</span></p>
                    <p><span class="feed-label">CVSS Score:</span> N/A</p>
                    <p>The vulnerability exists in BLUVOYIX due to improper authentication in the BLUVOYIX backend APIs. An unauthenticated remote attacker could exploit this vulnerability by sending specially crafted HTTP requests to the vulnerable APIs. Successful exploitation of this vulnerability could allow the attacker to gain full access to customers' data and completely compromise the targeted platform.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-9142" data-description="a local user can trigger harmony sase windows client to write or delete files outside the intended certificate working directory.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-9142" target="_blank">CVE-2025-9142</a></h2>
                    <p><span class="feed-label">Published:</span> 2026-01-14 09:16:04 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-online">HIGH</span></p>
                    <p><span class="feed-label">CVSS Score:</span> 7.5</p>
                    <p>A local user can trigger Harmony SASE Windows client to write or delete files outside the intended certificate working directory.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-71144" data-description="in the linux kernel, the following vulnerability has been resolved:

mptcp: ensure context reset on disconnect()

after the blamed commit below, if the mpc subflow is already in tcp_close
status or has fallback to tcp at mptcp_disconnect() time,
mptcp_do_fastclose() skips setting the `send_fastclose flag` and the later
__mptcp_close_ssk() does not reset anymore the related subflow context.

any later connection will be created with both the `request_mptcp` flag
and the msk-level fallback status off (it is unconditionally cleared at
mptcp disconnect time), leading to a warning in subflow_data_ready():

  warning: cpu: 26 pid: 8996 at net/mptcp/subflow.c:1519 subflow_data_ready (net/mptcp/subflow.c:1519 (discriminator 13))
  modules linked in:
  cpu: 26 uid: 0 pid: 8996 comm: syz.22.39 not tainted 6.18.0-rc7-05427-g11fc074f6c36 #1 preempt(voluntary)
  hardware name: bochs bochs, bios bochs 01/01/2011
  rip: 0010:subflow_data_ready (net/mptcp/subflow.c:1519 (discriminator 13))
  code: 90 0f 0b 90 90 e9 04 fe ff ff e8 b7 1e f5 fe 89 ee bf 07 00 00 00 e8 db 19 f5 fe 83 fd 07 0f 84 35 ff ff ff e8 9d 1e f5 fe 90 <0f> 0b 90 e9 27 ff ff ff e8 8f 1e f5 fe 4c 89 e7 48 89 de e8 14 09
  rsp: 0018:ffffc9002646fb30 eflags: 00010293
  rax: 0000000000000000 rbx: ffff88813b218000 rcx: ffffffff825c8435
  rdx: ffff8881300b3580 rsi: ffffffff825c8443 rdi: 0000000000000005
  rbp: 000000000000000b r08: ffffffff825c8435 r09: 000000000000000b
  r10: 0000000000000005 r11: 0000000000000007 r12: ffff888131ac0000
  r13: 0000000000000000 r14: 0000000000000000 r15: 0000000000000000
  fs:  00007f88330af6c0(0000) gs:ffff888a93dd2000(0000) knlgs:0000000000000000
  cs:  0010 ds: 0000 es: 0000 cr0: 0000000080050033
  cr2: 00007f88330aefe8 cr3: 000000010ff59000 cr4: 0000000000350ef0
  call trace:
   <task>
   tcp_data_ready (net/ipv4/tcp_input.c:5356)
   tcp_data_queue (net/ipv4/tcp_input.c:5445)
   tcp_rcv_state_process (net/ipv4/tcp_input.c:7165)
   tcp_v4_do_rcv (net/ipv4/tcp_ipv4.c:1955)
   __release_sock (include/net/sock.h:1158 (discriminator 6) net/core/sock.c:3180 (discriminator 6))
   release_sock (net/core/sock.c:3737)
   mptcp_sendmsg (net/mptcp/protocol.c:1763 net/mptcp/protocol.c:1857)
   inet_sendmsg (net/ipv4/af_inet.c:853 (discriminator 7))
   __sys_sendto (net/socket.c:727 (discriminator 15) net/socket.c:742 (discriminator 15) net/socket.c:2244 (discriminator 15))
   __x64_sys_sendto (net/socket.c:2247)
   do_syscall_64 (arch/x86/entry/syscall_64.c:63 (discriminator 1) arch/x86/entry/syscall_64.c:94 (discriminator 1))
   entry_syscall_64_after_hwframe (arch/x86/entry/entry_64.s:130)
  rip: 0033:0x7f883326702d

address the issue setting an explicit `fastclosing` flag at fastclose
time, and checking such flag after mptcp_do_fastclose().">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-71144" target="_blank">CVE-2025-71144</a></h2>
                    <p><span class="feed-label">Published:</span> 2026-01-14 09:16:04 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">N/A</span></p>
                    <p><span class="feed-label">CVSS Score:</span> N/A</p>
                    <p>In the Linux kernel, the following vulnerability has been resolved:

mptcp: ensure context reset on disconnect()

After the blamed commit below, if the MPC subflow is already in TCP_CLOSE
status or has fallback to TCP at mptcp_disconnect() time,
mptcp_do_fastclose() skips setting the `send_fastclose flag` and the later
__mptcp_close_ssk() does not reset anymore the related subflow context.

Any later connection will be created with both the `request_mptcp` flag
and the msk-level fallback status off (it is unconditionally cleared at
MPTCP disconnect time), leading to a warning in subflow_data_ready():

  WARNING: CPU: 26 PID: 8996 at net/mptcp/subflow.c:1519 subflow_data_ready (net/mptcp/subflow.c:1519 (discriminator 13))
  Modules linked in:
  CPU: 26 UID: 0 PID: 8996 Comm: syz.22.39 Not tainted 6.18.0-rc7-05427-g11fc074f6c36 #1 PREEMPT(voluntary)
  Hardware name: Bochs Bochs, BIOS Bochs 01/01/2011
  RIP: 0010:subflow_data_ready (net/mptcp/subflow.c:1519 (discriminator 13))
  Code: 90 0f 0b 90 90 e9 04 fe ff ff e8 b7 1e f5 fe 89 ee bf 07 00 00 00 e8 db 19 f5 fe 83 fd 07 0f 84 35 ff ff ff e8 9d 1e f5 fe 90 <0f> 0b 90 e9 27 ff ff ff e8 8f 1e f5 fe 4c 89 e7 48 89 de e8 14 09
  RSP: 0018:ffffc9002646fb30 EFLAGS: 00010293
  RAX: 0000000000000000 RBX: ffff88813b218000 RCX: ffffffff825c8435
  RDX: ffff8881300b3580 RSI: ffffffff825c8443 RDI: 0000000000000005
  RBP: 000000000000000b R08: ffffffff825c8435 R09: 000000000000000b
  R10: 0000000000000005 R11: 0000000000000007 R12: ffff888131ac0000
  R13: 0000000000000000 R14: 0000000000000000 R15: 0000000000000000
  FS:  00007f88330af6c0(0000) GS:ffff888a93dd2000(0000) knlGS:0000000000000000
  CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
  CR2: 00007f88330aefe8 CR3: 000000010ff59000 CR4: 0000000000350ef0
  Call Trace:
   <TASK>
   tcp_data_ready (net/ipv4/tcp_input.c:5356)
   tcp_data_queue (net/ipv4/tcp_input.c:5445)
   tcp_rcv_state_process (net/ipv4/tcp_input.c:7165)
   tcp_v4_do_rcv (net/ipv4/tcp_ipv4.c:1955)
   __release_sock (include/net/sock.h:1158 (discriminator 6) net/core/sock.c:3180 (discriminator 6))
   release_sock (net/core/sock.c:3737)
   mptcp_sendmsg (net/mptcp/protocol.c:1763 net/mptcp/protocol.c:1857)
   inet_sendmsg (net/ipv4/af_inet.c:853 (discriminator 7))
   __sys_sendto (net/socket.c:727 (discriminator 15) net/socket.c:742 (discriminator 15) net/socket.c:2244 (discriminator 15))
   __x64_sys_sendto (net/socket.c:2247)
   do_syscall_64 (arch/x86/entry/syscall_64.c:63 (discriminator 1) arch/x86/entry/syscall_64.c:94 (discriminator 1))
   entry_SYSCALL_64_after_hwframe (arch/x86/entry/entry_64.S:130)
  RIP: 0033:0x7f883326702d

Address the issue setting an explicit `fastclosing` flag at fastclose
time, and checking such flag after mptcp_do_fastclose().</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-71143" data-description="in the linux kernel, the following vulnerability has been resolved:

clk: samsung: exynos-clkout: assign .num before accessing .hws

commit f316cdff8d67 ("clk: annotate struct clk_hw_onecell_data with
__counted_by") annotated the hws member of 'struct clk_hw_onecell_data'
with __counted_by, which informs the bounds sanitizer (ubsan_bounds)
about the number of elements in .hws[], so that it can warn when .hws[]
is accessed out of bounds. as noted in that change, the __counted_by
member must be initialized with the number of elements before the first
array access happens, otherwise there will be a warning from each access
prior to the initialization because the number of elements is zero. this
occurs in exynos_clkout_probe() due to .num being assigned after .hws[]
has been accessed:

  ubsan: array-index-out-of-bounds in drivers/clk/samsung/clk-exynos-clkout.c:178:18
  index 0 is out of range for type 'clk_hw *[*]'

move the .num initialization to before the first access of .hws[],
clearing up the warning.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-71143" target="_blank">CVE-2025-71143</a></h2>
                    <p><span class="feed-label">Published:</span> 2026-01-14 09:16:04 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">N/A</span></p>
                    <p><span class="feed-label">CVSS Score:</span> N/A</p>
                    <p>In the Linux kernel, the following vulnerability has been resolved:

clk: samsung: exynos-clkout: Assign .num before accessing .hws

Commit f316cdff8d67 ("clk: Annotate struct clk_hw_onecell_data with
__counted_by") annotated the hws member of 'struct clk_hw_onecell_data'
with __counted_by, which informs the bounds sanitizer (UBSAN_BOUNDS)
about the number of elements in .hws[], so that it can warn when .hws[]
is accessed out of bounds. As noted in that change, the __counted_by
member must be initialized with the number of elements before the first
array access happens, otherwise there will be a warning from each access
prior to the initialization because the number of elements is zero. This
occurs in exynos_clkout_probe() due to .num being assigned after .hws[]
has been accessed:

  UBSAN: array-index-out-of-bounds in drivers/clk/samsung/clk-exynos-clkout.c:178:18
  index 0 is out of range for type 'clk_hw *[*]'

Move the .num initialization to before the first access of .hws[],
clearing up the warning.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-71142" data-description="in the linux kernel, the following vulnerability has been resolved:

cpuset: fix warning when disabling remote partition

a warning was triggered as follows:

warning: kernel/cgroup/cpuset.c:1651 at remote_partition_disable+0xf7/0x110
rip: 0010:remote_partition_disable+0xf7/0x110
rsp: 0018:ffffc90001947d88 eflags: 00000206
rax: 0000000000007fff rbx: ffff888103b6e000 rcx: 0000000000006f40
rdx: 0000000000006f00 rsi: ffffc90001947da8 rdi: ffff888103b6e000
rbp: ffff888103b6e000 r08: 0000000000000000 r09: 0000000000000000
r10: 0000000000000001 r11: ffff88810b2e2728 r12: ffffc90001947da8
r13: 0000000000000000 r14: ffffc90001947da8 r15: ffff8881081f1c00
cs:  0010 ds: 0000 es: 0000 cr0: 0000000080050033
cr2: 00007f55c8bbe0b2 cr3: 000000010b14c000 cr4: 00000000000006f0
call trace:
 <task>
 update_prstate+0x2d3/0x580
 cpuset_partition_write+0x94/0xf0
 kernfs_fop_write_iter+0x147/0x200
 vfs_write+0x35d/0x500
 ksys_write+0x66/0xe0
 do_syscall_64+0x6b/0x390
 entry_syscall_64_after_hwframe+0x4b/0x53
rip: 0033:0x7f55c8cd4887

reproduction steps (on a 16-cpu machine):

        # cd /sys/fs/cgroup/
        # mkdir a1
        # echo +cpuset > a1/cgroup.subtree_control
        # echo "0-14" > a1/cpuset.cpus.exclusive
        # mkdir a1/a2
        # echo "0-14" > a1/a2/cpuset.cpus.exclusive
        # echo "root" > a1/a2/cpuset.cpus.partition
        # echo 0 > /sys/devices/system/cpu/cpu15/online
        # echo member > a1/a2/cpuset.cpus.partition

when cpu 15 is offlined, subpartitions_cpus gets cleared because no cpus
remain available for the top_cpuset, forcing partitions to share cpus with
the top_cpuset. in this scenario, disabling the remote partition triggers
a warning stating that effective_xcpus is not a subset of
subpartitions_cpus. partitions should be invalidated in this case to
inform users that the partition is now invalid(cpus are shared with
top_cpuset).

to fix this issue:
1. only emit the warning only if subpartitions_cpus is not empty and the
   effective_xcpus is not a subset of subpartitions_cpus.
2. during the cpu hotplug process, invalidate partitions if
   subpartitions_cpus is empty.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-71142" target="_blank">CVE-2025-71142</a></h2>
                    <p><span class="feed-label">Published:</span> 2026-01-14 09:16:04 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">N/A</span></p>
                    <p><span class="feed-label">CVSS Score:</span> N/A</p>
                    <p>In the Linux kernel, the following vulnerability has been resolved:

cpuset: fix warning when disabling remote partition

A warning was triggered as follows:

WARNING: kernel/cgroup/cpuset.c:1651 at remote_partition_disable+0xf7/0x110
RIP: 0010:remote_partition_disable+0xf7/0x110
RSP: 0018:ffffc90001947d88 EFLAGS: 00000206
RAX: 0000000000007fff RBX: ffff888103b6e000 RCX: 0000000000006f40
RDX: 0000000000006f00 RSI: ffffc90001947da8 RDI: ffff888103b6e000
RBP: ffff888103b6e000 R08: 0000000000000000 R09: 0000000000000000
R10: 0000000000000001 R11: ffff88810b2e2728 R12: ffffc90001947da8
R13: 0000000000000000 R14: ffffc90001947da8 R15: ffff8881081f1c00
CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
CR2: 00007f55c8bbe0b2 CR3: 000000010b14c000 CR4: 00000000000006f0
Call Trace:
 <TASK>
 update_prstate+0x2d3/0x580
 cpuset_partition_write+0x94/0xf0
 kernfs_fop_write_iter+0x147/0x200
 vfs_write+0x35d/0x500
 ksys_write+0x66/0xe0
 do_syscall_64+0x6b/0x390
 entry_SYSCALL_64_after_hwframe+0x4b/0x53
RIP: 0033:0x7f55c8cd4887

Reproduction steps (on a 16-CPU machine):

        # cd /sys/fs/cgroup/
        # mkdir A1
        # echo +cpuset > A1/cgroup.subtree_control
        # echo "0-14" > A1/cpuset.cpus.exclusive
        # mkdir A1/A2
        # echo "0-14" > A1/A2/cpuset.cpus.exclusive
        # echo "root" > A1/A2/cpuset.cpus.partition
        # echo 0 > /sys/devices/system/cpu/cpu15/online
        # echo member > A1/A2/cpuset.cpus.partition

When CPU 15 is offlined, subpartitions_cpus gets cleared because no CPUs
remain available for the top_cpuset, forcing partitions to share CPUs with
the top_cpuset. In this scenario, disabling the remote partition triggers
a warning stating that effective_xcpus is not a subset of
subpartitions_cpus. Partitions should be invalidated in this case to
inform users that the partition is now invalid(cpus are shared with
top_cpuset).

To fix this issue:
1. Only emit the warning only if subpartitions_cpus is not empty and the
   effective_xcpus is not a subset of subpartitions_cpus.
2. During the CPU hotplug process, invalidate partitions if
   subpartitions_cpus is empty.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-71141" data-description="in the linux kernel, the following vulnerability has been resolved:

drm/tilcdc: fix removal actions in case of failed probe

the drm_kms_helper_poll_fini() and drm_atomic_helper_shutdown() helpers
should only be called when the device has been successfully registered.
currently, these functions are called unconditionally in tilcdc_fini(),
which causes warnings during probe deferral scenarios.

[    7.972317] warning: cpu: 0 pid: 23 at drivers/gpu/drm/drm_atomic_state_helper.c:175 drm_atomic_helper_crtc_duplicate_state+0x60/0x68
...
[    8.005820]  drm_atomic_helper_crtc_duplicate_state from drm_atomic_get_crtc_state+0x68/0x108
[    8.005858]  drm_atomic_get_crtc_state from drm_atomic_helper_disable_all+0x90/0x1c8
[    8.005885]  drm_atomic_helper_disable_all from drm_atomic_helper_shutdown+0x90/0x144
[    8.005911]  drm_atomic_helper_shutdown from tilcdc_fini+0x68/0xf8 [tilcdc]
[    8.005957]  tilcdc_fini [tilcdc] from tilcdc_pdev_probe+0xb0/0x6d4 [tilcdc]

fix this by rewriting the failed probe cleanup path using the standard
goto error handling pattern, which ensures that cleanup functions are
only called on successfully initialized resources. additionally, remove
the now-unnecessary is_registered flag.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-71141" target="_blank">CVE-2025-71141</a></h2>
                    <p><span class="feed-label">Published:</span> 2026-01-14 09:16:03 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">N/A</span></p>
                    <p><span class="feed-label">CVSS Score:</span> N/A</p>
                    <p>In the Linux kernel, the following vulnerability has been resolved:

drm/tilcdc: Fix removal actions in case of failed probe

The drm_kms_helper_poll_fini() and drm_atomic_helper_shutdown() helpers
should only be called when the device has been successfully registered.
Currently, these functions are called unconditionally in tilcdc_fini(),
which causes warnings during probe deferral scenarios.

[    7.972317] WARNING: CPU: 0 PID: 23 at drivers/gpu/drm/drm_atomic_state_helper.c:175 drm_atomic_helper_crtc_duplicate_state+0x60/0x68
...
[    8.005820]  drm_atomic_helper_crtc_duplicate_state from drm_atomic_get_crtc_state+0x68/0x108
[    8.005858]  drm_atomic_get_crtc_state from drm_atomic_helper_disable_all+0x90/0x1c8
[    8.005885]  drm_atomic_helper_disable_all from drm_atomic_helper_shutdown+0x90/0x144
[    8.005911]  drm_atomic_helper_shutdown from tilcdc_fini+0x68/0xf8 [tilcdc]
[    8.005957]  tilcdc_fini [tilcdc] from tilcdc_pdev_probe+0xb0/0x6d4 [tilcdc]

Fix this by rewriting the failed probe cleanup path using the standard
goto error handling pattern, which ensures that cleanup functions are
only called on successfully initialized resources. Additionally, remove
the now-unnecessary is_registered flag.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-71140" data-description="in the linux kernel, the following vulnerability has been resolved:

media: mediatek: vcodec: use spinlock for context list protection lock

previously a mutex was added to protect the encoder and decoder context
lists from unexpected changes originating from the scp ip block, causing
the context pointer to go invalid, resulting in a null pointer
dereference in the ipi handler.

turns out on the mt8173, the vpu ipi handler is called from hard irq
context. this causes a big warning from the scheduler. this was first
reported downstream on the chromeos kernels, but is also reproducible
on mainline using fluster with the ffmpeg v4l2m2m decoders. even though
the actual capture format is not supported, the affected code paths
are triggered.

since this lock just protects the context list and operations on it are
very fast, it should be ok to switch to a spinlock.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-71140" target="_blank">CVE-2025-71140</a></h2>
                    <p><span class="feed-label">Published:</span> 2026-01-14 09:16:03 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">N/A</span></p>
                    <p><span class="feed-label">CVSS Score:</span> N/A</p>
                    <p>In the Linux kernel, the following vulnerability has been resolved:

media: mediatek: vcodec: Use spinlock for context list protection lock

Previously a mutex was added to protect the encoder and decoder context
lists from unexpected changes originating from the SCP IP block, causing
the context pointer to go invalid, resulting in a NULL pointer
dereference in the IPI handler.

Turns out on the MT8173, the VPU IPI handler is called from hard IRQ
context. This causes a big warning from the scheduler. This was first
reported downstream on the ChromeOS kernels, but is also reproducible
on mainline using Fluster with the FFmpeg v4l2m2m decoders. Even though
the actual capture format is not supported, the affected code paths
are triggered.

Since this lock just protects the context list and operations on it are
very fast, it should be OK to switch to a spinlock.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-71139" data-description="in the linux kernel, the following vulnerability has been resolved:

kernel/kexec: fix ima when allocation happens in cma area

*** bug description ***

when i tested kexec with the latest kernel, i ran into the following warning:

[   40.712410] ------------[ cut here ]------------
[   40.712576] warning: cpu: 2 pid: 1562 at kernel/kexec_core.c:1001 kimage_map_segment+0x144/0x198
[...]
[   40.816047] call trace:
[   40.818498]  kimage_map_segment+0x144/0x198 (p)
[   40.823221]  ima_kexec_post_load+0x58/0xc0
[   40.827246]  __do_sys_kexec_file_load+0x29c/0x368
[...]
[   40.855423] ---[ end trace 0000000000000000 ]---

*** how to reproduce ***

this bug is only triggered when the kexec target address is allocated in
the cma area. if no cma area is reserved in the kernel, use the "cma="
option in the kernel command line to reserve one.

*** root cause ***
the commit 07d24902977e ("kexec: enable cma based contiguous
allocation") allocates the kexec target address directly on the cma area
to avoid copying during the jump. in this case, there is no ind_source
for the kexec segment.  but the current implementation of
kimage_map_segment() assumes that ind_source pages exist and map them
into a contiguous virtual address by vmap().

*** solution ***
if ima segment is allocated in the cma area, use its page_address()
directly.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-71139" target="_blank">CVE-2025-71139</a></h2>
                    <p><span class="feed-label">Published:</span> 2026-01-14 09:16:03 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">N/A</span></p>
                    <p><span class="feed-label">CVSS Score:</span> N/A</p>
                    <p>In the Linux kernel, the following vulnerability has been resolved:

kernel/kexec: fix IMA when allocation happens in CMA area

*** Bug description ***

When I tested kexec with the latest kernel, I ran into the following warning:

[   40.712410] ------------[ cut here ]------------
[   40.712576] WARNING: CPU: 2 PID: 1562 at kernel/kexec_core.c:1001 kimage_map_segment+0x144/0x198
[...]
[   40.816047] Call trace:
[   40.818498]  kimage_map_segment+0x144/0x198 (P)
[   40.823221]  ima_kexec_post_load+0x58/0xc0
[   40.827246]  __do_sys_kexec_file_load+0x29c/0x368
[...]
[   40.855423] ---[ end trace 0000000000000000 ]---

*** How to reproduce ***

This bug is only triggered when the kexec target address is allocated in
the CMA area. If no CMA area is reserved in the kernel, use the "cma="
option in the kernel command line to reserve one.

*** Root cause ***
The commit 07d24902977e ("kexec: enable CMA based contiguous
allocation") allocates the kexec target address directly on the CMA area
to avoid copying during the jump. In this case, there is no IND_SOURCE
for the kexec segment.  But the current implementation of
kimage_map_segment() assumes that IND_SOURCE pages exist and map them
into a contiguous virtual address by vmap().

*** Solution ***
If IMA segment is allocated in the CMA area, use its page_address()
directly.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-71138" data-description="in the linux kernel, the following vulnerability has been resolved:

drm/msm/dpu: add missing null pointer check for pingpong interface

it is checked almost always in dpu_encoder_phys_wb_setup_ctl(), but in a
single place the check is missing.
also use convenient locals instead of phys_enc->* where available.

patchwork: https://patchwork.freedesktop.org/patch/693860/">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-71138" target="_blank">CVE-2025-71138</a></h2>
                    <p><span class="feed-label">Published:</span> 2026-01-14 09:16:03 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">N/A</span></p>
                    <p><span class="feed-label">CVSS Score:</span> N/A</p>
                    <p>In the Linux kernel, the following vulnerability has been resolved:

drm/msm/dpu: Add missing NULL pointer check for pingpong interface

It is checked almost always in dpu_encoder_phys_wb_setup_ctl(), but in a
single place the check is missing.
Also use convenient locals instead of phys_enc->* where available.

Patchwork: https://patchwork.freedesktop.org/patch/693860/</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-71137" data-description="in the linux kernel, the following vulnerability has been resolved:

octeontx2-pf: fix "ubsan: shift-out-of-bounds error"

this patch ensures that the rx ring size (rx_pending) is not
set below the permitted length. this avoids ubsan
shift-out-of-bounds errors when users passes small or zero
ring sizes via ethtool -g.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-71137" target="_blank">CVE-2025-71137</a></h2>
                    <p><span class="feed-label">Published:</span> 2026-01-14 09:16:03 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">N/A</span></p>
                    <p><span class="feed-label">CVSS Score:</span> N/A</p>
                    <p>In the Linux kernel, the following vulnerability has been resolved:

octeontx2-pf: fix "UBSAN: shift-out-of-bounds error"

This patch ensures that the RX ring size (rx_pending) is not
set below the permitted length. This avoids UBSAN
shift-out-of-bounds errors when users passes small or zero
ring sizes via ethtool -G.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-71136" data-description="in the linux kernel, the following vulnerability has been resolved:

media: adv7842: avoid possible out-of-bounds array accesses in adv7842_cp_log_status()

it's possible for cp_read() and hdmi_read() to return -eio. those
values are further used as indexes for accessing arrays.

fix that by checking return values where it's needed.

found by linux verification center (linuxtesting.org) with svace.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-71136" target="_blank">CVE-2025-71136</a></h2>
                    <p><span class="feed-label">Published:</span> 2026-01-14 09:16:03 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">N/A</span></p>
                    <p><span class="feed-label">CVSS Score:</span> N/A</p>
                    <p>In the Linux kernel, the following vulnerability has been resolved:

media: adv7842: Avoid possible out-of-bounds array accesses in adv7842_cp_log_status()

It's possible for cp_read() and hdmi_read() to return -EIO. Those
values are further used as indexes for accessing arrays.

Fix that by checking return values where it's needed.

Found by Linux Verification Center (linuxtesting.org) with SVACE.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-71135" data-description="in the linux kernel, the following vulnerability has been resolved:

md/raid5: fix possible null-pointer dereferences in raid5_store_group_thread_cnt()

the variable mddev->private is first assigned to conf and then checked:

  conf = mddev->private;
  if (!conf) ...

if conf is null, then mddev->private is also null. in this case,
null-pointer dereferences can occur when calling raid5_quiesce():

  raid5_quiesce(mddev, true);
  raid5_quiesce(mddev, false);

since mddev->private is assigned to conf again in raid5_quiesce(), and conf
is dereferenced in several places, for example:

  conf->quiesce = 0;
  wake_up(&conf->wait_for_quiescent);

to fix this issue, the function should unlock mddev and return before
invoking raid5_quiesce() when conf is null, following the existing pattern
in raid5_change_consistency_policy().">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-71135" target="_blank">CVE-2025-71135</a></h2>
                    <p><span class="feed-label">Published:</span> 2026-01-14 09:16:03 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">N/A</span></p>
                    <p><span class="feed-label">CVSS Score:</span> N/A</p>
                    <p>In the Linux kernel, the following vulnerability has been resolved:

md/raid5: fix possible null-pointer dereferences in raid5_store_group_thread_cnt()

The variable mddev->private is first assigned to conf and then checked:

  conf = mddev->private;
  if (!conf) ...

If conf is NULL, then mddev->private is also NULL. In this case,
null-pointer dereferences can occur when calling raid5_quiesce():

  raid5_quiesce(mddev, true);
  raid5_quiesce(mddev, false);

since mddev->private is assigned to conf again in raid5_quiesce(), and conf
is dereferenced in several places, for example:

  conf->quiesce = 0;
  wake_up(&conf->wait_for_quiescent);

To fix this issue, the function should unlock mddev and return before
invoking raid5_quiesce() when conf is NULL, following the existing pattern
in raid5_change_consistency_policy().</p>
                </div>
        
            </div>
        </div>

        <footer class="footer">
            <p>Â© 2025 dotne1 - Cybersecurity Portfolio</p>
        </footer>

        <script>
            function searchCVEs() {
                const input = document.getElementById('searchInput').value.toLowerCase();
                const cveEntries = document.getElementsByClassName('cve-entry');
                for (let i = 0; i < cveEntries.length; i++) {
                    const cveId = cveEntries[i].getAttribute('data-cve-id').toLowerCase();
                    const description = cveEntries[i].getAttribute('data-description');
                    if (cveId.includes(input) || description.includes(input)) {
                        cveEntries[i].style.display = '';
                    } else {
                        cveEntries[i].style.display = 'none';
                    }
                }
            }
        </script>
    </body>
    </html>
    