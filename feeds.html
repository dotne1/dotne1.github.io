
    <!DOCTYPE html>
    <html lang="en">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <meta name="description" content="Security alerts and cybersecurity news feeds">
        <meta name="keywords" content="cybersecurity news, security alerts, vulnerability feeds, threat intelligence">
        <meta name="author" content="dotne1">
        <meta property="og:title" content="Security Feeds - dotne1's Cybersecurity Portfolio">
        <meta property="og:description" content="Stay updated with the latest cybersecurity news and alerts">
        <meta property="og:type" content="website">
        <title>Security Feeds - dotne1's Cybersecurity Portfolio</title>
        <link rel="stylesheet" href="styles.css">
        <link rel="icon" type="image/x-icon" href="/favicon.ico">
    </head>
    <body>
        <nav class="navbar">
            <div class="nav-links">
                <a href="index.html" class="nav-link">Home</a>
                <a href="about-me.html" class="nav-link">About Me</a>
                <a href="projects.html" class="nav-link">Projects</a>
                <a href="resume.html" class="nav-link">Resume</a>
                <a href="feeds.html" class="nav-link">Feeds</a>
            </div>
        </nav>

        <div class="container" role="main">
            <h1 class="main-header">Security Feeds</h1>
            <div class="search-bar">
                <input type="text" id="searchInput" placeholder="Search CVEs..." onkeyup="searchCVEs()">
            </div>
            <div class="feed-preview" id="cveFeed">
                <div class="feed-header">Latest Vulnerabilities</div>
    
                <div class="cve-entry" data-cve-id="CVE-2025-55741" data-description="unopim is an open-source product information management (pim) system built on the laravel framework. in versions 0.3.0 and earlier, users without the delete privilege for products are unable to delete individual products via the standard endpoint, as expected. however, these users can bypass intended access controls by issuing requests to the mass-delete endpoint, allowing them to delete products without proper authorization. this vulnerability allows unauthorized product deletion, leading to potential data loss and business disruption. the issue is fixed in version 0.3.1. no known workarounds exist.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-55741" target="_blank">CVE-2025-55741</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-08-22 11:15:46 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-online">HIGH</span></p>
                    <p><span class="feed-label">CVSS Score:</span> 8.1</p>
                    <p>UnoPim is an open-source Product Information Management (PIM) system built on the Laravel framework. In versions 0.3.0 and earlier, users without the Delete privilege for products are unable to delete individual products via the standard endpoint, as expected. However, these users can bypass intended access controls by issuing requests to the mass-delete endpoint, allowing them to delete products without proper authorization. This vulnerability allows unauthorized product deletion, leading to potential data loss and business disruption. The issue is fixed in version 0.3.1. No known workarounds exist.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-55611" data-description="d-link dir-619l 2.06b01 is vulnerable to buffer overflow in the formlanguagechange function via the nextpage parameter.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-55611" target="_blank">CVE-2025-55611</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-08-22 11:15:45 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">N/A</span></p>
                    <p><span class="feed-label">CVSS Score:</span> N/A</p>
                    <p>D-Link DIR-619L 2.06B01 is vulnerable to Buffer Overflow in the formLanguageChange function via the nextPage parameter.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-55606" data-description="tenda ax3 v16.03.12.10_cn is vulnerable to buffer overflow in the fromadvsetmacmtuwan function via the servername parameter.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-55606" target="_blank">CVE-2025-55606</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-08-22 11:15:45 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">N/A</span></p>
                    <p><span class="feed-label">CVSS Score:</span> N/A</p>
                    <p>Tenda AX3 V16.03.12.10_CN is vulnerable to Buffer Overflow in the fromAdvSetMacMtuWan function via the serverName parameter.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-55605" data-description="tenda ax3 v16.03.12.10_cn is vulnerable to buffer overflow in the saveparentcontrolinfo function via the devicename parameter.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-55605" target="_blank">CVE-2025-55605</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-08-22 11:15:45 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">N/A</span></p>
                    <p><span class="feed-label">CVSS Score:</span> N/A</p>
                    <p>Tenda AX3 V16.03.12.10_CN is vulnerable to Buffer Overflow in the saveParentControlInfo function via the deviceName parameter.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-55603" data-description="tenda ax3 v16.03.12.10_cn is vulnerable to buffer overflow in the fromsetsystime function via the ntpserver parameter.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-55603" target="_blank">CVE-2025-55603</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-08-22 11:15:45 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">N/A</span></p>
                    <p><span class="feed-label">CVSS Score:</span> N/A</p>
                    <p>Tenda AX3 V16.03.12.10_CN is vulnerable to Buffer Overflow in the fromSetSysTime function via the ntpServer parameter.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-55602" data-description="d-link dir-619l 2.06b01 is vulnerable to buffer overflow in the formsyscmd function via the submit-url parameter.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-55602" target="_blank">CVE-2025-55602</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-08-22 11:15:45 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">N/A</span></p>
                    <p><span class="feed-label">CVSS Score:</span> N/A</p>
                    <p>D-Link DIR-619L 2.06B01 is vulnerable to Buffer Overflow in the formSysCmd function via the submit-url parameter.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-55599" data-description="d-link dir-619l 2.06b01 is vulnerable to buffer overflow in the formwlansetup function via the parameter f_wds_wepkey.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-55599" target="_blank">CVE-2025-55599</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-08-22 11:15:45 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">N/A</span></p>
                    <p><span class="feed-label">CVSS Score:</span> N/A</p>
                    <p>D-Link DIR-619L 2.06B01 is vulnerable to Buffer Overflow in the formWlanSetup function via the parameter f_wds_wepKey.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-53363" data-description="dpanel is an open source server management panel written in go. in versions 1.2.0 through 1.7.2, dpanel allows authenticated users to read arbitrary files from the server via the /api/app/compose/get-from-uri api endpoint. the vulnerability exists in the getfromuri function in app/application/http/controller/compose.go, where the uri parameter is passed directly to os.readfile without proper validation or access control. a logged-in attacker can exploit this flaw to read sensitive files from the host system, leading to information disclosure. no patched version is available as of this writing.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-53363" target="_blank">CVE-2025-53363</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-08-22 11:15:44 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">N/A</span></p>
                    <p><span class="feed-label">CVSS Score:</span> N/A</p>
                    <p>dpanel is an open source server management panel written in Go. In versions 1.2.0 through 1.7.2, dpanel allows authenticated users to read arbitrary files from the server via the /api/app/compose/get-from-uri API endpoint. The vulnerability exists in the GetFromUri function in app/application/http/controller/compose.go, where the uri parameter is passed directly to os.ReadFile without proper validation or access control. A logged-in attacker can exploit this flaw to read sensitive files from the host system, leading to information disclosure. No patched version is available as of this writing.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-52095" data-description="an issue in pdq smart deploy v.3.0.2040 allows an attacker to escalate privileges via the credential encryption routines in sdcommon.dll">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-52095" target="_blank">CVE-2025-52095</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-08-22 11:15:44 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">N/A</span></p>
                    <p><span class="feed-label">CVSS Score:</span> N/A</p>
                    <p>An issue in PDQ Smart Deploy V.3.0.2040 allows an attacker to escalate privileges via the Credential encryption routines in SDCommon.dll</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-52094" data-description="insecure permissions vulnerability in pdq smart deploy v.3.0.2040 allows a local attacker to execute arbtirary code via the \hklm\system\setup\smartdeploy component">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-52094" target="_blank">CVE-2025-52094</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-08-22 11:15:44 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">N/A</span></p>
                    <p><span class="feed-label">CVSS Score:</span> N/A</p>
                    <p>Insecure Permissions vulnerability in PDQ Smart Deploy V.3.0.2040 allows a local attacker to execute arbtirary code via the \HKLM\SYSTEM\Setup\SmartDeploy component</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-51605" data-description="an issue was discovered in shopizer 3.2.7. the server's cors implementation reflects the client-supplied origin header verbatim into access-control-allow-origin without any whitelist validation, while also enabling access-control-allow-credentials: true. this allows any malicious origin to make authenticated cross-origin requests and read sensitive responses.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-51605" target="_blank">CVE-2025-51605</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-08-22 11:15:44 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-online">HIGH</span></p>
                    <p><span class="feed-label">CVSS Score:</span> 8.1</p>
                    <p>An issue was discovered in Shopizer 3.2.7. The server's CORS implementation reflects the client-supplied Origin header verbatim into Access-Control-Allow-Origin without any whitelist validation, while also enabling Access-Control-Allow-Credentials: true. This allows any malicious origin to make authenticated cross-origin requests and read sensitive responses.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-50733" data-description="nextchat contains a cross-site scripting (xss) vulnerability in the htmlpreview component of artifacts.tsx that allows attackers to execute arbitrary javascript code when html content is rendered in the ai chat interface. the vulnerability occurs because user-influenced html from ai responses is rendered in an iframe with 'allow-scripts' sandbox permission without proper sanitization. this can be exploited through specifically crafted prompts that cause the ai to generate malicious html/javascript code. when a user views the html preview, the injected javascript executes in the user's browser context, potentially allowing attackers to exfiltrate sensitive information (including api keys stored in localstorage), perform actions on behalf of the user, and steal session data.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-50733" target="_blank">CVE-2025-50733</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-08-22 11:15:43 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">N/A</span></p>
                    <p><span class="feed-label">CVSS Score:</span> N/A</p>
                    <p>NextChat contains a cross-site scripting (XSS) vulnerability in the HTMLPreview component of artifacts.tsx that allows attackers to execute arbitrary JavaScript code when HTML content is rendered in the AI chat interface. The vulnerability occurs because user-influenced HTML from AI responses is rendered in an iframe with 'allow-scripts' sandbox permission without proper sanitization. This can be exploited through specifically crafted prompts that cause the AI to generate malicious HTML/JavaScript code. When a user views the HTML preview, the injected JavaScript executes in the user's browser context, potentially allowing attackers to exfiltrate sensitive information (including API keys stored in localStorage), perform actions on behalf of the user, and steal session data.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-50674" data-description="an issue was discovered in the changepassword method in file /usr/share/php/openmediavault/system/user.inc in openmediavault 7.4.17 allowing local authenticated attackers to escalate privileges to root.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-50674" target="_blank">CVE-2025-50674</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-08-22 11:15:43 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-online">HIGH</span></p>
                    <p><span class="feed-label">CVSS Score:</span> 7.8</p>
                    <p>An issue was discovered in the changePassword method in file /usr/share/php/openmediavault/system/user.inc in OpenMediaVault 7.4.17 allowing local authenticated attackers to escalate privileges to root.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-43751" data-description="user enumeration vulnerability in liferay portal 7.4.0 through 7.4.3.132, and liferay dxp 2024.q4.0 through 2024.q4.7, 2024.q3.0 through 2024.q3.13, 2024.q2.0 through 2024.q2.13, 2024.q1.1 through 2024.q1.14, 2023.q4.0 through 2023.q4.10, 2023.q3.1 through 2023.q3.10 and 7.4 ga through update 92 allows remote attackers to determine if an account exist in the application via the create account page.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-43751" target="_blank">CVE-2025-43751</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-08-22 11:15:43 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">N/A</span></p>
                    <p><span class="feed-label">CVSS Score:</span> N/A</p>
                    <p>User enumeration vulnerability in Liferay Portal 7.4.0 through 7.4.3.132, and Liferay DXP 2024.Q4.0 through 2024.Q4.7, 2024.Q3.0 through 2024.Q3.13, 2024.Q2.0 through 2024.Q2.13, 2024.Q1.1 through 2024.Q1.14, 2023.Q4.0 through 2023.Q4.10, 2023.Q3.1 through 2023.Q3.10 and 7.4 GA through update 92 allows remote attackers to determine if an account exist in the application via the create account page.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-38675" data-description="in the linux kernel, the following vulnerability has been resolved:

xfrm: state: initialize state_ptrs earlier in xfrm_state_find

in case of preemption, xfrm_state_look_at will find a different
pcpu_id and look up states for that other cpu. if we matched a state
for cpu2 in the state_cache while the lookup started on cpu1, we will
jump to "found", but the "best" state that we got will be ignored and
we will enter the "acquire" block. this block uses state_ptrs, which
isn't initialized at this point.

let's initialize state_ptrs just after taking rcu_read_lock. this will
also prevent a possible misuse in the future, if someone adjusts this
function.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-38675" target="_blank">CVE-2025-38675</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-08-22 11:15:43 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">N/A</span></p>
                    <p><span class="feed-label">CVSS Score:</span> N/A</p>
                    <p>In the Linux kernel, the following vulnerability has been resolved:

xfrm: state: initialize state_ptrs earlier in xfrm_state_find

In case of preemption, xfrm_state_look_at will find a different
pcpu_id and look up states for that other CPU. If we matched a state
for CPU2 in the state_cache while the lookup started on CPU1, we will
jump to "found", but the "best" state that we got will be ignored and
we will enter the "acquire" block. This block uses state_ptrs, which
isn't initialized at this point.

Let's initialize state_ptrs just after taking rcu_read_lock. This will
also prevent a possible misuse in the future, if someone adjusts this
function.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-38674" data-description="in the linux kernel, the following vulnerability has been resolved:

revert "drm/prime: use dma_buf from gem object instance"

this reverts commit f83a9b8c7fd0557b0c50784bfdc1bbe9140c9bf8.

the dma_buf field in struct drm_gem_object is not stable over the
object instance's lifetime. the field becomes null when user space
releases the final gem handle on the buffer object. this resulted
in a null-pointer deref.

workarounds in commit 5307dce878d4 ("drm/gem: acquire references on
gem handles for framebuffers") and commit f6bfc9afc751 ("drm/framebuffer:
acquire internal references on gem handles") only solved the problem
partially. they especially don't work for buffer objects without a drm
framebuffer associated.

hence, this revert to going back to using .import_attach->dmabuf.

v3:
- cc stable">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-38674" target="_blank">CVE-2025-38674</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-08-22 11:15:43 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">N/A</span></p>
                    <p><span class="feed-label">CVSS Score:</span> N/A</p>
                    <p>In the Linux kernel, the following vulnerability has been resolved:

Revert "drm/prime: Use dma_buf from GEM object instance"

This reverts commit f83a9b8c7fd0557b0c50784bfdc1bbe9140c9bf8.

The dma_buf field in struct drm_gem_object is not stable over the
object instance's lifetime. The field becomes NULL when user space
releases the final GEM handle on the buffer object. This resulted
in a NULL-pointer deref.

Workarounds in commit 5307dce878d4 ("drm/gem: Acquire references on
GEM handles for framebuffers") and commit f6bfc9afc751 ("drm/framebuffer:
Acquire internal references on GEM handles") only solved the problem
partially. They especially don't work for buffer objects without a DRM
framebuffer associated.

Hence, this revert to going back to using .import_attach->dmabuf.

v3:
- cc stable</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-38673" data-description="in the linux kernel, the following vulnerability has been resolved:

revert "drm/gem-framebuffer: use dma_buf from gem object instance"

this reverts commit cce16fcd7446dcff7480cd9d2b6417075ed81065.

the dma_buf field in struct drm_gem_object is not stable over the
object instance's lifetime. the field becomes null when user space
releases the final gem handle on the buffer object. this resulted
in a null-pointer deref.

workarounds in commit 5307dce878d4 ("drm/gem: acquire references on
gem handles for framebuffers") and commit f6bfc9afc751 ("drm/framebuffer:
acquire internal references on gem handles") only solved the problem
partially. they especially don't work for buffer objects without a drm
framebuffer associated.

hence, this revert to going back to using .import_attach->dmabuf.

v3:
- cc stable">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-38673" target="_blank">CVE-2025-38673</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-08-22 11:15:42 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">N/A</span></p>
                    <p><span class="feed-label">CVSS Score:</span> N/A</p>
                    <p>In the Linux kernel, the following vulnerability has been resolved:

Revert "drm/gem-framebuffer: Use dma_buf from GEM object instance"

This reverts commit cce16fcd7446dcff7480cd9d2b6417075ed81065.

The dma_buf field in struct drm_gem_object is not stable over the
object instance's lifetime. The field becomes NULL when user space
releases the final GEM handle on the buffer object. This resulted
in a NULL-pointer deref.

Workarounds in commit 5307dce878d4 ("drm/gem: Acquire references on
GEM handles for framebuffers") and commit f6bfc9afc751 ("drm/framebuffer:
Acquire internal references on GEM handles") only solved the problem
partially. They especially don't work for buffer objects without a DRM
framebuffer associated.

Hence, this revert to going back to using .import_attach->dmabuf.

v3:
- cc stable</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-38672" data-description="in the linux kernel, the following vulnerability has been resolved:

revert "drm/gem-dma: use dma_buf from gem object instance"

this reverts commit e8afa1557f4f963c9a511bd2c6074a941c308685.

the dma_buf field in struct drm_gem_object is not stable over the
object instance's lifetime. the field becomes null when user space
releases the final gem handle on the buffer object. this resulted
in a null-pointer deref.

workarounds in commit 5307dce878d4 ("drm/gem: acquire references on
gem handles for framebuffers") and commit f6bfc9afc751 ("drm/framebuffer:
acquire internal references on gem handles") only solved the problem
partially. they especially don't work for buffer objects without a drm
framebuffer associated.

hence, this revert to going back to using .import_attach->dmabuf.

v3:
- cc stable">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-38672" target="_blank">CVE-2025-38672</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-08-22 11:15:42 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">N/A</span></p>
                    <p><span class="feed-label">CVSS Score:</span> N/A</p>
                    <p>In the Linux kernel, the following vulnerability has been resolved:

Revert "drm/gem-dma: Use dma_buf from GEM object instance"

This reverts commit e8afa1557f4f963c9a511bd2c6074a941c308685.

The dma_buf field in struct drm_gem_object is not stable over the
object instance's lifetime. The field becomes NULL when user space
releases the final GEM handle on the buffer object. This resulted
in a NULL-pointer deref.

Workarounds in commit 5307dce878d4 ("drm/gem: Acquire references on
GEM handles for framebuffers") and commit f6bfc9afc751 ("drm/framebuffer:
Acquire internal references on GEM handles") only solved the problem
partially. They especially don't work for buffer objects without a DRM
framebuffer associated.

Hence, this revert to going back to using .import_attach->dmabuf.

v3:
- cc stable</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-38671" data-description="in the linux kernel, the following vulnerability has been resolved:

i2c: qup: jump out of the loop in case of timeout

original logic only sets the return value but doesn't jump out of the
loop if the bus is kept active by a client. this is not expected. a
malicious or buggy i2c client can hang the kernel in this case and
should be avoided. this is observed during a long time test with a
pca953x gpio extender.

fix it by changing the logic to not only sets the return value, but also
jumps out of the loop and return to the caller with -etimedout.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-38671" target="_blank">CVE-2025-38671</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-08-22 11:15:42 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">N/A</span></p>
                    <p><span class="feed-label">CVSS Score:</span> N/A</p>
                    <p>In the Linux kernel, the following vulnerability has been resolved:

i2c: qup: jump out of the loop in case of timeout

Original logic only sets the return value but doesn't jump out of the
loop if the bus is kept active by a client. This is not expected. A
malicious or buggy i2c client can hang the kernel in this case and
should be avoided. This is observed during a long time test with a
PCA953x GPIO extender.

Fix it by changing the logic to not only sets the return value, but also
jumps out of the loop and return to the caller with -ETIMEDOUT.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-38670" data-description="in the linux kernel, the following vulnerability has been resolved:

arm64/entry: mask daif in cpu_switch_to(), call_on_irq_stack()

`cpu_switch_to()` and `call_on_irq_stack()` manipulate sp to change
to different stacks along with the shadow call stack if it is enabled.
those two stack changes cannot be done atomically and both functions
can be interrupted by serrors or debug exceptions which, though unlikely,
is very much broken : if interrupted, we can end up with mismatched stacks
and shadow call stack leading to clobbered stacks.

in `cpu_switch_to()`, it can happen when sp_el0 points to the new task,
but x18 stills points to the old task's scs. when the interrupt handler
tries to save the task's scs pointer, it will save the old task
scs pointer (x18) into the new task struct (pointed to by sp_el0),
clobbering it.

in `call_on_irq_stack()`, it can happen when switching from the task stack
to the irq stack and when switching back. in both cases, we can be
interrupted when the scs pointer points to the irq scs, but sp points to
the task stack. the nested interrupt handler pushes its return addresses
on the irq scs. it then detects that sp points to the task stack,
calls `call_on_irq_stack()` and clobbers the task scs pointer with
the irq scs pointer, which it will also use !

this leads to tasks returning to addresses on the wrong scs,
or even on the irq scs, triggering kernel panics via config_vmap_stack
or fpac if enabled.

this is possible on a default config, but unlikely.
however, when enabling config_arm64_pseudo_nmi, daif is unmasked and
instead the gic is responsible for filtering what interrupts the cpu
should receive based on priority.
given the goal of emulating nmis, pseudo-nmis can be received by the cpu
even in `cpu_switch_to()` and `call_on_irq_stack()`, possibly *very*
frequently depending on the system configuration and workload, leading
to unpredictable kernel panics.

completely mask daif in `cpu_switch_to()` and restore it when returning.
do the same in `call_on_irq_stack()`, but restore and mask around
the branch.
mask daif even if config_shadow_call_stack is not enabled for consistency
of behaviour between all configurations.

introduce and use an assembly macro for saving and masking daif,
as the existing one saves but only masks if.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-38670" target="_blank">CVE-2025-38670</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-08-22 11:15:42 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">N/A</span></p>
                    <p><span class="feed-label">CVSS Score:</span> N/A</p>
                    <p>In the Linux kernel, the following vulnerability has been resolved:

arm64/entry: Mask DAIF in cpu_switch_to(), call_on_irq_stack()

`cpu_switch_to()` and `call_on_irq_stack()` manipulate SP to change
to different stacks along with the Shadow Call Stack if it is enabled.
Those two stack changes cannot be done atomically and both functions
can be interrupted by SErrors or Debug Exceptions which, though unlikely,
is very much broken : if interrupted, we can end up with mismatched stacks
and Shadow Call Stack leading to clobbered stacks.

In `cpu_switch_to()`, it can happen when SP_EL0 points to the new task,
but x18 stills points to the old task's SCS. When the interrupt handler
tries to save the task's SCS pointer, it will save the old task
SCS pointer (x18) into the new task struct (pointed to by SP_EL0),
clobbering it.

In `call_on_irq_stack()`, it can happen when switching from the task stack
to the IRQ stack and when switching back. In both cases, we can be
interrupted when the SCS pointer points to the IRQ SCS, but SP points to
the task stack. The nested interrupt handler pushes its return addresses
on the IRQ SCS. It then detects that SP points to the task stack,
calls `call_on_irq_stack()` and clobbers the task SCS pointer with
the IRQ SCS pointer, which it will also use !

This leads to tasks returning to addresses on the wrong SCS,
or even on the IRQ SCS, triggering kernel panics via CONFIG_VMAP_STACK
or FPAC if enabled.

This is possible on a default config, but unlikely.
However, when enabling CONFIG_ARM64_PSEUDO_NMI, DAIF is unmasked and
instead the GIC is responsible for filtering what interrupts the CPU
should receive based on priority.
Given the goal of emulating NMIs, pseudo-NMIs can be received by the CPU
even in `cpu_switch_to()` and `call_on_irq_stack()`, possibly *very*
frequently depending on the system configuration and workload, leading
to unpredictable kernel panics.

Completely mask DAIF in `cpu_switch_to()` and restore it when returning.
Do the same in `call_on_irq_stack()`, but restore and mask around
the branch.
Mask DAIF even if CONFIG_SHADOW_CALL_STACK is not enabled for consistency
of behaviour between all configurations.

Introduce and use an assembly macro for saving and masking DAIF,
as the existing one saves but only masks IF.</p>
                </div>
        
            </div>
        </div>

        <footer class="footer">
            <p>Â© 2025 dotne1 - Cybersecurity Portfolio</p>
        </footer>

        <script>
            function searchCVEs() {
                const input = document.getElementById('searchInput').value.toLowerCase();
                const cveEntries = document.getElementsByClassName('cve-entry');
                for (let i = 0; i < cveEntries.length; i++) {
                    const cveId = cveEntries[i].getAttribute('data-cve-id').toLowerCase();
                    const description = cveEntries[i].getAttribute('data-description');
                    if (cveId.includes(input) || description.includes(input)) {
                        cveEntries[i].style.display = '';
                    } else {
                        cveEntries[i].style.display = 'none';
                    }
                }
            }
        </script>
    </body>
    </html>
    