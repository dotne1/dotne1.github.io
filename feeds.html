
    <!DOCTYPE html>
    <html lang="en">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <meta name="description" content="Security alerts and cybersecurity news feeds">
        <meta name="keywords" content="cybersecurity news, security alerts, vulnerability feeds, threat intelligence">
        <meta name="author" content="dotne1">
        <meta property="og:title" content="Security Feeds - dotne1's Cybersecurity Portfolio">
        <meta property="og:description" content="Stay updated with the latest cybersecurity news and alerts">
        <meta property="og:type" content="website">
        <title>Security Feeds - dotne1's Cybersecurity Portfolio</title>
        <link rel="stylesheet" href="styles.css">
        <link rel="icon" type="image/x-icon" href="/favicon.ico">
    </head>
    <body>
        <nav class="navbar">
            <div class="nav-links">
                <a href="index.html" class="nav-link">Home</a>
                <a href="about-me.html" class="nav-link">About Me</a>
                <a href="projects.html" class="nav-link">Projects</a>
                <a href="resume.html" class="nav-link">Resume</a>
                <a href="feeds.html" class="nav-link">Feeds</a>
            </div>
        </nav>

        <div class="container" role="main">
            <h1 class="main-header">Security Feeds</h1>
            <div class="search-bar">
                <input type="text" id="searchInput" placeholder="Search CVEs..." onkeyup="searchCVEs()">
            </div>
            <div class="feed-preview" id="cveFeed">
                <div class="feed-header">Latest Vulnerabilities</div>
    
                <div class="cve-entry" data-cve-id="CVE-2025-6086" data-description="the csv me plugin for wordpress is vulnerable to arbitrary file uploads due to insufficient file type validation in the 'csv_me_options_page' function in all versions up to, and including, 2.0. this makes it possible for authenticated attackers, with administrator-level access and above, to upload arbitrary files on the affected site's server which may make remote code execution possible.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-6086" target="_blank">CVE-2025-6086</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-06-18 05:15:42 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-online">HIGH</span></p>
                    <p><span class="feed-label">CVSS Score:</span> 7.2</p>
                    <p>The CSV Me plugin for WordPress is vulnerable to arbitrary file uploads due to insufficient file type validation in the 'csv_me_options_page' function in all versions up to, and including, 2.0. This makes it possible for authenticated attackers, with Administrator-level access and above, to upload arbitrary files on the affected site's server which may make remote code execution possible.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-5237" data-description="the target video easy publish plugin for wordpress is vulnerable to stored cross-site scripting via the ‘width’ parameter in all versions up to, and including, 3.8.5 due to insufficient input sanitization and output escaping. this makes it possible for authenticated attackers, with contributor-level access and above, to inject arbitrary web scripts in pages that will execute whenever a user accesses an injected page.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-5237" target="_blank">CVE-2025-5237</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-06-18 05:15:42 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">MEDIUM</span></p>
                    <p><span class="feed-label">CVSS Score:</span> 6.4</p>
                    <p>The Target Video Easy Publish plugin for WordPress is vulnerable to Stored Cross-Site Scripting via the ‘width’ parameter in all versions up to, and including, 3.8.5 due to insufficient input sanitization and output escaping. This makes it possible for authenticated attackers, with Contributor-level access and above, to inject arbitrary web scripts in pages that will execute whenever a user accesses an injected page.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-38082" data-description="in the linux kernel, the following vulnerability has been resolved:

gpio: virtuser: fix potential out-of-bound write

if the caller wrote more characters, count is truncated to the max
available space in "simple_write_to_buffer". check that the input
size does not exceed the buffer size. write a zero termination
afterwards.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-38082" target="_blank">CVE-2025-38082</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-06-18 05:15:41 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">N/A</span></p>
                    <p><span class="feed-label">CVSS Score:</span> N/A</p>
                    <p>In the Linux kernel, the following vulnerability has been resolved:

gpio: virtuser: fix potential out-of-bound write

If the caller wrote more characters, count is truncated to the max
available space in "simple_write_to_buffer". Check that the input
size does not exceed the buffer size. Write a zero termination
afterwards.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-38081" data-description="in the linux kernel, the following vulnerability has been resolved:

spi-rockchip: fix register out of bounds access

do not write native chip select stuff for gpio chip selects.
gpios can be numbered much higher than native cs.
also, it makes no sense.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-38081" target="_blank">CVE-2025-38081</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-06-18 05:15:41 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">N/A</span></p>
                    <p><span class="feed-label">CVSS Score:</span> N/A</p>
                    <p>In the Linux kernel, the following vulnerability has been resolved:

spi-rockchip: Fix register out of bounds access

Do not write native chip select stuff for GPIO chip selects.
GPIOs can be numbered much higher than native CS.
Also, it makes no sense.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-38080" data-description="in the linux kernel, the following vulnerability has been resolved:

drm/amd/display: increase block_sequence array size

[why]
it's possible to generate more than 50 steps in hwss_build_fast_sequence,
for example with a 6-pipe asic where all pipes are in one mpc chain. this
overflows the block_sequence buffer and corrupts block_sequence_steps,
causing a crash.

[how]
expand block_sequence to 100 items. a naive upper bound on the possible
number of steps for a 6-pipe asic, ignoring the potential for steps to be
mutually exclusive, is 91 with current code, therefore 100 is sufficient.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-38080" target="_blank">CVE-2025-38080</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-06-18 05:15:41 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">N/A</span></p>
                    <p><span class="feed-label">CVSS Score:</span> N/A</p>
                    <p>In the Linux kernel, the following vulnerability has been resolved:

drm/amd/display: Increase block_sequence array size

[Why]
It's possible to generate more than 50 steps in hwss_build_fast_sequence,
for example with a 6-pipe asic where all pipes are in one MPC chain. This
overflows the block_sequence buffer and corrupts block_sequence_steps,
causing a crash.

[How]
Expand block_sequence to 100 items. A naive upper bound on the possible
number of steps for a 6-pipe asic, ignoring the potential for steps to be
mutually exclusive, is 91 with current code, therefore 100 is sufficient.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-38079" data-description="in the linux kernel, the following vulnerability has been resolved:

crypto: algif_hash - fix double free in hash_accept

if accept(2) is called on socket type algif_hash with
msg_more flag set and crypto_ahash_import fails,
sk2 is freed. however, it is also freed in af_alg_release,
leading to slab-use-after-free error.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-38079" target="_blank">CVE-2025-38079</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-06-18 05:15:41 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">N/A</span></p>
                    <p><span class="feed-label">CVSS Score:</span> N/A</p>
                    <p>In the Linux kernel, the following vulnerability has been resolved:

crypto: algif_hash - fix double free in hash_accept

If accept(2) is called on socket type algif_hash with
MSG_MORE flag set and crypto_ahash_import fails,
sk2 is freed. However, it is also freed in af_alg_release,
leading to slab-use-after-free error.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-38078" data-description="in the linux kernel, the following vulnerability has been resolved:

alsa: pcm: fix race of buffer access at pcm oss layer

the pcm oss layer tries to clear the buffer with the silence data at
initialization (or reconfiguration) of a stream with the explicit call
of snd_pcm_format_set_silence() with runtime->dma_area.  but this may
lead to a uaf because the accessed runtime->dma_area might be freed
concurrently, as it's performed outside the pcm ops.

for avoiding it, move the code into the pcm core and perform it inside
the buffer access lock, so that it won't be changed during the
operation.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-38078" target="_blank">CVE-2025-38078</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-06-18 05:15:41 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">N/A</span></p>
                    <p><span class="feed-label">CVSS Score:</span> N/A</p>
                    <p>In the Linux kernel, the following vulnerability has been resolved:

ALSA: pcm: Fix race of buffer access at PCM OSS layer

The PCM OSS layer tries to clear the buffer with the silence data at
initialization (or reconfiguration) of a stream with the explicit call
of snd_pcm_format_set_silence() with runtime->dma_area.  But this may
lead to a UAF because the accessed runtime->dma_area might be freed
concurrently, as it's performed outside the PCM ops.

For avoiding it, move the code into the PCM core and perform it inside
the buffer access lock, so that it won't be changed during the
operation.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-38077" data-description="in the linux kernel, the following vulnerability has been resolved:

platform/x86: dell-wmi-sysman: avoid buffer overflow in current_password_store()

if the 'buf' array received from the user contains an empty string, the
'length' variable will be zero. accessing the 'buf' array element with
index 'length - 1' will result in a buffer overflow.

add a check for an empty string.

found by linux verification center (linuxtesting.org) with svace.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-38077" target="_blank">CVE-2025-38077</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-06-18 05:15:41 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">N/A</span></p>
                    <p><span class="feed-label">CVSS Score:</span> N/A</p>
                    <p>In the Linux kernel, the following vulnerability has been resolved:

platform/x86: dell-wmi-sysman: Avoid buffer overflow in current_password_store()

If the 'buf' array received from the user contains an empty string, the
'length' variable will be zero. Accessing the 'buf' array element with
index 'length - 1' will result in a buffer overflow.

Add a check for an empty string.

Found by Linux Verification Center (linuxtesting.org) with SVACE.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-38076" data-description="in the linux kernel, the following vulnerability has been resolved:

alloc_tag: allocate percpu counters for module tags dynamically

when a module gets unloaded it checks whether any of its tags are still in
use and if so, we keep the memory containing module's allocation tags
alive until all tags are unused.  however percpu counters referenced by
the tags are freed by free_module().  this will lead to uaf if the memory
allocated by a module is accessed after module was unloaded.

to fix this we allocate percpu counters for module allocation tags
dynamically and we keep it alive for tags which are still in use after
module unloading.  this also removes the requirement of a larger
percpu_module_reserve when memory allocation profiling is enabled because
percpu memory for counters does not need to be reserved anymore.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-38076" target="_blank">CVE-2025-38076</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-06-18 05:15:41 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">N/A</span></p>
                    <p><span class="feed-label">CVSS Score:</span> N/A</p>
                    <p>In the Linux kernel, the following vulnerability has been resolved:

alloc_tag: allocate percpu counters for module tags dynamically

When a module gets unloaded it checks whether any of its tags are still in
use and if so, we keep the memory containing module's allocation tags
alive until all tags are unused.  However percpu counters referenced by
the tags are freed by free_module().  This will lead to UAF if the memory
allocated by a module is accessed after module was unloaded.

To fix this we allocate percpu counters for module allocation tags
dynamically and we keep it alive for tags which are still in use after
module unloading.  This also removes the requirement of a larger
PERCPU_MODULE_RESERVE when memory allocation profiling is enabled because
percpu memory for counters does not need to be reserved anymore.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-38075" data-description="in the linux kernel, the following vulnerability has been resolved:

scsi: target: iscsi: fix timeout on deleted connection

nopin response timer may expire on a deleted connection and crash with
such logs:

did not receive response to nopin on cid: 0, failing connection for i_t nexus (null),i,0x00023d000125,iqn.2017-01.com.iscsi.target,t,0x3d

bug: kernel null pointer dereference on read at 0x00000000
nip  strlcpy+0x8/0xb0
lr iscsit_fill_cxn_timeout_err_stats+0x5c/0xc0 [iscsi_target_mod]
call trace:
 iscsit_handle_nopin_response_timeout+0xfc/0x120 [iscsi_target_mod]
 call_timer_fn+0x58/0x1f0
 run_timer_softirq+0x740/0x860
 __do_softirq+0x16c/0x420
 irq_exit+0x188/0x1c0
 timer_interrupt+0x184/0x410

that is because nopin response timer may be re-started on nopin timer
expiration.

stop nopin timer before stopping the nopin response timer to be sure
that no one of them will be re-started.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-38075" target="_blank">CVE-2025-38075</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-06-18 05:15:40 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">N/A</span></p>
                    <p><span class="feed-label">CVSS Score:</span> N/A</p>
                    <p>In the Linux kernel, the following vulnerability has been resolved:

scsi: target: iscsi: Fix timeout on deleted connection

NOPIN response timer may expire on a deleted connection and crash with
such logs:

Did not receive response to NOPIN on CID: 0, failing connection for I_T Nexus (null),i,0x00023d000125,iqn.2017-01.com.iscsi.target,t,0x3d

BUG: Kernel NULL pointer dereference on read at 0x00000000
NIP  strlcpy+0x8/0xb0
LR iscsit_fill_cxn_timeout_err_stats+0x5c/0xc0 [iscsi_target_mod]
Call Trace:
 iscsit_handle_nopin_response_timeout+0xfc/0x120 [iscsi_target_mod]
 call_timer_fn+0x58/0x1f0
 run_timer_softirq+0x740/0x860
 __do_softirq+0x16c/0x420
 irq_exit+0x188/0x1c0
 timer_interrupt+0x184/0x410

That is because nopin response timer may be re-started on nopin timer
expiration.

Stop nopin timer before stopping the nopin response timer to be sure
that no one of them will be re-started.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-38074" data-description="in the linux kernel, the following vulnerability has been resolved:

vhost-scsi: protect vq->log_used with vq->mutex

the vhost-scsi completion path may access vq->log_base when vq->log_used is
already set to false.

    vhost-thread                       qemu-thread

vhost_scsi_complete_cmd_work()
-> vhost_add_used()
   -> vhost_add_used_n()
      if (unlikely(vq->log_used))
                                      qemu disables vq->log_used
                                      via vhost_set_vring_addr.
                                      mutex_lock(&vq->mutex);
                                      vq->log_used = false now!
                                      mutex_unlock(&vq->mutex);

				      qemu gfree(vq->log_base)
        log_used()
        -> log_write(vq->log_base)

assuming the vmm is qemu. the vq->log_base is from qemu userpace and can be
reclaimed via gfree(). as a result, this causes invalid memory writes to
qemu userspace.

the control queue path has the same issue.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-38074" target="_blank">CVE-2025-38074</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-06-18 05:15:40 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">N/A</span></p>
                    <p><span class="feed-label">CVSS Score:</span> N/A</p>
                    <p>In the Linux kernel, the following vulnerability has been resolved:

vhost-scsi: protect vq->log_used with vq->mutex

The vhost-scsi completion path may access vq->log_base when vq->log_used is
already set to false.

    vhost-thread                       QEMU-thread

vhost_scsi_complete_cmd_work()
-> vhost_add_used()
   -> vhost_add_used_n()
      if (unlikely(vq->log_used))
                                      QEMU disables vq->log_used
                                      via VHOST_SET_VRING_ADDR.
                                      mutex_lock(&vq->mutex);
                                      vq->log_used = false now!
                                      mutex_unlock(&vq->mutex);

				      QEMU gfree(vq->log_base)
        log_used()
        -> log_write(vq->log_base)

Assuming the VMM is QEMU. The vq->log_base is from QEMU userpace and can be
reclaimed via gfree(). As a result, this causes invalid memory writes to
QEMU userspace.

The control queue path has the same issue.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-38073" data-description="in the linux kernel, the following vulnerability has been resolved:

block: fix race between set_blocksize and read paths

with the new large sector size support, it's now the case that
set_blocksize can change i_blksize and the folio order in a manner that
conflicts with a concurrent reader and causes a kernel crash.

specifically, let's say that udev-worker calls libblkid to detect the
labels on a block device.  the read call can create an order-0 folio to
read the first 4096 bytes from the disk.  but then udev is preempted.

next, someone tries to mount an 8k-sectorsize filesystem from the same
block device.  the filesystem calls set_blksize, which sets i_blksize to
8192 and the minimum folio order to 1.

now udev resumes, still holding the order-0 folio it allocated.  it then
tries to schedule a read bio and do_mpage_readahead tries to create
bufferheads for the folio.  unfortunately, blocks_per_folio == 0 because
the page size is 4096 but the blocksize is 8192 so no bufferheads are
attached and the bh walk never sets bdev.  we then submit the bio with a
null block device and crash.

therefore, truncate the page cache after flushing but before updating
i_blksize.  however, that's not enough -- we also need to lock out file
io and page faults during the update.  take both the i_rwsem and the
invalidate_lock in exclusive mode for invalidations, and in shared mode
for read/write operations.

i don't know if this is the correct fix, but xfs/259 found it.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-38073" target="_blank">CVE-2025-38073</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-06-18 05:15:40 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">N/A</span></p>
                    <p><span class="feed-label">CVSS Score:</span> N/A</p>
                    <p>In the Linux kernel, the following vulnerability has been resolved:

block: fix race between set_blocksize and read paths

With the new large sector size support, it's now the case that
set_blocksize can change i_blksize and the folio order in a manner that
conflicts with a concurrent reader and causes a kernel crash.

Specifically, let's say that udev-worker calls libblkid to detect the
labels on a block device.  The read call can create an order-0 folio to
read the first 4096 bytes from the disk.  But then udev is preempted.

Next, someone tries to mount an 8k-sectorsize filesystem from the same
block device.  The filesystem calls set_blksize, which sets i_blksize to
8192 and the minimum folio order to 1.

Now udev resumes, still holding the order-0 folio it allocated.  It then
tries to schedule a read bio and do_mpage_readahead tries to create
bufferheads for the folio.  Unfortunately, blocks_per_folio == 0 because
the page size is 4096 but the blocksize is 8192 so no bufferheads are
attached and the bh walk never sets bdev.  We then submit the bio with a
NULL block device and crash.

Therefore, truncate the page cache after flushing but before updating
i_blksize.  However, that's not enough -- we also need to lock out file
IO and page faults during the update.  Take both the i_rwsem and the
invalidate_lock in exclusive mode for invalidations, and in shared mode
for read/write operations.

I don't know if this is the correct fix, but xfs/259 found it.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-38072" data-description="in the linux kernel, the following vulnerability has been resolved:

libnvdimm/labels: fix divide error in nd_label_data_init()

if a faulty cxl memory device returns a broken zero lsa size in its
memory device information (identify memory device (opcode 4000h), cxl
spec. 3.1, 8.2.9.9.1.1), a divide error occurs in the libnvdimm
driver:

 oops: divide error: 0000 [#1] preempt smp nopti
 rip: 0010:nd_label_data_init+0x10e/0x800 [libnvdimm]

code and flow:

1) cxl command 4000h returns lsa size = 0
2) config_size is assigned to zero lsa size (cxl pmem driver):

drivers/cxl/pmem.c:             .config_size = mds->lsa_size,

3) max_xfer is set to zero (nvdimm driver):

drivers/nvdimm/label.c: max_xfer = min_t(size_t, ndd->nsarea.max_xfer, config_size);

4) a subsequent div_round_up() causes a division by zero:

drivers/nvdimm/label.c: /* make our initial read size a multiple of max_xfer size */
drivers/nvdimm/label.c: read_size = min(div_round_up(read_size, max_xfer) * max_xfer,
drivers/nvdimm/label.c-                 config_size);

fix this by checking the config size parameter by extending an
existing check.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-38072" target="_blank">CVE-2025-38072</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-06-18 05:15:40 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">N/A</span></p>
                    <p><span class="feed-label">CVSS Score:</span> N/A</p>
                    <p>In the Linux kernel, the following vulnerability has been resolved:

libnvdimm/labels: Fix divide error in nd_label_data_init()

If a faulty CXL memory device returns a broken zero LSA size in its
memory device information (Identify Memory Device (Opcode 4000h), CXL
spec. 3.1, 8.2.9.9.1.1), a divide error occurs in the libnvdimm
driver:

 Oops: divide error: 0000 [#1] PREEMPT SMP NOPTI
 RIP: 0010:nd_label_data_init+0x10e/0x800 [libnvdimm]

Code and flow:

1) CXL Command 4000h returns LSA size = 0
2) config_size is assigned to zero LSA size (CXL pmem driver):

drivers/cxl/pmem.c:             .config_size = mds->lsa_size,

3) max_xfer is set to zero (nvdimm driver):

drivers/nvdimm/label.c: max_xfer = min_t(size_t, ndd->nsarea.max_xfer, config_size);

4) A subsequent DIV_ROUND_UP() causes a division by zero:

drivers/nvdimm/label.c: /* Make our initial read size a multiple of max_xfer size */
drivers/nvdimm/label.c: read_size = min(DIV_ROUND_UP(read_size, max_xfer) * max_xfer,
drivers/nvdimm/label.c-                 config_size);

Fix this by checking the config size parameter by extending an
existing check.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-38071" data-description="in the linux kernel, the following vulnerability has been resolved:

x86/mm: check return value from memblock_phys_alloc_range()

at least with config_physical_start=0x100000, if there is < 4 mib of
contiguous free memory available at this point, the kernel will crash
and burn because memblock_phys_alloc_range() returns 0 on failure,
which leads memblock_phys_free() to throw the first 4 mib of physical
memory to the wolves.

at a minimum it should fail gracefully with a meaningful diagnostic,
but in fact everything seems to work fine without the weird reserve
allocation.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-38071" target="_blank">CVE-2025-38071</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-06-18 05:15:40 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">N/A</span></p>
                    <p><span class="feed-label">CVSS Score:</span> N/A</p>
                    <p>In the Linux kernel, the following vulnerability has been resolved:

x86/mm: Check return value from memblock_phys_alloc_range()

At least with CONFIG_PHYSICAL_START=0x100000, if there is < 4 MiB of
contiguous free memory available at this point, the kernel will crash
and burn because memblock_phys_alloc_range() returns 0 on failure,
which leads memblock_phys_free() to throw the first 4 MiB of physical
memory to the wolves.

At a minimum it should fail gracefully with a meaningful diagnostic,
but in fact everything seems to work fine without the weird reserve
allocation.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-38070" data-description="in the linux kernel, the following vulnerability has been resolved:

asoc: sma1307: add null check in sma1307_setting_loaded()

all varibale allocated by kzalloc and devm_kzalloc could be null.
multiple pointer checks and their cleanup are added.

this issue is found by our static analysis tool">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-38070" target="_blank">CVE-2025-38070</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-06-18 05:15:40 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">N/A</span></p>
                    <p><span class="feed-label">CVSS Score:</span> N/A</p>
                    <p>In the Linux kernel, the following vulnerability has been resolved:

ASoC: sma1307: Add NULL check in sma1307_setting_loaded()

All varibale allocated by kzalloc and devm_kzalloc could be NULL.
Multiple pointer checks and their cleanup are added.

This issue is found by our static analysis tool</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-38069" data-description="in the linux kernel, the following vulnerability has been resolved:

pci: endpoint: pci-epf-test: fix double free that causes kernel to oops

fix a kernel oops found while testing the stm32_pcie endpoint driver
with handling of perst# deassertion:

during ep initialization, pci_epf_test_alloc_space() allocates all bars,
which are further freed if epc_set_bar() fails (for instance, due to no
free inbound window).

however, when pci_epc_set_bar() fails, the error path:

  pci_epc_set_bar() ->
    pci_epf_free_space()

does not clear the previous assignment to epf_test->reg[bar].

then, if the host reboots, the perst# deassertion restarts the bar
allocation sequence with the same allocation failure (no free inbound
window), creating a double free situation since epf_test->reg[bar] was
deallocated and is still non-null.

thus, make sure that pci_epf_alloc_space() and pci_epf_free_space()
invocations are symmetric, and as such, set epf_test->reg[bar] to null
when memory is freed.

[kwilczynski: commit log]">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-38069" target="_blank">CVE-2025-38069</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-06-18 05:15:40 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">N/A</span></p>
                    <p><span class="feed-label">CVSS Score:</span> N/A</p>
                    <p>In the Linux kernel, the following vulnerability has been resolved:

PCI: endpoint: pci-epf-test: Fix double free that causes kernel to oops

Fix a kernel oops found while testing the stm32_pcie Endpoint driver
with handling of PERST# deassertion:

During EP initialization, pci_epf_test_alloc_space() allocates all BARs,
which are further freed if epc_set_bar() fails (for instance, due to no
free inbound window).

However, when pci_epc_set_bar() fails, the error path:

  pci_epc_set_bar() ->
    pci_epf_free_space()

does not clear the previous assignment to epf_test->reg[bar].

Then, if the host reboots, the PERST# deassertion restarts the BAR
allocation sequence with the same allocation failure (no free inbound
window), creating a double free situation since epf_test->reg[bar] was
deallocated and is still non-NULL.

Thus, make sure that pci_epf_alloc_space() and pci_epf_free_space()
invocations are symmetric, and as such, set epf_test->reg[bar] to NULL
when memory is freed.

[kwilczynski: commit log]</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-38068" data-description="in the linux kernel, the following vulnerability has been resolved:

crypto: lzo - fix compression buffer overrun

unlike the decompression code, the compression code in lzo never
checked for output overruns.  it instead assumes that the caller
always provides enough buffer space, disregarding the buffer length
provided by the caller.

add a safe compression interface that checks for the end of buffer
before each write.  use the safe interface in crypto/lzo.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-38068" target="_blank">CVE-2025-38068</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-06-18 05:15:39 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">N/A</span></p>
                    <p><span class="feed-label">CVSS Score:</span> N/A</p>
                    <p>In the Linux kernel, the following vulnerability has been resolved:

crypto: lzo - Fix compression buffer overrun

Unlike the decompression code, the compression code in LZO never
checked for output overruns.  It instead assumes that the caller
always provides enough buffer space, disregarding the buffer length
provided by the caller.

Add a safe compression interface that checks for the end of buffer
before each write.  Use the safe interface in crypto/lzo.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-38067" data-description="in the linux kernel, the following vulnerability has been resolved:

rseq: fix segfault on registration when rseq_cs is non-zero

the rseq_cs field is documented as being set to 0 by user-space prior to
registration, however this is not currently enforced by the kernel. this
can result in a segfault on return to user-space if the value stored in
the rseq_cs field doesn't point to a valid struct rseq_cs.

the correct solution to this would be to fail the rseq registration when
the rseq_cs field is non-zero. however, some older versions of glibc
will reuse the rseq area of previous threads without clearing the
rseq_cs field and will also terminate the process if the rseq
registration fails in a secondary thread. this wasn't caught in testing
because in this case the leftover rseq_cs does point to a valid struct
rseq_cs.

what we can do is clear the rseq_cs field on registration when it's
non-zero which will prevent segfaults on registration and won't break
the glibc versions that reuse rseq areas on thread creation.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-38067" target="_blank">CVE-2025-38067</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-06-18 05:15:39 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">N/A</span></p>
                    <p><span class="feed-label">CVSS Score:</span> N/A</p>
                    <p>In the Linux kernel, the following vulnerability has been resolved:

rseq: Fix segfault on registration when rseq_cs is non-zero

The rseq_cs field is documented as being set to 0 by user-space prior to
registration, however this is not currently enforced by the kernel. This
can result in a segfault on return to user-space if the value stored in
the rseq_cs field doesn't point to a valid struct rseq_cs.

The correct solution to this would be to fail the rseq registration when
the rseq_cs field is non-zero. However, some older versions of glibc
will reuse the rseq area of previous threads without clearing the
rseq_cs field and will also terminate the process if the rseq
registration fails in a secondary thread. This wasn't caught in testing
because in this case the leftover rseq_cs does point to a valid struct
rseq_cs.

What we can do is clear the rseq_cs field on registration when it's
non-zero which will prevent segfaults on registration and won't break
the glibc versions that reuse rseq areas on thread creation.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-38066" data-description="in the linux kernel, the following vulnerability has been resolved:

dm cache: prevent bug_on by blocking retries on failed device resumes

a cache device failing to resume due to mapping errors should not be
retried, as the failure leaves a partially initialized policy object.
repeating the resume operation risks triggering bug_on when reloading
cache mappings into the incomplete policy object.

reproduce steps:

1. create a cache metadata consisting of 512 or more cache blocks,
   with some mappings stored in the first array block of the mapping
   array. here we use cache_restore v1.0 to build the metadata.

cat <<eof >> cmeta.xml
<superblock uuid="" block_size="128" nr_cache_blocks="512" \
policy="smq" hint_width="4">
  <mappings>
    <mapping cache_block="0" origin_block="0" dirty="false"/>
  </mappings>
</superblock>
eof
dmsetup create cmeta --table "0 8192 linear /dev/sdc 0"
cache_restore -i cmeta.xml -o /dev/mapper/cmeta --metadata-version=2
dmsetup remove cmeta

2. wipe the second array block of the mapping array to simulate
   data degradations.

mapping_root=$(dd if=/dev/sdc bs=1c count=8 skip=192 \
2>/dev/null | hexdump -e '1/8 "%u\n"')
ablock=$(dd if=/dev/sdc bs=1c count=8 skip=$((4096*mapping_root+2056)) \
2>/dev/null | hexdump -e '1/8 "%u\n"')
dd if=/dev/zero of=/dev/sdc bs=4k count=1 seek=$ablock

3. try bringing up the cache device. the resume is expected to fail
   due to the broken array block.

dmsetup create cmeta --table "0 8192 linear /dev/sdc 0"
dmsetup create cdata --table "0 65536 linear /dev/sdc 8192"
dmsetup create corig --table "0 524288 linear /dev/sdc 262144"
dmsetup create cache --notable
dmsetup load cache --table "0 524288 cache /dev/mapper/cmeta \
/dev/mapper/cdata /dev/mapper/corig 128 2 metadata2 writethrough smq 0"
dmsetup resume cache

4. try resuming the cache again. an unexpected bug_on is triggered
   while loading cache mappings.

dmsetup resume cache

kernel logs:

(snip)
------------[ cut here ]------------
kernel bug at drivers/md/dm-cache-policy-smq.c:752!
oops: invalid opcode: 0000 [#1] preempt smp kasan nopti
cpu: 0 uid: 0 pid: 332 comm: dmsetup not tainted 6.13.4 #3
rip: 0010:smq_load_mapping+0x3e5/0x570

fix by disallowing resume operations for devices that failed the
initial attempt.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-38066" target="_blank">CVE-2025-38066</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-06-18 05:15:39 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">N/A</span></p>
                    <p><span class="feed-label">CVSS Score:</span> N/A</p>
                    <p>In the Linux kernel, the following vulnerability has been resolved:

dm cache: prevent BUG_ON by blocking retries on failed device resumes

A cache device failing to resume due to mapping errors should not be
retried, as the failure leaves a partially initialized policy object.
Repeating the resume operation risks triggering BUG_ON when reloading
cache mappings into the incomplete policy object.

Reproduce steps:

1. create a cache metadata consisting of 512 or more cache blocks,
   with some mappings stored in the first array block of the mapping
   array. Here we use cache_restore v1.0 to build the metadata.

cat <<EOF >> cmeta.xml
<superblock uuid="" block_size="128" nr_cache_blocks="512" \
policy="smq" hint_width="4">
  <mappings>
    <mapping cache_block="0" origin_block="0" dirty="false"/>
  </mappings>
</superblock>
EOF
dmsetup create cmeta --table "0 8192 linear /dev/sdc 0"
cache_restore -i cmeta.xml -o /dev/mapper/cmeta --metadata-version=2
dmsetup remove cmeta

2. wipe the second array block of the mapping array to simulate
   data degradations.

mapping_root=$(dd if=/dev/sdc bs=1c count=8 skip=192 \
2>/dev/null | hexdump -e '1/8 "%u\n"')
ablock=$(dd if=/dev/sdc bs=1c count=8 skip=$((4096*mapping_root+2056)) \
2>/dev/null | hexdump -e '1/8 "%u\n"')
dd if=/dev/zero of=/dev/sdc bs=4k count=1 seek=$ablock

3. try bringing up the cache device. The resume is expected to fail
   due to the broken array block.

dmsetup create cmeta --table "0 8192 linear /dev/sdc 0"
dmsetup create cdata --table "0 65536 linear /dev/sdc 8192"
dmsetup create corig --table "0 524288 linear /dev/sdc 262144"
dmsetup create cache --notable
dmsetup load cache --table "0 524288 cache /dev/mapper/cmeta \
/dev/mapper/cdata /dev/mapper/corig 128 2 metadata2 writethrough smq 0"
dmsetup resume cache

4. try resuming the cache again. An unexpected BUG_ON is triggered
   while loading cache mappings.

dmsetup resume cache

Kernel logs:

(snip)
------------[ cut here ]------------
kernel BUG at drivers/md/dm-cache-policy-smq.c:752!
Oops: invalid opcode: 0000 [#1] PREEMPT SMP KASAN NOPTI
CPU: 0 UID: 0 PID: 332 Comm: dmsetup Not tainted 6.13.4 #3
RIP: 0010:smq_load_mapping+0x3e5/0x570

Fix by disallowing resume operations for devices that failed the
initial attempt.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-38065" data-description="in the linux kernel, the following vulnerability has been resolved:

orangefs: do not truncate file size

'len' is used to store the result of i_size_read(), so making 'len'
a size_t results in truncation to 4gib on 32-bit systems.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-38065" target="_blank">CVE-2025-38065</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-06-18 05:15:39 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">N/A</span></p>
                    <p><span class="feed-label">CVSS Score:</span> N/A</p>
                    <p>In the Linux kernel, the following vulnerability has been resolved:

orangefs: Do not truncate file size

'len' is used to store the result of i_size_read(), so making 'len'
a size_t results in truncation to 4GiB on 32-bit systems.</p>
                </div>
        
            </div>
        </div>

        <footer class="footer">
            <p>© 2025 dotne1 - Cybersecurity Portfolio</p>
        </footer>

        <script>
            function searchCVEs() {
                const input = document.getElementById('searchInput').value.toLowerCase();
                const cveEntries = document.getElementsByClassName('cve-entry');
                for (let i = 0; i < cveEntries.length; i++) {
                    const cveId = cveEntries[i].getAttribute('data-cve-id').toLowerCase();
                    const description = cveEntries[i].getAttribute('data-description');
                    if (cveId.includes(input) || description.includes(input)) {
                        cveEntries[i].style.display = '';
                    } else {
                        cveEntries[i].style.display = 'none';
                    }
                }
            }
        </script>
    </body>
    </html>
    