
    <!DOCTYPE html>
    <html lang="en">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <meta name="description" content="Security alerts and cybersecurity news feeds">
        <meta name="keywords" content="cybersecurity news, security alerts, vulnerability feeds, threat intelligence">
        <meta name="author" content="dotne1">
        <meta property="og:title" content="Security Feeds - dotne1's Cybersecurity Portfolio">
        <meta property="og:description" content="Stay updated with the latest cybersecurity news and alerts">
        <meta property="og:type" content="website">
        <title>Security Feeds - dotne1's Cybersecurity Portfolio</title>
        <link rel="stylesheet" href="styles.css">
        <link rel="icon" type="image/x-icon" href="/favicon.ico">
    </head>
    <body>
        <nav class="navbar">
            <div class="nav-links">
                <a href="index.html" class="nav-link">Home</a>
                <a href="about-me.html" class="nav-link">About Me</a>
                <a href="projects.html" class="nav-link">Projects</a>
                <a href="resume.html" class="nav-link">Resume</a>
                <a href="feeds.html" class="nav-link">Feeds</a>
            </div>
        </nav>

        <div class="container" role="main">
            <h1 class="main-header">Security Feeds</h1>
            <div class="search-bar">
                <input type="text" id="searchInput" placeholder="Search CVEs..." onkeyup="searchCVEs()">
            </div>
            <div class="feed-preview" id="cveFeed">
                <div class="feed-header">Latest Vulnerabilities</div>
    
                <div class="cve-entry" data-cve-id="CVE-2025-67288" data-description="an arbitrary file upload vulnerability in umbraco cms v16.3.3 allows attackers to execute arbitrary code via uploading a crafted pdf file.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-67288" target="_blank">CVE-2025-67288</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-12-22 13:15:49 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-online">CRITICAL</span></p>
                    <p><span class="feed-label">CVSS Score:</span> 10.0</p>
                    <p>An arbitrary file upload vulnerability in Umbraco CMS v16.3.3 allows attackers to execute arbitrary code via uploading a crafted PDF file.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-63664" data-description="incorrect access control in the /api/v1/conversations/*/messages api of gt edge ai platform before v2.0.10-dev allows unauthorized attackers to access other users' message history with ai agents.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-63664" target="_blank">CVE-2025-63664</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-12-22 13:15:49 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-online">HIGH</span></p>
                    <p><span class="feed-label">CVSS Score:</span> 7.5</p>
                    <p>Incorrect access control in the /api/v1/conversations/*/messages API of GT Edge AI Platform before v2.0.10-dev allows unauthorized attackers to access other users' message history with AI agents.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-63663" data-description="incorrect access control in the /api/v1/conversations/*/files api of gt edge ai platform before v2.0.10 allows unauthorized attackers to access other users' uploaded files.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-63663" target="_blank">CVE-2025-63663</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-12-22 13:15:49 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">N/A</span></p>
                    <p><span class="feed-label">CVSS Score:</span> N/A</p>
                    <p>Incorrect access control in the /api/v1/conversations/*/files API of GT Edge AI Platform before v2.0.10 allows unauthorized attackers to access other users' uploaded files.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-63662" data-description="insecure permissions in the /api/v1/agents api of gt edge ai platform before v2.0.10-dev allows unauthorized attackers to access sensitive information.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-63662" target="_blank">CVE-2025-63662</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-12-22 13:15:49 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">N/A</span></p>
                    <p><span class="feed-label">CVSS Score:</span> N/A</p>
                    <p>Insecure permissions in the /api/v1/agents API of GT Edge AI Platform before v2.0.10-dev allows unauthorized attackers to access sensitive information.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-26787" data-description="an error in the signserver container startup logic was found in keyfactor signserver versions prior to 7.2. the admin cli command used to configure certificate access to the initial startup of the container sets a property of "allowany" to allow any user with a valid and trusted client auth certificate to connect. admins can then set more restricted access to specific certificates. a logic error caused this admin cli command to be run on each restart of the container instead of only the first startup as intended resetting the configuration to "allowany".">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-26787" target="_blank">CVE-2025-26787</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-12-22 13:15:48 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">MEDIUM</span></p>
                    <p><span class="feed-label">CVSS Score:</span> 4.7</p>
                    <p>An error in the SignServer container startup logic was found in Keyfactor SignServer versions prior to 7.2. The Admin CLI command used to configure Certificate access to the initial startup of the container sets a property of "allowany" to allow any user with a valid and trusted client auth certificate to connect. Admins can then set more restricted access to specific certificates. A logic error caused this admin CLI command to be run on each restart of the container instead of only the first startup as intended resetting the configuration to "allowany".</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-15033" data-description="a vulnerability in woocommerce 8.1 to 10.4.2 can allow logged-in customers to access order data of guest customers on sites with a certain configuration. this has been fixed in woocommerce 10.4.3, as well as all the previously affected versions through point releases, starting from 8.1, where it has been fixed in 8.1.3. it does not affect woocommerce 8.0 or earlier.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-15033" target="_blank">CVE-2025-15033</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-12-22 13:15:48 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">N/A</span></p>
                    <p><span class="feed-label">CVSS Score:</span> N/A</p>
                    <p>A vulnerability in WooCommerce 8.1 to 10.4.2 can allow logged-in customers to access order data of guest customers on sites with a certain configuration. This has been fixed in WooCommerce 10.4.3, as well as all the previously affected versions through point releases, starting from 8.1, where it has been fixed in 8.1.3. It does not affect WooCommerce 8.0 or earlier.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2024-35321" data-description="mynet up to v26.08 was discovered to contain a reflected cross-site scripting (xss) vulnerability via the msgtipo parameter.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2024-35321" target="_blank">CVE-2024-35321</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-12-22 13:15:48 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">N/A</span></p>
                    <p><span class="feed-label">CVSS Score:</span> N/A</p>
                    <p>MyNET up to v26.08 was discovered to contain a Reflected cross-site scripting (XSS) vulnerability via the msgtipo parameter.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2024-25814" data-description="mynet up to v26.05 was discovered to contain a reflected cross-site scripting (xss) vulnerability via the msg parameter.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2024-25814" target="_blank">CVE-2024-25814</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-12-22 13:15:47 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">N/A</span></p>
                    <p><span class="feed-label">CVSS Score:</span> N/A</p>
                    <p>MyNET up to v26.05 was discovered to contain a reflected cross-site scripting (XSS) vulnerability via the msg parameter.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-68645" data-description="a local file inclusion (lfi) vulnerability exists in the webmail classic ui of zimbra collaboration (zcs) 10.0 and 10.1 because of improper handling of user-supplied request parameters in the restfilter servlet. an unauthenticated remote attacker can craft requests to the /h/rest endpoint to influence internal request dispatching, allowing inclusion of arbitrary files from the webroot directory.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-68645" target="_blank">CVE-2025-68645</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-12-22 12:16:17 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">N/A</span></p>
                    <p><span class="feed-label">CVSS Score:</span> N/A</p>
                    <p>A Local File Inclusion (LFI) vulnerability exists in the Webmail Classic UI of Zimbra Collaboration (ZCS) 10.0 and 10.1 because of improper handling of user-supplied request parameters in the RestFilter servlet. An unauthenticated remote attacker can craft requests to the /h/rest endpoint to influence internal request dispatching, allowing inclusion of arbitrary files from the WebRoot directory.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-67289" data-description="an arbitrary file upload vulnerability in the attachments module of frappe framework v15.89.0 allows attackers to execute arbitrary code via uploading a crafted xml file.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-67289" target="_blank">CVE-2025-67289</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-12-22 12:16:16 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">N/A</span></p>
                    <p><span class="feed-label">CVSS Score:</span> N/A</p>
                    <p>An arbitrary file upload vulnerability in the Attachments module of Frappe Framework v15.89.0 allows attackers to execute arbitrary code via uploading a crafted XML file.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-65270" data-description="reflected cross-site scripting (xss) vulnerability in clincapture edc 3.0 and 2.2.3, allowing an unauthenticated remote attacker to execute javascript code in the context of the victim's browser.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-65270" target="_blank">CVE-2025-65270</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-12-22 12:16:16 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">N/A</span></p>
                    <p><span class="feed-label">CVSS Score:</span> N/A</p>
                    <p>Reflected cross-site scripting (XSS) vulnerability in ClinCapture EDC 3.0 and 2.2.3, allowing an unauthenticated remote attacker to execute JavaScript code in the context of the victim's browser.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-68337" data-description="in the linux kernel, the following vulnerability has been resolved:

jbd2: avoid bug_on in jbd2_journal_get_create_access() when file system corrupted

there's issue when file system corrupted:
------------[ cut here ]------------
kernel bug at fs/jbd2/transaction.c:1289!
oops: invalid opcode: 0000 [#1] smp kasan pti
cpu: 5 uid: 0 pid: 2031 comm: mkdir not tainted 6.18.0-rc1-next
rip: 0010:jbd2_journal_get_create_access+0x3b6/0x4d0
rsp: 0018:ffff888117aafa30 eflags: 00010202
rax: 0000000000000000 rbx: ffff88811a86b000 rcx: ffffffff89a63534
rdx: 1ffff110200ec602 rsi: 0000000000000004 rdi: ffff888100763010
rbp: ffff888100763000 r08: 0000000000000001 r09: ffff888100763028
r10: 0000000000000003 r11: 0000000000000000 r12: 0000000000000000
r13: ffff88812c432000 r14: ffff88812c608000 r15: ffff888120bfc000
cs:  0010 ds: 0000 es: 0000 cr0: 0000000080050033
cr2: 00007f91d6970c99 cr3: 00000001159c4000 cr4: 00000000000006f0
call trace:
 <task>
 __ext4_journal_get_create_access+0x42/0x170
 ext4_getblk+0x319/0x6f0
 ext4_bread+0x11/0x100
 ext4_append+0x1e6/0x4a0
 ext4_init_new_dir+0x145/0x1d0
 ext4_mkdir+0x326/0x920
 vfs_mkdir+0x45c/0x740
 do_mkdirat+0x234/0x2f0
 __x64_sys_mkdir+0xd6/0x120
 do_syscall_64+0x5f/0xfa0
 entry_syscall_64_after_hwframe+0x76/0x7e

the above issue occurs with us in errors=continue mode when accompanied by
storage failures. there have been many inconsistencies in the file system
data.
in the case of file system data inconsistency, for example, if the block
bitmap of a referenced block is not set, it can lead to the situation where
a block being committed is allocated and used again. as a result, the
following condition will not be satisfied then trigger bug_on. of course,
it is entirely possible to construct a problematic image that can trigger
this bug_on through specific operations. in fact, i have constructed such
an image and easily reproduced this issue.
therefore, j_assert() holds true only under ideal conditions, but it may
not necessarily be satisfied in exceptional scenarios. using j_assert()
directly in abnormal situations would cause the system to crash, which is
clearly not what we want. so here we directly trigger a jbd abort instead
of immediately invoking bug_on.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-68337" target="_blank">CVE-2025-68337</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-12-22 11:16:01 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">N/A</span></p>
                    <p><span class="feed-label">CVSS Score:</span> N/A</p>
                    <p>In the Linux kernel, the following vulnerability has been resolved:

jbd2: avoid bug_on in jbd2_journal_get_create_access() when file system corrupted

There's issue when file system corrupted:
------------[ cut here ]------------
kernel BUG at fs/jbd2/transaction.c:1289!
Oops: invalid opcode: 0000 [#1] SMP KASAN PTI
CPU: 5 UID: 0 PID: 2031 Comm: mkdir Not tainted 6.18.0-rc1-next
RIP: 0010:jbd2_journal_get_create_access+0x3b6/0x4d0
RSP: 0018:ffff888117aafa30 EFLAGS: 00010202
RAX: 0000000000000000 RBX: ffff88811a86b000 RCX: ffffffff89a63534
RDX: 1ffff110200ec602 RSI: 0000000000000004 RDI: ffff888100763010
RBP: ffff888100763000 R08: 0000000000000001 R09: ffff888100763028
R10: 0000000000000003 R11: 0000000000000000 R12: 0000000000000000
R13: ffff88812c432000 R14: ffff88812c608000 R15: ffff888120bfc000
CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
CR2: 00007f91d6970c99 CR3: 00000001159c4000 CR4: 00000000000006f0
Call Trace:
 <TASK>
 __ext4_journal_get_create_access+0x42/0x170
 ext4_getblk+0x319/0x6f0
 ext4_bread+0x11/0x100
 ext4_append+0x1e6/0x4a0
 ext4_init_new_dir+0x145/0x1d0
 ext4_mkdir+0x326/0x920
 vfs_mkdir+0x45c/0x740
 do_mkdirat+0x234/0x2f0
 __x64_sys_mkdir+0xd6/0x120
 do_syscall_64+0x5f/0xfa0
 entry_SYSCALL_64_after_hwframe+0x76/0x7e

The above issue occurs with us in errors=continue mode when accompanied by
storage failures. There have been many inconsistencies in the file system
data.
In the case of file system data inconsistency, for example, if the block
bitmap of a referenced block is not set, it can lead to the situation where
a block being committed is allocated and used again. As a result, the
following condition will not be satisfied then trigger BUG_ON. Of course,
it is entirely possible to construct a problematic image that can trigger
this BUG_ON through specific operations. In fact, I have constructed such
an image and easily reproduced this issue.
Therefore, J_ASSERT() holds true only under ideal conditions, but it may
not necessarily be satisfied in exceptional scenarios. Using J_ASSERT()
directly in abnormal situations would cause the system to crash, which is
clearly not what we want. So here we directly trigger a JBD abort instead
of immediately invoking BUG_ON.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-68336" data-description="in the linux kernel, the following vulnerability has been resolved:

locking/spinlock/debug: fix data-race in do_raw_write_lock

kcsan reports:

bug: kcsan: data-race in do_raw_write_lock / do_raw_write_lock

write (marked) to 0xffff800009cf504c of 4 bytes by task 1102 on cpu 1:
 do_raw_write_lock+0x120/0x204
 _raw_write_lock_irq
 do_exit
 call_usermodehelper_exec_async
 ret_from_fork

read to 0xffff800009cf504c of 4 bytes by task 1103 on cpu 0:
 do_raw_write_lock+0x88/0x204
 _raw_write_lock_irq
 do_exit
 call_usermodehelper_exec_async
 ret_from_fork

value changed: 0xffffffff -> 0x00000001

reported by kernel concurrency sanitizer on:
cpu: 0 pid: 1103 comm: kworker/u4:1 6.1.111

commit 1a365e822372 ("locking/spinlock/debug: fix various data races") has
adressed most of these races, but seems to be not consistent/not complete.

>from do_raw_write_lock() only debug_write_lock_after() part has been
converted to write_once(), but not debug_write_lock_before() part.
do it now.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-68336" target="_blank">CVE-2025-68336</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-12-22 11:16:01 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">N/A</span></p>
                    <p><span class="feed-label">CVSS Score:</span> N/A</p>
                    <p>In the Linux kernel, the following vulnerability has been resolved:

locking/spinlock/debug: Fix data-race in do_raw_write_lock

KCSAN reports:

BUG: KCSAN: data-race in do_raw_write_lock / do_raw_write_lock

write (marked) to 0xffff800009cf504c of 4 bytes by task 1102 on cpu 1:
 do_raw_write_lock+0x120/0x204
 _raw_write_lock_irq
 do_exit
 call_usermodehelper_exec_async
 ret_from_fork

read to 0xffff800009cf504c of 4 bytes by task 1103 on cpu 0:
 do_raw_write_lock+0x88/0x204
 _raw_write_lock_irq
 do_exit
 call_usermodehelper_exec_async
 ret_from_fork

value changed: 0xffffffff -> 0x00000001

Reported by Kernel Concurrency Sanitizer on:
CPU: 0 PID: 1103 Comm: kworker/u4:1 6.1.111

Commit 1a365e822372 ("locking/spinlock/debug: Fix various data races") has
adressed most of these races, but seems to be not consistent/not complete.

>From do_raw_write_lock() only debug_write_lock_after() part has been
converted to WRITE_ONCE(), but not debug_write_lock_before() part.
Do it now.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-68335" data-description="in the linux kernel, the following vulnerability has been resolved:

comedi: pcl818: fix null-ptr-deref in pcl818_ai_cancel()

syzbot identified an issue [1] in pcl818_ai_cancel(), which stems from
the fact that in case of early device detach via pcl818_detach(),
subdevice dev->read_subdev may not have initialized its pointer to
&struct comedi_async as intended. thus, any such dereferencing of
&s->async->cmd will lead to general protection fault and kernel crash.

mitigate this problem by removing a call to pcl818_ai_cancel() from
pcl818_detach() altogether. this way, if the subdevice setups its
support for async commands, everything async-related will be
handled via subdevice's own ->cancel() function in
comedi_device_detach_locked() even before pcl818_detach(). if no
support for asynchronous commands is provided, there is no need
to cancel anything either.

[1] syzbot crash:
oops: general protection fault, probably for non-canonical address 0xdffffc0000000005: 0000 [#1] smp kasan pti
kasan: null-ptr-deref in range [0x0000000000000028-0x000000000000002f]
cpu: 1 uid: 0 pid: 6050 comm: syz.0.18 not tainted syzkaller #0 preempt(full)
hardware name: google google compute engine/google compute engine, bios google 08/18/2025
rip: 0010:pcl818_ai_cancel+0x69/0x3f0 drivers/comedi/drivers/pcl818.c:762
...
call trace:
 <task>
 pcl818_detach+0x66/0xd0 drivers/comedi/drivers/pcl818.c:1115
 comedi_device_detach_locked+0x178/0x750 drivers/comedi/drivers.c:207
 do_devconfig_ioctl drivers/comedi/comedi_fops.c:848 [inline]
 comedi_unlocked_ioctl+0xcde/0x1020 drivers/comedi/comedi_fops.c:2178
 vfs_ioctl fs/ioctl.c:51 [inline]
 __do_sys_ioctl fs/ioctl.c:597 [inline]
...">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-68335" target="_blank">CVE-2025-68335</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-12-22 11:16:01 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">N/A</span></p>
                    <p><span class="feed-label">CVSS Score:</span> N/A</p>
                    <p>In the Linux kernel, the following vulnerability has been resolved:

comedi: pcl818: fix null-ptr-deref in pcl818_ai_cancel()

Syzbot identified an issue [1] in pcl818_ai_cancel(), which stems from
the fact that in case of early device detach via pcl818_detach(),
subdevice dev->read_subdev may not have initialized its pointer to
&struct comedi_async as intended. Thus, any such dereferencing of
&s->async->cmd will lead to general protection fault and kernel crash.

Mitigate this problem by removing a call to pcl818_ai_cancel() from
pcl818_detach() altogether. This way, if the subdevice setups its
support for async commands, everything async-related will be
handled via subdevice's own ->cancel() function in
comedi_device_detach_locked() even before pcl818_detach(). If no
support for asynchronous commands is provided, there is no need
to cancel anything either.

[1] Syzbot crash:
Oops: general protection fault, probably for non-canonical address 0xdffffc0000000005: 0000 [#1] SMP KASAN PTI
KASAN: null-ptr-deref in range [0x0000000000000028-0x000000000000002f]
CPU: 1 UID: 0 PID: 6050 Comm: syz.0.18 Not tainted syzkaller #0 PREEMPT(full)
Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 08/18/2025
RIP: 0010:pcl818_ai_cancel+0x69/0x3f0 drivers/comedi/drivers/pcl818.c:762
...
Call Trace:
 <TASK>
 pcl818_detach+0x66/0xd0 drivers/comedi/drivers/pcl818.c:1115
 comedi_device_detach_locked+0x178/0x750 drivers/comedi/drivers.c:207
 do_devconfig_ioctl drivers/comedi/comedi_fops.c:848 [inline]
 comedi_unlocked_ioctl+0xcde/0x1020 drivers/comedi/comedi_fops.c:2178
 vfs_ioctl fs/ioctl.c:51 [inline]
 __do_sys_ioctl fs/ioctl.c:597 [inline]
...</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-68334" data-description="in the linux kernel, the following vulnerability has been resolved:

platform/x86/amd/pmc: add support for van gogh soc

the rog xbox ally (non-x) soc features a similar architecture to the
steam deck. while the steam deck supports s3 (s2idle causes a crash),
this support was dropped by the xbox ally which only s0ix suspend.

since the handler is missing here, this causes the device to not suspend
and the amd gpu driver to crash while trying to resume afterwards due to
a power hang.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-68334" target="_blank">CVE-2025-68334</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-12-22 11:16:01 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">N/A</span></p>
                    <p><span class="feed-label">CVSS Score:</span> N/A</p>
                    <p>In the Linux kernel, the following vulnerability has been resolved:

platform/x86/amd/pmc: Add support for Van Gogh SoC

The ROG Xbox Ally (non-X) SoC features a similar architecture to the
Steam Deck. While the Steam Deck supports S3 (s2idle causes a crash),
this support was dropped by the Xbox Ally which only S0ix suspend.

Since the handler is missing here, this causes the device to not suspend
and the AMD GPU driver to crash while trying to resume afterwards due to
a power hang.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-68333" data-description="in the linux kernel, the following vulnerability has been resolved:

sched_ext: fix possible deadlock in the deferred_irq_workfn()

for preempt_rt=y kernels, the deferred_irq_workfn() is executed in
the per-cpu irq_work/* task context and not disable-irq, if the rq
returned by container_of() is current cpu's rq, the following scenarios
may occur:

lock(&rq->__lock);
<interrupt>
  lock(&rq->__lock);

this commit use irq_work_init_hard() to replace init_irq_work() to
initialize rq->scx.deferred_irq_work, make the deferred_irq_workfn()
is always invoked in hard-irq context.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-68333" target="_blank">CVE-2025-68333</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-12-22 11:16:01 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">N/A</span></p>
                    <p><span class="feed-label">CVSS Score:</span> N/A</p>
                    <p>In the Linux kernel, the following vulnerability has been resolved:

sched_ext: Fix possible deadlock in the deferred_irq_workfn()

For PREEMPT_RT=y kernels, the deferred_irq_workfn() is executed in
the per-cpu irq_work/* task context and not disable-irq, if the rq
returned by container_of() is current CPU's rq, the following scenarios
may occur:

lock(&rq->__lock);
<Interrupt>
  lock(&rq->__lock);

This commit use IRQ_WORK_INIT_HARD() to replace init_irq_work() to
initialize rq->scx.deferred_irq_work, make the deferred_irq_workfn()
is always invoked in hard-irq context.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-68332" data-description="in the linux kernel, the following vulnerability has been resolved:

comedi: c6xdigio: fix invalid pnp driver unregistration

the comedi low-level driver "c6xdigio" seems to be for a parallel port
connected device.  when the comedi core calls the driver's comedi
"attach" handler `c6xdigio_attach()` to configure a comedi to use this
driver, it tries to enable the parallel port pnp resources by
registering a pnp driver with `pnp_register_driver()`, but ignores the
return value.  (the `struct pnp_driver` it uses has only the `name` and
`id_table` members filled in.)  the driver's comedi "detach" handler
`c6xdigio_detach()` unconditionally unregisters the pnp driver with
`pnp_unregister_driver()`.

it is possible for `c6xdigio_attach()` to return an error before it
calls `pnp_register_driver()` and it is possible for the call to
`pnp_register_driver()` to return an error (that is ignored).  in both
cases, the driver should not be calling `pnp_unregister_driver()` as it
does in `c6xdigio_detach()`.  (note that `c6xdigio_detach()` will be
called by the comedi core if `c6xdigio_attach()` returns an error, or if
the comedi core decides to detach the comedi device from the driver for
some other reason.)

the unconditional call to `pnp_unregister_driver()` without a previous
successful call to `pnp_register_driver()` will cause
`driver_unregister()` to issue a warning "unexpected driver
unregister!".  this was detected by syzbot [1].

also, the pnp driver registration and unregistration should be done at
module init and exit time, respectively, not when attaching or detaching
comedi devices to the driver.  (there might be more than one comedi
device being attached to the driver, although that is unlikely.)

change the driver to do the pnp driver registration at module init time,
and the unregistration at module exit time.  since `c6xdigio_detach()`
now only calls `comedi_legacy_detach()`, remove the function and change
the comedi driver "detach" handler to `comedi_legacy_detach`.

-------------------------------------------
[1] syzbot sample crash report:
unexpected driver unregister!
warning: cpu: 0 pid: 5970 at drivers/base/driver.c:273 driver_unregister drivers/base/driver.c:273 [inline]
warning: cpu: 0 pid: 5970 at drivers/base/driver.c:273 driver_unregister+0x90/0xb0 drivers/base/driver.c:270
modules linked in:
cpu: 0 uid: 0 pid: 5970 comm: syz.0.17 not tainted syzkaller #0 preempt(full)
hardware name: google google compute engine/google compute engine, bios google 10/02/2025
rip: 0010:driver_unregister drivers/base/driver.c:273 [inline]
rip: 0010:driver_unregister+0x90/0xb0 drivers/base/driver.c:270
code: 48 89 ef e8 c2 e6 82 fc 48 89 df e8 3a 93 ff ff 5b 5d e9 c3 6d d9 fb e8 be 6d d9 fb 90 48 c7 c7 e0 f8 1f 8c e8 51 a2 97 fb 90 <0f> 0b 90 90 5b 5d e9 a5 6d d9 fb e8 e0 f4 41 fc eb 94 e8 d9 f4 41
rsp: 0018:ffffc9000373f9a0 eflags: 00010282
rax: 0000000000000000 rbx: ffffffff8ff24720 rcx: ffffffff817b6ee8
rdx: ffff88807c932480 rsi: ffffffff817b6ef5 rdi: 0000000000000001
rbp: 0000000000000000 r08: 0000000000000001 r09: 0000000000000000
r10: 0000000000000001 r11: 0000000000000001 r12: ffffffff8ff24660
r13: dffffc0000000000 r14: 0000000000000000 r15: ffff88814cca0000
fs:  000055556dab1500(0000) gs:ffff8881249d9000(0000) knlgs:0000000000000000
cs:  0010 ds: 0000 es: 0000 cr0: 0000000080050033
cr2: 000055f77f285cd0 cr3: 000000007d871000 cr4: 00000000003526f0
call trace:
 <task>
 comedi_device_detach_locked+0x12f/0xa50 drivers/comedi/drivers.c:207
 comedi_device_detach+0x67/0xb0 drivers/comedi/drivers.c:215
 comedi_device_attach+0x43d/0x900 drivers/comedi/drivers.c:1011
 do_devconfig_ioctl+0x1b1/0x710 drivers/comedi/comedi_fops.c:872
 comedi_unlocked_ioctl+0x165d/0x2f00 drivers/comedi/comedi_fops.c:2178
 vfs_ioctl fs/ioctl.c:51 [inline]
 __do_sys_ioctl fs/ioctl.c:597 [inline]
 __se_sys_ioctl fs/ioctl.c:583 [inline]
 __x64_sys_ioctl+0x18e/0x210 fs/ioctl.c:583
 do_syscall_x64 arch/x86/entry/syscall_64.c:63 [inline]
 do_sys
---truncated---">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-68332" target="_blank">CVE-2025-68332</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-12-22 11:16:00 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">N/A</span></p>
                    <p><span class="feed-label">CVSS Score:</span> N/A</p>
                    <p>In the Linux kernel, the following vulnerability has been resolved:

comedi: c6xdigio: Fix invalid PNP driver unregistration

The Comedi low-level driver "c6xdigio" seems to be for a parallel port
connected device.  When the Comedi core calls the driver's Comedi
"attach" handler `c6xdigio_attach()` to configure a Comedi to use this
driver, it tries to enable the parallel port PNP resources by
registering a PNP driver with `pnp_register_driver()`, but ignores the
return value.  (The `struct pnp_driver` it uses has only the `name` and
`id_table` members filled in.)  The driver's Comedi "detach" handler
`c6xdigio_detach()` unconditionally unregisters the PNP driver with
`pnp_unregister_driver()`.

It is possible for `c6xdigio_attach()` to return an error before it
calls `pnp_register_driver()` and it is possible for the call to
`pnp_register_driver()` to return an error (that is ignored).  In both
cases, the driver should not be calling `pnp_unregister_driver()` as it
does in `c6xdigio_detach()`.  (Note that `c6xdigio_detach()` will be
called by the Comedi core if `c6xdigio_attach()` returns an error, or if
the Comedi core decides to detach the Comedi device from the driver for
some other reason.)

The unconditional call to `pnp_unregister_driver()` without a previous
successful call to `pnp_register_driver()` will cause
`driver_unregister()` to issue a warning "Unexpected driver
unregister!".  This was detected by Syzbot [1].

Also, the PNP driver registration and unregistration should be done at
module init and exit time, respectively, not when attaching or detaching
Comedi devices to the driver.  (There might be more than one Comedi
device being attached to the driver, although that is unlikely.)

Change the driver to do the PNP driver registration at module init time,
and the unregistration at module exit time.  Since `c6xdigio_detach()`
now only calls `comedi_legacy_detach()`, remove the function and change
the Comedi driver "detach" handler to `comedi_legacy_detach`.

-------------------------------------------
[1] Syzbot sample crash report:
Unexpected driver unregister!
WARNING: CPU: 0 PID: 5970 at drivers/base/driver.c:273 driver_unregister drivers/base/driver.c:273 [inline]
WARNING: CPU: 0 PID: 5970 at drivers/base/driver.c:273 driver_unregister+0x90/0xb0 drivers/base/driver.c:270
Modules linked in:
CPU: 0 UID: 0 PID: 5970 Comm: syz.0.17 Not tainted syzkaller #0 PREEMPT(full)
Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 10/02/2025
RIP: 0010:driver_unregister drivers/base/driver.c:273 [inline]
RIP: 0010:driver_unregister+0x90/0xb0 drivers/base/driver.c:270
Code: 48 89 ef e8 c2 e6 82 fc 48 89 df e8 3a 93 ff ff 5b 5d e9 c3 6d d9 fb e8 be 6d d9 fb 90 48 c7 c7 e0 f8 1f 8c e8 51 a2 97 fb 90 <0f> 0b 90 90 5b 5d e9 a5 6d d9 fb e8 e0 f4 41 fc eb 94 e8 d9 f4 41
RSP: 0018:ffffc9000373f9a0 EFLAGS: 00010282
RAX: 0000000000000000 RBX: ffffffff8ff24720 RCX: ffffffff817b6ee8
RDX: ffff88807c932480 RSI: ffffffff817b6ef5 RDI: 0000000000000001
RBP: 0000000000000000 R08: 0000000000000001 R09: 0000000000000000
R10: 0000000000000001 R11: 0000000000000001 R12: ffffffff8ff24660
R13: dffffc0000000000 R14: 0000000000000000 R15: ffff88814cca0000
FS:  000055556dab1500(0000) GS:ffff8881249d9000(0000) knlGS:0000000000000000
CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
CR2: 000055f77f285cd0 CR3: 000000007d871000 CR4: 00000000003526f0
Call Trace:
 <TASK>
 comedi_device_detach_locked+0x12f/0xa50 drivers/comedi/drivers.c:207
 comedi_device_detach+0x67/0xb0 drivers/comedi/drivers.c:215
 comedi_device_attach+0x43d/0x900 drivers/comedi/drivers.c:1011
 do_devconfig_ioctl+0x1b1/0x710 drivers/comedi/comedi_fops.c:872
 comedi_unlocked_ioctl+0x165d/0x2f00 drivers/comedi/comedi_fops.c:2178
 vfs_ioctl fs/ioctl.c:51 [inline]
 __do_sys_ioctl fs/ioctl.c:597 [inline]
 __se_sys_ioctl fs/ioctl.c:583 [inline]
 __x64_sys_ioctl+0x18e/0x210 fs/ioctl.c:583
 do_syscall_x64 arch/x86/entry/syscall_64.c:63 [inline]
 do_sys
---truncated---</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-68331" data-description="in the linux kernel, the following vulnerability has been resolved:

usb: uas: fix urb unmapping issue when the uas device is remove during ongoing data transfer

when a uas device is unplugged during data transfer, there is
a probability of a system panic occurring. the root cause is
an access to an invalid memory address during urb callback handling.
specifically, this happens when the dma_direct_unmap_sg() function
is called within the usb_hcd_unmap_urb_for_dma() interface, but the
sg->dma_address field is 0 and the sg data structure has already been
freed.

the scsi driver sends transfer commands by invoking uas_queuecommand_lck()
in uas.c, using the uas_submit_urbs() function to submit requests to usb.
within the uas_submit_urbs() implementation, three urbs (sense_urb,
data_urb, and cmd_urb) are sequentially submitted. device removal may
occur at any point during uas_submit_urbs execution, which may result
in urb submission failure. however, some urbs might have been successfully
submitted before the failure, and uas_submit_urbs will return the -enodev
error code in this case. the current error handling directly calls
scsi_done(). in the scsi driver, this eventually triggers scsi_complete()
to invoke scsi_end_request() for releasing the sgtable. the successfully
submitted urbs, when being unlinked to giveback, call
usb_hcd_unmap_urb_for_dma() in hcd.c, leading to exceptions during sg
unmapping operations since the sg data structure has already been freed.

this patch modifies the error condition check in the uas_submit_urbs()
function. when a uas device is removed but one or more urbs have already
been successfully submitted to usb, it avoids immediately invoking
scsi_done() and save the cmnd to devinfo->cmnd array. if the successfully
submitted urbs is completed before devinfo->resetting being set, then
the scsi_done() function will be called within uas_try_complete() after
all pending urb operations are finalized. otherwise, the scsi_done()
function will be called within uas_zap_pending(), which is executed after
usb_kill_anchored_urbs().

the error handling only takes effect when uas_queuecommand_lck() calls
uas_submit_urbs() and returns the error value -enodev . in this case,
the device is disconnected, and the flow proceeds to uas_disconnect(),
where uas_zap_pending() is invoked to call uas_try_complete().">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-68331" target="_blank">CVE-2025-68331</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-12-22 11:16:00 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">N/A</span></p>
                    <p><span class="feed-label">CVSS Score:</span> N/A</p>
                    <p>In the Linux kernel, the following vulnerability has been resolved:

usb: uas: fix urb unmapping issue when the uas device is remove during ongoing data transfer

When a UAS device is unplugged during data transfer, there is
a probability of a system panic occurring. The root cause is
an access to an invalid memory address during URB callback handling.
Specifically, this happens when the dma_direct_unmap_sg() function
is called within the usb_hcd_unmap_urb_for_dma() interface, but the
sg->dma_address field is 0 and the sg data structure has already been
freed.

The SCSI driver sends transfer commands by invoking uas_queuecommand_lck()
in uas.c, using the uas_submit_urbs() function to submit requests to USB.
Within the uas_submit_urbs() implementation, three URBs (sense_urb,
data_urb, and cmd_urb) are sequentially submitted. Device removal may
occur at any point during uas_submit_urbs execution, which may result
in URB submission failure. However, some URBs might have been successfully
submitted before the failure, and uas_submit_urbs will return the -ENODEV
error code in this case. The current error handling directly calls
scsi_done(). In the SCSI driver, this eventually triggers scsi_complete()
to invoke scsi_end_request() for releasing the sgtable. The successfully
submitted URBs, when being unlinked to giveback, call
usb_hcd_unmap_urb_for_dma() in hcd.c, leading to exceptions during sg
unmapping operations since the sg data structure has already been freed.

This patch modifies the error condition check in the uas_submit_urbs()
function. When a UAS device is removed but one or more URBs have already
been successfully submitted to USB, it avoids immediately invoking
scsi_done() and save the cmnd to devinfo->cmnd array. If the successfully
submitted URBs is completed before devinfo->resetting being set, then
the scsi_done() function will be called within uas_try_complete() after
all pending URB operations are finalized. Otherwise, the scsi_done()
function will be called within uas_zap_pending(), which is executed after
usb_kill_anchored_urbs().

The error handling only takes effect when uas_queuecommand_lck() calls
uas_submit_urbs() and returns the error value -ENODEV . In this case,
the device is disconnected, and the flow proceeds to uas_disconnect(),
where uas_zap_pending() is invoked to call uas_try_complete().</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-68330" data-description="in the linux kernel, the following vulnerability has been resolved:

iio: accel: bmc150: fix irq assumption regression

the code in bmc150-accel-core.c unconditionally calls
bmc150_accel_set_interrupt() in the iio_buffer_setup_ops,
such as on the runtime pm resume path giving a kernel
splat like this if the device has no interrupts:

unable to handle kernel null pointer dereference at virtual
  address 00000001 when read

pc is at bmc150_accel_set_interrupt+0x98/0x194
lr is at __pm_runtime_resume+0x5c/0x64
(...)
call trace:
bmc150_accel_set_interrupt from bmc150_accel_buffer_postenable+0x40/0x108
bmc150_accel_buffer_postenable from __iio_update_buffers+0xbe0/0xcbc
__iio_update_buffers from enable_store+0x84/0xc8
enable_store from kernfs_fop_write_iter+0x154/0x1b4

this bug seems to have been in the driver since the beginning,
but it only manifests recently, i do not know why.

store the irq number in the state struct, as this is a common
pattern in other drivers, then use this to determine if we have
irq support or not.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-68330" target="_blank">CVE-2025-68330</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-12-22 11:16:00 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">N/A</span></p>
                    <p><span class="feed-label">CVSS Score:</span> N/A</p>
                    <p>In the Linux kernel, the following vulnerability has been resolved:

iio: accel: bmc150: Fix irq assumption regression

The code in bmc150-accel-core.c unconditionally calls
bmc150_accel_set_interrupt() in the iio_buffer_setup_ops,
such as on the runtime PM resume path giving a kernel
splat like this if the device has no interrupts:

Unable to handle kernel NULL pointer dereference at virtual
  address 00000001 when read

PC is at bmc150_accel_set_interrupt+0x98/0x194
LR is at __pm_runtime_resume+0x5c/0x64
(...)
Call trace:
bmc150_accel_set_interrupt from bmc150_accel_buffer_postenable+0x40/0x108
bmc150_accel_buffer_postenable from __iio_update_buffers+0xbe0/0xcbc
__iio_update_buffers from enable_store+0x84/0xc8
enable_store from kernfs_fop_write_iter+0x154/0x1b4

This bug seems to have been in the driver since the beginning,
but it only manifests recently, I do not know why.

Store the IRQ number in the state struct, as this is a common
pattern in other drivers, then use this to determine if we have
IRQ support or not.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-68329" data-description="in the linux kernel, the following vulnerability has been resolved:

tracing: fix warn_on in tracing_buffers_mmap_close for split vmas

when a vma is split (e.g., by partial munmap or map_fixed), the kernel
calls vm_ops->close on each portion. for trace buffer mappings, this
results in ring_buffer_unmap() being called multiple times while
ring_buffer_map() was only called once.

this causes ring_buffer_unmap() to return -enodev on subsequent calls
because user_mapped is already 0, triggering a warn_on.

trace buffer mappings cannot support partial mappings because the ring
buffer structure requires the complete buffer including the meta page.

fix this by adding a may_split callback that returns -einval to prevent
vma splits entirely.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-68329" target="_blank">CVE-2025-68329</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-12-22 11:16:00 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">N/A</span></p>
                    <p><span class="feed-label">CVSS Score:</span> N/A</p>
                    <p>In the Linux kernel, the following vulnerability has been resolved:

tracing: Fix WARN_ON in tracing_buffers_mmap_close for split VMAs

When a VMA is split (e.g., by partial munmap or MAP_FIXED), the kernel
calls vm_ops->close on each portion. For trace buffer mappings, this
results in ring_buffer_unmap() being called multiple times while
ring_buffer_map() was only called once.

This causes ring_buffer_unmap() to return -ENODEV on subsequent calls
because user_mapped is already 0, triggering a WARN_ON.

Trace buffer mappings cannot support partial mappings because the ring
buffer structure requires the complete buffer including the meta page.

Fix this by adding a may_split callback that returns -EINVAL to prevent
VMA splits entirely.</p>
                </div>
        
            </div>
        </div>

        <footer class="footer">
            <p>Â© 2025 dotne1 - Cybersecurity Portfolio</p>
        </footer>

        <script>
            function searchCVEs() {
                const input = document.getElementById('searchInput').value.toLowerCase();
                const cveEntries = document.getElementsByClassName('cve-entry');
                for (let i = 0; i < cveEntries.length; i++) {
                    const cveId = cveEntries[i].getAttribute('data-cve-id').toLowerCase();
                    const description = cveEntries[i].getAttribute('data-description');
                    if (cveId.includes(input) || description.includes(input)) {
                        cveEntries[i].style.display = '';
                    } else {
                        cveEntries[i].style.display = 'none';
                    }
                }
            }
        </script>
    </body>
    </html>
    