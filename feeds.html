
    <!DOCTYPE html>
    <html lang="en">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <meta name="description" content="Security alerts and cybersecurity news feeds">
        <meta name="keywords" content="cybersecurity news, security alerts, vulnerability feeds, threat intelligence">
        <meta name="author" content="dotne1">
        <meta property="og:title" content="Security Feeds - dotne1's Cybersecurity Portfolio">
        <meta property="og:description" content="Stay updated with the latest cybersecurity news and alerts">
        <meta property="og:type" content="website">
        <title>Security Feeds - dotne1's Cybersecurity Portfolio</title>
        <link rel="stylesheet" href="styles.css">
        <link rel="icon" type="image/x-icon" href="/favicon.ico">
    </head>
    <body>
        <nav class="navbar">
            <div class="nav-links">
                <a href="index.html" class="nav-link">Home</a>
                <a href="about-me.html" class="nav-link">About Me</a>
                <a href="projects.html" class="nav-link">Projects</a>
                <a href="resume.html" class="nav-link">Resume</a>
                <a href="feeds.html" class="nav-link">Feeds</a>
            </div>
        </nav>

        <div class="container" role="main">
            <h1 class="main-header">Security Feeds</h1>
            <div class="search-bar">
                <input type="text" id="searchInput" placeholder="Search CVEs..." onkeyup="searchCVEs()">
            </div>
            <div class="feed-preview" id="cveFeed">
                <div class="feed-header">Latest Vulnerabilities</div>
    
                <div class="cve-entry" data-cve-id="CVE-2025-15248" data-description="a security flaw has been discovered in sunhailin12315 product-review 商品评价系统 up to 91ead6890b4065bb45b7602d0d73348e75cb4639. this affects an unknown part of the component write a review. performing manipulation of the argument content results in cross site scripting. the attack is possible to be carried out remotely. the exploit has been released to the public and may be exploited. this product adopts a rolling release strategy to maintain continuous delivery the project was informed of the problem early through an issue report but has not responded yet.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-15248" target="_blank">CVE-2025-15248</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-12-30 07:16:23 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">LOW</span></p>
                    <p><span class="feed-label">CVSS Score:</span> 3.5</p>
                    <p>A security flaw has been discovered in sunhailin12315 product-review 商品评价系统 up to 91ead6890b4065bb45b7602d0d73348e75cb4639. This affects an unknown part of the component Write a Review. Performing manipulation of the argument content results in cross site scripting. The attack is possible to be carried out remotely. The exploit has been released to the public and may be exploited. This product adopts a rolling release strategy to maintain continuous delivery The project was informed of the problem early through an issue report but has not responded yet.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2025-14426" data-description="the strong testimonials plugin for wordpress is vulnerable to unauthorized modification of data due to a missing capability check in the 'edit_rating' function in all versions up to, and including, 3.2.18. this makes it possible for authenticated attackers with contributor-level access and above to modify or delete the rating meta on any testimonial post, including those created by other users, by reusing a valid nonce obtained from their own testimonial edit screen.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2025-14426" target="_blank">CVE-2025-14426</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-12-30 07:16:22 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">MEDIUM</span></p>
                    <p><span class="feed-label">CVSS Score:</span> 4.3</p>
                    <p>The Strong Testimonials plugin for WordPress is vulnerable to unauthorized modification of data due to a missing capability check in the 'edit_rating' function in all versions up to, and including, 3.2.18. This makes it possible for authenticated attackers with Contributor-level access and above to modify or delete the rating meta on any testimonial post, including those created by other users, by reusing a valid nonce obtained from their own testimonial edit screen.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2024-58247" data-description="rejected reason: ** reject ** do not use this cve record. consultids: none. reason: this record was in a cna pool that was not assigned to any issues during 2024. notes: none.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2024-58247" target="_blank">CVE-2024-58247</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-12-30 07:16:22 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">N/A</span></p>
                    <p><span class="feed-label">CVSS Score:</span> N/A</p>
                    <p>Rejected reason: ** REJECT ** DO NOT USE THIS CVE RECORD. ConsultIDs: none. Reason: This record was in a CNA pool that was not assigned to any issues during 2024. Notes: none.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2024-58246" data-description="rejected reason: ** reject ** do not use this cve record. consultids: none. reason: this record was in a cna pool that was not assigned to any issues during 2024. notes: none.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2024-58246" target="_blank">CVE-2024-58246</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-12-30 07:16:22 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">N/A</span></p>
                    <p><span class="feed-label">CVSS Score:</span> N/A</p>
                    <p>Rejected reason: ** REJECT ** DO NOT USE THIS CVE RECORD. ConsultIDs: none. Reason: This record was in a CNA pool that was not assigned to any issues during 2024. Notes: none.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2024-58245" data-description="rejected reason: ** reject ** do not use this cve record. consultids: none. reason: this record was in a cna pool that was not assigned to any issues during 2024. notes: none.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2024-58245" target="_blank">CVE-2024-58245</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-12-30 07:16:22 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">N/A</span></p>
                    <p><span class="feed-label">CVSS Score:</span> N/A</p>
                    <p>Rejected reason: ** REJECT ** DO NOT USE THIS CVE RECORD. ConsultIDs: none. Reason: This record was in a CNA pool that was not assigned to any issues during 2024. Notes: none.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2024-58244" data-description="rejected reason: ** reject ** do not use this cve record. consultids: none. reason: this record was in a cna pool that was not assigned to any issues during 2024. notes: none.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2024-58244" target="_blank">CVE-2024-58244</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-12-30 07:16:22 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">N/A</span></p>
                    <p><span class="feed-label">CVSS Score:</span> N/A</p>
                    <p>Rejected reason: ** REJECT ** DO NOT USE THIS CVE RECORD. ConsultIDs: none. Reason: This record was in a CNA pool that was not assigned to any issues during 2024. Notes: none.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2024-58243" data-description="rejected reason: ** reject ** do not use this cve record. consultids: none. reason: this record was in a cna pool that was not assigned to any issues during 2024. notes: none.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2024-58243" target="_blank">CVE-2024-58243</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-12-30 07:16:22 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">N/A</span></p>
                    <p><span class="feed-label">CVSS Score:</span> N/A</p>
                    <p>Rejected reason: ** REJECT ** DO NOT USE THIS CVE RECORD. ConsultIDs: none. Reason: This record was in a CNA pool that was not assigned to any issues during 2024. Notes: none.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2024-58242" data-description="rejected reason: ** reject ** do not use this cve record. consultids: none. reason: this record was in a cna pool that was not assigned to any issues during 2024. notes: none.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2024-58242" target="_blank">CVE-2024-58242</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-12-30 07:16:22 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">N/A</span></p>
                    <p><span class="feed-label">CVSS Score:</span> N/A</p>
                    <p>Rejected reason: ** REJECT ** DO NOT USE THIS CVE RECORD. ConsultIDs: none. Reason: This record was in a CNA pool that was not assigned to any issues during 2024. Notes: none.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2023-54326" data-description="in the linux kernel, the following vulnerability has been resolved:

misc: pci_endpoint_test: free irqs before removing the device

in pci_endpoint_test_remove(), freeing the irqs after removing the device
creates a small race window for irqs to be received with the test device
memory already released, causing the irq handler to access invalid memory,
resulting in an oops.

free the device irqs before removing the device to avoid this issue.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2023-54326" target="_blank">CVE-2023-54326</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-12-30 07:16:21 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">N/A</span></p>
                    <p><span class="feed-label">CVSS Score:</span> N/A</p>
                    <p>In the Linux kernel, the following vulnerability has been resolved:

misc: pci_endpoint_test: Free IRQs before removing the device

In pci_endpoint_test_remove(), freeing the IRQs after removing the device
creates a small race window for IRQs to be received with the test device
memory already released, causing the IRQ handler to access invalid memory,
resulting in an oops.

Free the device IRQs before removing the device to avoid this issue.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2023-54325" data-description="in the linux kernel, the following vulnerability has been resolved:

crypto: qat - fix out-of-bounds read

when preparing an aer-ctr request, the driver copies the key provided by
the user into a data structure that is accessible by the firmware.
if the target device is qat gen4, the key size is rounded up by 16 since
a rounded up size is expected by the device.
if the key size is rounded up before the copy, the size used for copying
the key might be bigger than the size of the region containing the key,
causing an out-of-bounds read.

fix by doing the copy first and then update the keylen.

this is to fix the following warning reported by kasan:

	[  138.150574] bug: kasan: global-out-of-bounds in qat_alg_skcipher_init_com.isra.0+0x197/0x250 [intel_qat]
	[  138.150641] read of size 32 at addr ffffffff88c402c0 by task cryptomgr_test/2340

	[  138.150651] cpu: 15 pid: 2340 comm: cryptomgr_test not tainted 6.2.0-rc1+ #45
	[  138.150659] hardware name: intel corporation archercity/archercity, bios egsdcrb1.86b.0087.d13.2208261706 08/26/2022
	[  138.150663] call trace:
	[  138.150668]  <task>
	[  138.150922]  kasan_check_range+0x13a/0x1c0
	[  138.150931]  memcpy+0x1f/0x60
	[  138.150940]  qat_alg_skcipher_init_com.isra.0+0x197/0x250 [intel_qat]
	[  138.151006]  qat_alg_skcipher_init_sessions+0xc1/0x240 [intel_qat]
	[  138.151073]  crypto_skcipher_setkey+0x82/0x160
	[  138.151085]  ? prepare_keybuf+0xa2/0xd0
	[  138.151095]  test_skcipher_vec_cfg+0x2b8/0x800">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2023-54325" target="_blank">CVE-2023-54325</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-12-30 07:16:21 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">N/A</span></p>
                    <p><span class="feed-label">CVSS Score:</span> N/A</p>
                    <p>In the Linux kernel, the following vulnerability has been resolved:

crypto: qat - fix out-of-bounds read

When preparing an AER-CTR request, the driver copies the key provided by
the user into a data structure that is accessible by the firmware.
If the target device is QAT GEN4, the key size is rounded up by 16 since
a rounded up size is expected by the device.
If the key size is rounded up before the copy, the size used for copying
the key might be bigger than the size of the region containing the key,
causing an out-of-bounds read.

Fix by doing the copy first and then update the keylen.

This is to fix the following warning reported by KASAN:

	[  138.150574] BUG: KASAN: global-out-of-bounds in qat_alg_skcipher_init_com.isra.0+0x197/0x250 [intel_qat]
	[  138.150641] Read of size 32 at addr ffffffff88c402c0 by task cryptomgr_test/2340

	[  138.150651] CPU: 15 PID: 2340 Comm: cryptomgr_test Not tainted 6.2.0-rc1+ #45
	[  138.150659] Hardware name: Intel Corporation ArcherCity/ArcherCity, BIOS EGSDCRB1.86B.0087.D13.2208261706 08/26/2022
	[  138.150663] Call Trace:
	[  138.150668]  <TASK>
	[  138.150922]  kasan_check_range+0x13a/0x1c0
	[  138.150931]  memcpy+0x1f/0x60
	[  138.150940]  qat_alg_skcipher_init_com.isra.0+0x197/0x250 [intel_qat]
	[  138.151006]  qat_alg_skcipher_init_sessions+0xc1/0x240 [intel_qat]
	[  138.151073]  crypto_skcipher_setkey+0x82/0x160
	[  138.151085]  ? prepare_keybuf+0xa2/0xd0
	[  138.151095]  test_skcipher_vec_cfg+0x2b8/0x800</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2023-54324" data-description="in the linux kernel, the following vulnerability has been resolved:

dm: fix a race condition in retrieve_deps

there's a race condition in the multipath target when retrieve_deps
races with multipath_message calling dm_get_device and dm_put_device.
retrieve_deps walks the list of open devices without holding any lock
but multipath may add or remove devices to the list while it is
running. the end result may be memory corruption or use-after-free
memory access.

see this description of a uaf with multipath_message():
https://listman.redhat.com/archives/dm-devel/2022-october/052373.html

fix this bug by introducing a new rw semaphore "devices_lock". we grab
devices_lock for read in retrieve_deps and we grab it for write in
dm_get_device and dm_put_device.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2023-54324" target="_blank">CVE-2023-54324</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-12-30 07:16:21 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">N/A</span></p>
                    <p><span class="feed-label">CVSS Score:</span> N/A</p>
                    <p>In the Linux kernel, the following vulnerability has been resolved:

dm: fix a race condition in retrieve_deps

There's a race condition in the multipath target when retrieve_deps
races with multipath_message calling dm_get_device and dm_put_device.
retrieve_deps walks the list of open devices without holding any lock
but multipath may add or remove devices to the list while it is
running. The end result may be memory corruption or use-after-free
memory access.

See this description of a UAF with multipath_message():
https://listman.redhat.com/archives/dm-devel/2022-October/052373.html

Fix this bug by introducing a new rw semaphore "devices_lock". We grab
devices_lock for read in retrieve_deps and we grab it for write in
dm_get_device and dm_put_device.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2023-54323" data-description="in the linux kernel, the following vulnerability has been resolved:

cxl/pmem: fix nvdimm registration races

a loop of the form:

    while true; do modprobe cxl_pci; modprobe -r cxl_pci; done

...fails with the following crash signature:

    bug: kernel null pointer dereference, address: 0000000000000040
    [..]
    rip: 0010:cxl_internal_send_cmd+0x5/0xb0 [cxl_core]
    [..]
    call trace:
     <task>
     cxl_pmem_ctl+0x121/0x240 [cxl_pmem]
     nvdimm_get_config_data+0xd6/0x1a0 [libnvdimm]
     nd_label_data_init+0x135/0x7e0 [libnvdimm]
     nvdimm_probe+0xd6/0x1c0 [libnvdimm]
     nvdimm_bus_probe+0x7a/0x1e0 [libnvdimm]
     really_probe+0xde/0x380
     __driver_probe_device+0x78/0x170
     driver_probe_device+0x1f/0x90
     __device_attach_driver+0x85/0x110
     bus_for_each_drv+0x7d/0xc0
     __device_attach+0xb4/0x1e0
     bus_probe_device+0x9f/0xc0
     device_add+0x445/0x9c0
     nd_async_device_register+0xe/0x40 [libnvdimm]
     async_run_entry_fn+0x30/0x130

...namely that the bottom half of async nvdimm device registration runs
after the cxl has already torn down the context that cxl_pmem_ctl()
needs. unlike the acpi nfit case that benefits from launching multiple
nvdimm device registrations in parallel from those listed in the table,
cxl is already marked probe_prefer_asynchronous. so provide for a
synchronous registration path to preclude this scenario.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2023-54323" target="_blank">CVE-2023-54323</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-12-30 07:16:21 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">N/A</span></p>
                    <p><span class="feed-label">CVSS Score:</span> N/A</p>
                    <p>In the Linux kernel, the following vulnerability has been resolved:

cxl/pmem: Fix nvdimm registration races

A loop of the form:

    while true; do modprobe cxl_pci; modprobe -r cxl_pci; done

...fails with the following crash signature:

    BUG: kernel NULL pointer dereference, address: 0000000000000040
    [..]
    RIP: 0010:cxl_internal_send_cmd+0x5/0xb0 [cxl_core]
    [..]
    Call Trace:
     <TASK>
     cxl_pmem_ctl+0x121/0x240 [cxl_pmem]
     nvdimm_get_config_data+0xd6/0x1a0 [libnvdimm]
     nd_label_data_init+0x135/0x7e0 [libnvdimm]
     nvdimm_probe+0xd6/0x1c0 [libnvdimm]
     nvdimm_bus_probe+0x7a/0x1e0 [libnvdimm]
     really_probe+0xde/0x380
     __driver_probe_device+0x78/0x170
     driver_probe_device+0x1f/0x90
     __device_attach_driver+0x85/0x110
     bus_for_each_drv+0x7d/0xc0
     __device_attach+0xb4/0x1e0
     bus_probe_device+0x9f/0xc0
     device_add+0x445/0x9c0
     nd_async_device_register+0xe/0x40 [libnvdimm]
     async_run_entry_fn+0x30/0x130

...namely that the bottom half of async nvdimm device registration runs
after the CXL has already torn down the context that cxl_pmem_ctl()
needs. Unlike the ACPI NFIT case that benefits from launching multiple
nvdimm device registrations in parallel from those listed in the table,
CXL is already marked PROBE_PREFER_ASYNCHRONOUS. So provide for a
synchronous registration path to preclude this scenario.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2023-54322" data-description="in the linux kernel, the following vulnerability has been resolved:

arm64: set __exception_irq_entry with __irq_entry as a default

filter_irq_stacks() is supposed to cut entries which are related irq entries
from its call stack.
and in_irqentry_text() which is called by filter_irq_stacks()
uses __irqentry_text_start/end symbol to find irq entries in callstack.

but it doesn't work correctly as without "config_function_graph_tracer",
arm64 kernel doesn't include gic_handle_irq which is entry point of arm64 irq
between __irqentry_text_start and __irqentry_text_end as we discussed in below link.
https://lore.kernel.org/all/cact4y+aremglyua2rclhgfps9io5czc04q8gls-unmrn1ezxyq@mail.gmail.com/#t

this problem can makes unintentional deep call stack entries especially
in kasan enabled situation as below.

[ 2479.383395]i[0:launcher-loader: 1719] stack depot reached limit capacity
[ 2479.383538]i[0:launcher-loader: 1719] warning: cpu: 0 pid: 1719 at lib/stackdepot.c:129 __stack_depot_save+0x464/0x46c
[ 2479.385693]i[0:launcher-loader: 1719] pstate: 624000c5 (nzcv daif +pan -uao +tco -dit -ssbs btype=--)
[ 2479.385724]i[0:launcher-loader: 1719] pc : __stack_depot_save+0x464/0x46c
[ 2479.385751]i[0:launcher-loader: 1719] lr : __stack_depot_save+0x460/0x46c
[ 2479.385774]i[0:launcher-loader: 1719] sp : ffffffc0080073c0
[ 2479.385793]i[0:launcher-loader: 1719] x29: ffffffc0080073e0 x28: ffffffd00b78a000 x27: 0000000000000000
[ 2479.385839]i[0:launcher-loader: 1719] x26: 000000000004d1dd x25: ffffff891474f000 x24: 00000000ca64d1dd
[ 2479.385882]i[0:launcher-loader: 1719] x23: 0000000000000200 x22: 0000000000000220 x21: 0000000000000040
[ 2479.385925]i[0:launcher-loader: 1719] x20: ffffffc008007440 x19: 0000000000000000 x18: 0000000000000000
[ 2479.385969]i[0:launcher-loader: 1719] x17: 2065726568207475 x16: 000000000000005e x15: 2d2d2d2d2d2d2d20
[ 2479.386013]i[0:launcher-loader: 1719] x14: 5d39313731203a72 x13: 00000000002f6b30 x12: 00000000002f6af8
[ 2479.386057]i[0:launcher-loader: 1719] x11: 00000000ffffffff x10: ffffffb90aacf000 x9 : e8a74a6c16008800
[ 2479.386101]i[0:launcher-loader: 1719] x8 : e8a74a6c16008800 x7 : 00000000002f6b30 x6 : 00000000002f6af8
[ 2479.386145]i[0:launcher-loader: 1719] x5 : ffffffc0080070c8 x4 : ffffffd00b192380 x3 : ffffffd0092b313c
[ 2479.386189]i[0:launcher-loader: 1719] x2 : 0000000000000001 x1 : 0000000000000004 x0 : 0000000000000022
[ 2479.386231]i[0:launcher-loader: 1719] call trace:
[ 2479.386248]i[0:launcher-loader: 1719]  __stack_depot_save+0x464/0x46c
[ 2479.386273]i[0:launcher-loader: 1719]  kasan_save_stack+0x58/0x70
[ 2479.386303]i[0:launcher-loader: 1719]  save_stack_info+0x34/0x138
[ 2479.386331]i[0:launcher-loader: 1719]  kasan_save_free_info+0x18/0x24
[ 2479.386358]i[0:launcher-loader: 1719]  ____kasan_slab_free+0x16c/0x170
[ 2479.386385]i[0:launcher-loader: 1719]  __kasan_slab_free+0x10/0x20
[ 2479.386410]i[0:launcher-loader: 1719]  kmem_cache_free+0x238/0x53c
[ 2479.386435]i[0:launcher-loader: 1719]  mempool_free_slab+0x1c/0x28
[ 2479.386460]i[0:launcher-loader: 1719]  mempool_free+0x7c/0x1a0
[ 2479.386484]i[0:launcher-loader: 1719]  bvec_free+0x34/0x80
[ 2479.386514]i[0:launcher-loader: 1719]  bio_free+0x60/0x98
[ 2479.386540]i[0:launcher-loader: 1719]  bio_put+0x50/0x21c
[ 2479.386567]i[0:launcher-loader: 1719]  f2fs_write_end_io+0x4ac/0x4d0
[ 2479.386594]i[0:launcher-loader: 1719]  bio_endio+0x2dc/0x300
[ 2479.386622]i[0:launcher-loader: 1719]  __dm_io_complete+0x324/0x37c
[ 2479.386650]i[0:launcher-loader: 1719]  dm_io_dec_pending+0x60/0xa4
[ 2479.386676]i[0:launcher-loader: 1719]  clone_endio+0xf8/0x2f0
[ 2479.386700]i[0:launcher-loader: 1719]  bio_endio+0x2dc/0x300
[ 2479.386727]i[0:launcher-loader: 1719]  blk_update_request+0x258/0x63c
[ 2479.386754]i[0:launcher-loader: 1719]  scsi_end_request+0x50/0x304
[ 2479.386782]i[0:launcher-loader: 1719]  scsi_io_completion+0x88/0x160
[ 2479.386808]i[0:launcher-loader: 1719]  scsi_finish_command+0x17c/0x194
[ 2479.386833]i
---truncated---">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2023-54322" target="_blank">CVE-2023-54322</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-12-30 07:16:21 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">N/A</span></p>
                    <p><span class="feed-label">CVSS Score:</span> N/A</p>
                    <p>In the Linux kernel, the following vulnerability has been resolved:

arm64: set __exception_irq_entry with __irq_entry as a default

filter_irq_stacks() is supposed to cut entries which are related irq entries
from its call stack.
And in_irqentry_text() which is called by filter_irq_stacks()
uses __irqentry_text_start/end symbol to find irq entries in callstack.

But it doesn't work correctly as without "CONFIG_FUNCTION_GRAPH_TRACER",
arm64 kernel doesn't include gic_handle_irq which is entry point of arm64 irq
between __irqentry_text_start and __irqentry_text_end as we discussed in below link.
https://lore.kernel.org/all/CACT4Y+aReMGLYua2rCLHgFpS9io5cZC04Q8GLs-uNmrn1ezxYQ@mail.gmail.com/#t

This problem can makes unintentional deep call stack entries especially
in KASAN enabled situation as below.

[ 2479.383395]I[0:launcher-loader: 1719] Stack depot reached limit capacity
[ 2479.383538]I[0:launcher-loader: 1719] WARNING: CPU: 0 PID: 1719 at lib/stackdepot.c:129 __stack_depot_save+0x464/0x46c
[ 2479.385693]I[0:launcher-loader: 1719] pstate: 624000c5 (nZCv daIF +PAN -UAO +TCO -DIT -SSBS BTYPE=--)
[ 2479.385724]I[0:launcher-loader: 1719] pc : __stack_depot_save+0x464/0x46c
[ 2479.385751]I[0:launcher-loader: 1719] lr : __stack_depot_save+0x460/0x46c
[ 2479.385774]I[0:launcher-loader: 1719] sp : ffffffc0080073c0
[ 2479.385793]I[0:launcher-loader: 1719] x29: ffffffc0080073e0 x28: ffffffd00b78a000 x27: 0000000000000000
[ 2479.385839]I[0:launcher-loader: 1719] x26: 000000000004d1dd x25: ffffff891474f000 x24: 00000000ca64d1dd
[ 2479.385882]I[0:launcher-loader: 1719] x23: 0000000000000200 x22: 0000000000000220 x21: 0000000000000040
[ 2479.385925]I[0:launcher-loader: 1719] x20: ffffffc008007440 x19: 0000000000000000 x18: 0000000000000000
[ 2479.385969]I[0:launcher-loader: 1719] x17: 2065726568207475 x16: 000000000000005e x15: 2d2d2d2d2d2d2d20
[ 2479.386013]I[0:launcher-loader: 1719] x14: 5d39313731203a72 x13: 00000000002f6b30 x12: 00000000002f6af8
[ 2479.386057]I[0:launcher-loader: 1719] x11: 00000000ffffffff x10: ffffffb90aacf000 x9 : e8a74a6c16008800
[ 2479.386101]I[0:launcher-loader: 1719] x8 : e8a74a6c16008800 x7 : 00000000002f6b30 x6 : 00000000002f6af8
[ 2479.386145]I[0:launcher-loader: 1719] x5 : ffffffc0080070c8 x4 : ffffffd00b192380 x3 : ffffffd0092b313c
[ 2479.386189]I[0:launcher-loader: 1719] x2 : 0000000000000001 x1 : 0000000000000004 x0 : 0000000000000022
[ 2479.386231]I[0:launcher-loader: 1719] Call trace:
[ 2479.386248]I[0:launcher-loader: 1719]  __stack_depot_save+0x464/0x46c
[ 2479.386273]I[0:launcher-loader: 1719]  kasan_save_stack+0x58/0x70
[ 2479.386303]I[0:launcher-loader: 1719]  save_stack_info+0x34/0x138
[ 2479.386331]I[0:launcher-loader: 1719]  kasan_save_free_info+0x18/0x24
[ 2479.386358]I[0:launcher-loader: 1719]  ____kasan_slab_free+0x16c/0x170
[ 2479.386385]I[0:launcher-loader: 1719]  __kasan_slab_free+0x10/0x20
[ 2479.386410]I[0:launcher-loader: 1719]  kmem_cache_free+0x238/0x53c
[ 2479.386435]I[0:launcher-loader: 1719]  mempool_free_slab+0x1c/0x28
[ 2479.386460]I[0:launcher-loader: 1719]  mempool_free+0x7c/0x1a0
[ 2479.386484]I[0:launcher-loader: 1719]  bvec_free+0x34/0x80
[ 2479.386514]I[0:launcher-loader: 1719]  bio_free+0x60/0x98
[ 2479.386540]I[0:launcher-loader: 1719]  bio_put+0x50/0x21c
[ 2479.386567]I[0:launcher-loader: 1719]  f2fs_write_end_io+0x4ac/0x4d0
[ 2479.386594]I[0:launcher-loader: 1719]  bio_endio+0x2dc/0x300
[ 2479.386622]I[0:launcher-loader: 1719]  __dm_io_complete+0x324/0x37c
[ 2479.386650]I[0:launcher-loader: 1719]  dm_io_dec_pending+0x60/0xa4
[ 2479.386676]I[0:launcher-loader: 1719]  clone_endio+0xf8/0x2f0
[ 2479.386700]I[0:launcher-loader: 1719]  bio_endio+0x2dc/0x300
[ 2479.386727]I[0:launcher-loader: 1719]  blk_update_request+0x258/0x63c
[ 2479.386754]I[0:launcher-loader: 1719]  scsi_end_request+0x50/0x304
[ 2479.386782]I[0:launcher-loader: 1719]  scsi_io_completion+0x88/0x160
[ 2479.386808]I[0:launcher-loader: 1719]  scsi_finish_command+0x17c/0x194
[ 2479.386833]I
---truncated---</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2023-54321" data-description="in the linux kernel, the following vulnerability has been resolved:

driver core: fix potential null-ptr-deref in device_add()

i got the following null-ptr-deref report while doing fault injection test:

bug: kernel null pointer dereference, address: 0000000000000058
cpu: 2 pid: 278 comm: 37-i2c-ds2482 tainted: g    b   w        n 6.1.0-rc3+
rip: 0010:klist_put+0x2d/0xd0
call trace:
 <task>
 klist_remove+0xf1/0x1c0
 device_release_driver_internal+0x196/0x210
 bus_remove_device+0x1bd/0x240
 device_add+0xd3d/0x1100
 w1_add_master_device+0x476/0x490 [wire]
 ds2482_probe+0x303/0x3e0 [ds2482]

this is how it happened:

w1_alloc_dev()
  // the dev->driver is set to w1_master_driver.
  memcpy(&dev->dev, device, sizeof(struct device));
  device_add()
    bus_add_device()
    dpm_sysfs_add() // it fails, calls bus_remove_device.

    // error path
    bus_remove_device()
      // the dev->driver is not null, but driver is not bound.
      __device_release_driver()
        klist_remove(&dev->p->knode_driver) <-- it causes null-ptr-deref.

    // normal path
    bus_probe_device() // it's not called yet.
      device_bind_driver()

if dev->driver is set, in the error path after calling bus_add_device()
in device_add(), bus_remove_device() is called, then the device will be
detached from driver. but device_bind_driver() is not called yet, so it
causes null-ptr-deref while access the 'knode_driver'. to fix this, set
dev->driver to null in the error path before calling bus_remove_device().">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2023-54321" target="_blank">CVE-2023-54321</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-12-30 07:16:21 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">N/A</span></p>
                    <p><span class="feed-label">CVSS Score:</span> N/A</p>
                    <p>In the Linux kernel, the following vulnerability has been resolved:

driver core: fix potential null-ptr-deref in device_add()

I got the following null-ptr-deref report while doing fault injection test:

BUG: kernel NULL pointer dereference, address: 0000000000000058
CPU: 2 PID: 278 Comm: 37-i2c-ds2482 Tainted: G    B   W        N 6.1.0-rc3+
RIP: 0010:klist_put+0x2d/0xd0
Call Trace:
 <TASK>
 klist_remove+0xf1/0x1c0
 device_release_driver_internal+0x196/0x210
 bus_remove_device+0x1bd/0x240
 device_add+0xd3d/0x1100
 w1_add_master_device+0x476/0x490 [wire]
 ds2482_probe+0x303/0x3e0 [ds2482]

This is how it happened:

w1_alloc_dev()
  // The dev->driver is set to w1_master_driver.
  memcpy(&dev->dev, device, sizeof(struct device));
  device_add()
    bus_add_device()
    dpm_sysfs_add() // It fails, calls bus_remove_device.

    // error path
    bus_remove_device()
      // The dev->driver is not null, but driver is not bound.
      __device_release_driver()
        klist_remove(&dev->p->knode_driver) <-- It causes null-ptr-deref.

    // normal path
    bus_probe_device() // It's not called yet.
      device_bind_driver()

If dev->driver is set, in the error path after calling bus_add_device()
in device_add(), bus_remove_device() is called, then the device will be
detached from driver. But device_bind_driver() is not called yet, so it
causes null-ptr-deref while access the 'knode_driver'. To fix this, set
dev->driver to null in the error path before calling bus_remove_device().</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2023-54320" data-description="in the linux kernel, the following vulnerability has been resolved:

platform/x86/amd: pmc: fix memory leak in amd_pmc_stb_debugfs_open_v2()

function amd_pmc_stb_debugfs_open_v2() may be called when the stb
debug mechanism enabled.

when amd_pmc_send_cmd() fails, the 'buf' needs to be released.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2023-54320" target="_blank">CVE-2023-54320</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-12-30 07:16:21 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">N/A</span></p>
                    <p><span class="feed-label">CVSS Score:</span> N/A</p>
                    <p>In the Linux kernel, the following vulnerability has been resolved:

platform/x86/amd: pmc: Fix memory leak in amd_pmc_stb_debugfs_open_v2()

Function amd_pmc_stb_debugfs_open_v2() may be called when the STB
debug mechanism enabled.

When amd_pmc_send_cmd() fails, the 'buf' needs to be released.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2023-54319" data-description="in the linux kernel, the following vulnerability has been resolved:

pinctrl: at91-pio4: check return value of devm_kasprintf()

devm_kasprintf() returns a pointer to dynamically allocated memory.
pointer could be null in case allocation fails. check pointer validity.
identified with coccinelle (kmerr.cocci script).

depends-on: 1c4e5c470a56 ("pinctrl: at91: use devm_kasprintf() to avoid potential leaks")
depends-on: 5a8f9cf269e8 ("pinctrl: at91-pio4: use proper format specifier for unsigned int")">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2023-54319" target="_blank">CVE-2023-54319</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-12-30 07:16:21 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">N/A</span></p>
                    <p><span class="feed-label">CVSS Score:</span> N/A</p>
                    <p>In the Linux kernel, the following vulnerability has been resolved:

pinctrl: at91-pio4: check return value of devm_kasprintf()

devm_kasprintf() returns a pointer to dynamically allocated memory.
Pointer could be NULL in case allocation fails. Check pointer validity.
Identified with coccinelle (kmerr.cocci script).

Depends-on: 1c4e5c470a56 ("pinctrl: at91: use devm_kasprintf() to avoid potential leaks")
Depends-on: 5a8f9cf269e8 ("pinctrl: at91-pio4: use proper format specifier for unsigned int")</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2023-54318" data-description="in the linux kernel, the following vulnerability has been resolved:

net/smc: use smc_lgr_list.lock to protect smc_lgr_list.list iterate in smcr_port_add

while doing smcr_port_add, there maybe linkgroup add into or delete
from smc_lgr_list.list at the same time, which may result kernel crash.
so, use smc_lgr_list.lock to protect smc_lgr_list.list iterate in
smcr_port_add.

the crash calltrace show below:
bug: kernel null pointer dereference, address: 0000000000000000
pgd 0 p4d 0
oops: 0000 [#1] smp nopti
cpu: 0 pid: 559726 comm: kworker/0:92 kdump: loaded tainted: g
hardware name: alibaba cloud alibaba cloud ecs, bios 449e491 04/01/2014
workqueue: events smc_ib_port_event_work [smc]
rip: 0010:smcr_port_add+0xa6/0xf0 [smc]
rsp: 0000:ffffa5a2c8f67de0 eflags: 00010297
rax: 0000000000000001 rbx: ffff9935e0650000 rcx: 0000000000000000
rdx: 0000000000000010 rsi: ffff9935e0654290 rdi: ffff9935c8560000
rbp: 0000000000000000 r08: 0000000000000000 r09: ffff9934c0401918
r10: 0000000000000000 r11: ffffffffb4a5c278 r12: ffff99364029aae4
r13: ffff99364029aa00 r14: 00000000ffffffed r15: ffff99364029ab08
fs:  0000000000000000(0000) gs:ffff994380600000(0000) knlgs:0000000000000000
cs:  0010 ds: 0000 es: 0000 cr0: 0000000080050033
cr2: 0000000000000000 cr3: 0000000f06a10003 cr4: 0000000002770ef0
pkru: 55555554
call trace:
 smc_ib_port_event_work+0x18f/0x380 [smc]
 process_one_work+0x19b/0x340
 worker_thread+0x30/0x370
 ? process_one_work+0x340/0x340
 kthread+0x114/0x130
 ? __kthread_cancel_work+0x50/0x50
 ret_from_fork+0x1f/0x30">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2023-54318" target="_blank">CVE-2023-54318</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-12-30 07:16:21 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">N/A</span></p>
                    <p><span class="feed-label">CVSS Score:</span> N/A</p>
                    <p>In the Linux kernel, the following vulnerability has been resolved:

net/smc: use smc_lgr_list.lock to protect smc_lgr_list.list iterate in smcr_port_add

While doing smcr_port_add, there maybe linkgroup add into or delete
from smc_lgr_list.list at the same time, which may result kernel crash.
So, use smc_lgr_list.lock to protect smc_lgr_list.list iterate in
smcr_port_add.

The crash calltrace show below:
BUG: kernel NULL pointer dereference, address: 0000000000000000
PGD 0 P4D 0
Oops: 0000 [#1] SMP NOPTI
CPU: 0 PID: 559726 Comm: kworker/0:92 Kdump: loaded Tainted: G
Hardware name: Alibaba Cloud Alibaba Cloud ECS, BIOS 449e491 04/01/2014
Workqueue: events smc_ib_port_event_work [smc]
RIP: 0010:smcr_port_add+0xa6/0xf0 [smc]
RSP: 0000:ffffa5a2c8f67de0 EFLAGS: 00010297
RAX: 0000000000000001 RBX: ffff9935e0650000 RCX: 0000000000000000
RDX: 0000000000000010 RSI: ffff9935e0654290 RDI: ffff9935c8560000
RBP: 0000000000000000 R08: 0000000000000000 R09: ffff9934c0401918
R10: 0000000000000000 R11: ffffffffb4a5c278 R12: ffff99364029aae4
R13: ffff99364029aa00 R14: 00000000ffffffed R15: ffff99364029ab08
FS:  0000000000000000(0000) GS:ffff994380600000(0000) knlGS:0000000000000000
CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
CR2: 0000000000000000 CR3: 0000000f06a10003 CR4: 0000000002770ef0
PKRU: 55555554
Call Trace:
 smc_ib_port_event_work+0x18f/0x380 [smc]
 process_one_work+0x19b/0x340
 worker_thread+0x30/0x370
 ? process_one_work+0x340/0x340
 kthread+0x114/0x130
 ? __kthread_cancel_work+0x50/0x50
 ret_from_fork+0x1f/0x30</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2023-54317" data-description="in the linux kernel, the following vulnerability has been resolved:

dm flakey: don't corrupt the zero page

when we need to zero some range on a block device, the function
__blkdev_issue_zero_pages submits a write bio with the bio vector pointing
to the zero page. if we use dm-flakey with corrupt bio writes option, it
will corrupt the content of the zero page which results in crashes of
various userspace programs. glibc assumes that memory returned by mmap is
zeroed and it uses it for calloc implementation; if the newly mapped
memory is not zeroed, calloc will return non-zeroed memory.

fix this bug by testing if the page is equal to zero_page(0) and
avoiding the corruption in this case.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2023-54317" target="_blank">CVE-2023-54317</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-12-30 07:16:20 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">N/A</span></p>
                    <p><span class="feed-label">CVSS Score:</span> N/A</p>
                    <p>In the Linux kernel, the following vulnerability has been resolved:

dm flakey: don't corrupt the zero page

When we need to zero some range on a block device, the function
__blkdev_issue_zero_pages submits a write bio with the bio vector pointing
to the zero page. If we use dm-flakey with corrupt bio writes option, it
will corrupt the content of the zero page which results in crashes of
various userspace programs. Glibc assumes that memory returned by mmap is
zeroed and it uses it for calloc implementation; if the newly mapped
memory is not zeroed, calloc will return non-zeroed memory.

Fix this bug by testing if the page is equal to ZERO_PAGE(0) and
avoiding the corruption in this case.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2023-54316" data-description="in the linux kernel, the following vulnerability has been resolved:

refscale: fix uninitalized use of wait_queue_head_t

running the refscale test occasionally crashes the kernel with the
following error:

[ 8569.952896] bug: unable to handle page fault for address: ffffffffffffffe8
[ 8569.952900] #pf: supervisor read access in kernel mode
[ 8569.952902] #pf: error_code(0x0000) - not-present page
[ 8569.952904] pgd c4b048067 p4d c4b049067 pud c4b04b067 pmd 0
[ 8569.952910] oops: 0000 [#1] preempt_rt smp nopti
[ 8569.952916] hardware name: dell inc. poweredge r750/0wmwcr, bios 1.2.4 05/28/2021
[ 8569.952917] rip: 0010:prepare_to_wait_event+0x101/0x190
  :
[ 8569.952940] call trace:
[ 8569.952941]  <task>
[ 8569.952944]  ref_scale_reader+0x380/0x4a0 [refscale]
[ 8569.952959]  kthread+0x10e/0x130
[ 8569.952966]  ret_from_fork+0x1f/0x30
[ 8569.952973]  </task>

the likely cause is that init_waitqueue_head() is called after the call to
the torture_create_kthread() function that creates the ref_scale_reader
kthread.  although this init_waitqueue_head() call will very likely
complete before this kthread is created and starts running, it is
possible that the calling kthread will be delayed between the calls to
torture_create_kthread() and init_waitqueue_head().  in this case, the
new kthread will use the waitqueue head before it is properly initialized,
which is not good for the kernel's health and well-being.

the above crash happened here:

	static inline void __add_wait_queue(...)
	{
		:
		if (!(wq->flags & wq_flag_priority)) <=== crash here

the offset of flags from list_head entry in wait_queue_entry is
-0x18. if reader_tasks[i].wq.head.next is null as allocated reader_task
structure is zero initialized, the instruction will try to access address
0xffffffffffffffe8, which is exactly the fault address listed above.

this commit therefore invokes init_waitqueue_head() before creating
the kthread.">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2023-54316" target="_blank">CVE-2023-54316</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-12-30 07:16:20 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">N/A</span></p>
                    <p><span class="feed-label">CVSS Score:</span> N/A</p>
                    <p>In the Linux kernel, the following vulnerability has been resolved:

refscale: Fix uninitalized use of wait_queue_head_t

Running the refscale test occasionally crashes the kernel with the
following error:

[ 8569.952896] BUG: unable to handle page fault for address: ffffffffffffffe8
[ 8569.952900] #PF: supervisor read access in kernel mode
[ 8569.952902] #PF: error_code(0x0000) - not-present page
[ 8569.952904] PGD c4b048067 P4D c4b049067 PUD c4b04b067 PMD 0
[ 8569.952910] Oops: 0000 [#1] PREEMPT_RT SMP NOPTI
[ 8569.952916] Hardware name: Dell Inc. PowerEdge R750/0WMWCR, BIOS 1.2.4 05/28/2021
[ 8569.952917] RIP: 0010:prepare_to_wait_event+0x101/0x190
  :
[ 8569.952940] Call Trace:
[ 8569.952941]  <TASK>
[ 8569.952944]  ref_scale_reader+0x380/0x4a0 [refscale]
[ 8569.952959]  kthread+0x10e/0x130
[ 8569.952966]  ret_from_fork+0x1f/0x30
[ 8569.952973]  </TASK>

The likely cause is that init_waitqueue_head() is called after the call to
the torture_create_kthread() function that creates the ref_scale_reader
kthread.  Although this init_waitqueue_head() call will very likely
complete before this kthread is created and starts running, it is
possible that the calling kthread will be delayed between the calls to
torture_create_kthread() and init_waitqueue_head().  In this case, the
new kthread will use the waitqueue head before it is properly initialized,
which is not good for the kernel's health and well-being.

The above crash happened here:

	static inline void __add_wait_queue(...)
	{
		:
		if (!(wq->flags & WQ_FLAG_PRIORITY)) <=== Crash here

The offset of flags from list_head entry in wait_queue_entry is
-0x18. If reader_tasks[i].wq.head.next is NULL as allocated reader_task
structure is zero initialized, the instruction will try to access address
0xffffffffffffffe8, which is exactly the fault address listed above.

This commit therefore invokes init_waitqueue_head() before creating
the kthread.</p>
                </div>
        
                <div class="cve-entry" data-cve-id="CVE-2023-54315" data-description="in the linux kernel, the following vulnerability has been resolved:

powerpc/powernv/sriov: perform null check on iov before dereferencing iov

currently pointer iov is being dereferenced before the null check of iov
which can lead to null pointer dereference errors. fix this by moving the
iov null check before the dereferencing.

detected using cppcheck static analysis:
linux/arch/powerpc/platforms/powernv/pci-sriov.c:597:12: warning: either
the condition '!iov' is redundant or there is possible null pointer
dereference: iov. [nullpointerredundantcheck]
 num_vfs = iov->num_vfs;
           ^">
                    <h2><a class="contact-button" href="https://nvd.nist.gov/vuln/detail/CVE-2023-54315" target="_blank">CVE-2023-54315</a></h2>
                    <p><span class="feed-label">Published:</span> 2025-12-30 07:16:20 CDT</p>
                    <p><span class="feed-label">Severity:</span> <span class="status-offline">N/A</span></p>
                    <p><span class="feed-label">CVSS Score:</span> N/A</p>
                    <p>In the Linux kernel, the following vulnerability has been resolved:

powerpc/powernv/sriov: perform null check on iov before dereferencing iov

Currently pointer iov is being dereferenced before the null check of iov
which can lead to null pointer dereference errors. Fix this by moving the
iov null check before the dereferencing.

Detected using cppcheck static analysis:
linux/arch/powerpc/platforms/powernv/pci-sriov.c:597:12: warning: Either
the condition '!iov' is redundant or there is possible null pointer
dereference: iov. [nullPointerRedundantCheck]
 num_vfs = iov->num_vfs;
           ^</p>
                </div>
        
            </div>
        </div>

        <footer class="footer">
            <p>© 2025 dotne1 - Cybersecurity Portfolio</p>
        </footer>

        <script>
            function searchCVEs() {
                const input = document.getElementById('searchInput').value.toLowerCase();
                const cveEntries = document.getElementsByClassName('cve-entry');
                for (let i = 0; i < cveEntries.length; i++) {
                    const cveId = cveEntries[i].getAttribute('data-cve-id').toLowerCase();
                    const description = cveEntries[i].getAttribute('data-description');
                    if (cveId.includes(input) || description.includes(input)) {
                        cveEntries[i].style.display = '';
                    } else {
                        cveEntries[i].style.display = 'none';
                    }
                }
            }
        </script>
    </body>
    </html>
    